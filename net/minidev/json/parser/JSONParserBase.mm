//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/minidev/json/parser/JSONParserBase.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/lang/Boolean.h"
#include "java/lang/Character.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/math/BigDecimal.h"
#include "java/math/BigInteger.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "net/minidev/json/parser/ContainerFactory.h"
#include "net/minidev/json/parser/ContentHandler.h"
#include "net/minidev/json/parser/JSONParser.h"
#include "net/minidev/json/parser/JSONParserBase.h"
#include "net/minidev/json/parser/ParseException.h"

J2OBJC_INITIALIZED_DEFN(NetMinidevJsonParserJSONParserBase)

IOSBooleanArray *NetMinidevJsonParserJSONParserBase_stopAll;
IOSBooleanArray *NetMinidevJsonParserJSONParserBase_stopArray;
IOSBooleanArray *NetMinidevJsonParserJSONParserBase_stopKey;
IOSBooleanArray *NetMinidevJsonParserJSONParserBase_stopValue;
IOSBooleanArray *NetMinidevJsonParserJSONParserBase_stopX;

@implementation NetMinidevJsonParserJSONParserBase

+ (jbyte)EOI {
  return NetMinidevJsonParserJSONParserBase_EOI;
}

+ (jchar)MAX_STOP {
  return NetMinidevJsonParserJSONParserBase_MAX_STOP;
}

+ (IOSBooleanArray *)stopAll {
  return NetMinidevJsonParserJSONParserBase_stopAll;
}

+ (void)setStopAll:(IOSBooleanArray *)value {
  JreStrongAssign(&NetMinidevJsonParserJSONParserBase_stopAll, value);
}

+ (IOSBooleanArray *)stopArray {
  return NetMinidevJsonParserJSONParserBase_stopArray;
}

+ (void)setStopArray:(IOSBooleanArray *)value {
  JreStrongAssign(&NetMinidevJsonParserJSONParserBase_stopArray, value);
}

+ (IOSBooleanArray *)stopKey {
  return NetMinidevJsonParserJSONParserBase_stopKey;
}

+ (void)setStopKey:(IOSBooleanArray *)value {
  JreStrongAssign(&NetMinidevJsonParserJSONParserBase_stopKey, value);
}

+ (IOSBooleanArray *)stopValue {
  return NetMinidevJsonParserJSONParserBase_stopValue;
}

+ (void)setStopValue:(IOSBooleanArray *)value {
  JreStrongAssign(&NetMinidevJsonParserJSONParserBase_stopValue, value);
}

+ (IOSBooleanArray *)stopX {
  return NetMinidevJsonParserJSONParserBase_stopX;
}

+ (void)setStopX:(IOSBooleanArray *)value {
  JreStrongAssign(&NetMinidevJsonParserJSONParserBase_stopX, value);
}

- (instancetype)initWithInt:(jint)permissiveMode {
  NetMinidevJsonParserJSONParserBase_initWithInt_(self, permissiveMode);
  return self;
}

- (void)checkControleChar {
  if (ignoreControlChar_) return;
  jint l = [((NSString *) nil_chk(xs_)) java_length];
  for (jint i = 0; i < l; i++) {
    jchar c = [((NSString *) nil_chk(xs_)) charAtWithInt:i];
    if (c < 0) continue;
    if (c <= 31) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ + i, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c));
    if (c == 127) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ + i, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c));
  }
}

- (void)checkLeadinZero {
  jint len = [((NSString *) nil_chk(xs_)) java_length];
  if (len == 1) return;
  if (len == 2) {
    if ([((NSString *) nil_chk(xs_)) isEqual:@"00"]) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_LEADING_0, xs_);
    return;
  }
  jchar c1 = [((NSString *) nil_chk(xs_)) charAtWithInt:0];
  jchar c2 = [((NSString *) nil_chk(xs_)) charAtWithInt:1];
  if (c1 == '-') {
    jchar c3 = [((NSString *) nil_chk(xs_)) charAtWithInt:2];
    if (c2 == '0' && c3 >= '0' && c3 <= '9') @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_LEADING_0, xs_);
    return;
  }
  if (c1 == '0' && c2 >= '0' && c2 <= '9') @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_LEADING_0, xs_);
}

- (NSNumber *)extractFloat {
  if (!acceptLeadinZero_) [self checkLeadinZero];
  if (!useHiPrecisionFloat_) return JavaLangFloat_valueOfWithFloat_(JavaLangFloat_parseFloatWithNSString_(xs_));
  if ([((NSString *) nil_chk(xs_)) java_length] > 18) return create_JavaMathBigDecimal_initWithNSString_(xs_);
  return JavaLangDouble_valueOfWithDouble_(JavaLangDouble_parseDoubleWithNSString_(xs_));
}

- (id)parseWithNetMinidevJsonParserContainerFactory:(id<NetMinidevJsonParserContainerFactory>)containerFactory
             withNetMinidevJsonParserContentHandler:(id<NetMinidevJsonParserContentHandler>)handler {
  JreStrongAssign(&self->containerFactory_, containerFactory);
  JreStrongAssign(&self->handler_, handler);
  id result;
  @try {
    [self read];
    [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler)) startJSON];
    result = [self readMainWithBooleanArray:NetMinidevJsonParserJSONParserBase_stopX];
    [handler endJSON];
    if (checkTaillingData_) {
      if (!checkTaillingSpace_) [self skipSpace];
      if (c_ != NetMinidevJsonParserJSONParserBase_EOI) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, JavaLangCharacter_valueOfWithChar_(c_));
    }
  }
  @catch (JavaIoIOException *e) {
    @throw create_NetMinidevJsonParserParseException_initWithInt_withJavaLangThrowable_(pos_, e);
  }
  JreStrongAssign(&xs_, nil);
  JreStrongAssign(&xo_, nil);
  return result;
}

- (NSNumber *)parseNumberWithNSString:(NSString *)s {
  jint p = 0;
  jint l = [((NSString *) nil_chk(s)) java_length];
  jint max = 19;
  jboolean neg;
  if ([s charAtWithInt:0] == '-') {
    p++;
    max++;
    neg = true;
    if (!acceptLeadinZero_ && l >= 3 && [s charAtWithInt:1] == '0') @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_LEADING_0, s);
  }
  else {
    neg = false;
    if (!acceptLeadinZero_ && l >= 2 && [s charAtWithInt:0] == '0') @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_LEADING_0, s);
  }
  jboolean mustCheck;
  if (l < max) {
    max = l;
    mustCheck = false;
  }
  else if (l > max) {
    return create_JavaMathBigInteger_initWithNSString_withInt_(s, 10);
  }
  else {
    max = l - 1;
    mustCheck = true;
  }
  jlong r = 0;
  while (p < max) {
    r = (r * 10LL) + ('0' - [s charAtWithInt:p++]);
  }
  if (mustCheck) {
    jboolean isBig;
    if (r > -922337203685477580LL) {
      isBig = false;
    }
    else if (r < -922337203685477580LL) {
      isBig = true;
    }
    else {
      if (neg) isBig = ([s charAtWithInt:p] > '8');
      else isBig = ([s charAtWithInt:p] > '7');
    }
    if (isBig) return create_JavaMathBigInteger_initWithNSString_withInt_(s, 10);
    r = r * 10LL + ('0' - [s charAtWithInt:p]);
  }
  if (neg) {
    if (self->useIntegerStorage_ && r >= JavaLangInteger_MIN_VALUE) return JavaLangInteger_valueOfWithInt_((jint) r);
    return JavaLangLong_valueOfWithLong_(r);
  }
  r = -r;
  if (self->useIntegerStorage_ && r <= JavaLangInteger_MAX_VALUE) return JavaLangInteger_valueOfWithInt_((jint) r);
  return JavaLangLong_valueOfWithLong_(r);
}

- (void)read {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (id<JavaUtilList>)readArray {
  id<JavaUtilList> obj = [((id<NetMinidevJsonParserContainerFactory>) nil_chk(containerFactory_)) createArrayContainer];
  if (c_ != '[') @throw create_JavaLangRuntimeException_initWithNSString_(@"Internal Error");
  [self read];
  jboolean needData = false;
  [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) startArray];
  for (; ; ) {
    switch (c_) {
      case ' ':
      case 0x000d:
      case 0x000a:
      case 0x0009:
      [self read];
      continue;
      case ']':
      if (needData && !acceptUselessComma_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_((jchar) c_));
      [self read];
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) endArray];
      return obj;
      case ':':
      case '}':
      @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_((jchar) c_));
      case ',':
      if (needData && !acceptUselessComma_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_((jchar) c_));
      [self read];
      needData = true;
      continue;
      case NetMinidevJsonParserJSONParserBase_EOI:
      @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_EOF, @"EOF");
      default:
      [((id<JavaUtilList>) nil_chk(obj)) addWithId:[self readMainWithBooleanArray:NetMinidevJsonParserJSONParserBase_stopArray]];
      needData = false;
      continue;
    }
  }
}

- (id)readMainWithBooleanArray:(IOSBooleanArray *)stop {
  for (; ; ) {
    switch (c_) {
      case ' ':
      case 0x000d:
      case 0x000a:
      case 0x0009:
      [self read];
      continue;
      case ':':
      case '}':
      case ']':
      @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c_));
      case '{':
      return [self readObject];
      case '[':
      return [self readArray];
      case '"':
      case '\'':
      [self readString];
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
      case 'n':
      [self readNQStringWithBooleanArray:stop];
      if ([@"null" isEqual:xs_]) {
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:nil];
        return nil;
      }
      if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
      case 'f':
      [self readNQStringWithBooleanArray:stop];
      if ([@"false" isEqual:xs_]) {
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:JreLoadStatic(JavaLangBoolean, FALSE)];
        return JreLoadStatic(JavaLangBoolean, FALSE);
      }
      if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
      case 't':
      [self readNQStringWithBooleanArray:stop];
      if ([@"true" isEqual:xs_]) {
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:JreLoadStatic(JavaLangBoolean, TRUE)];
        return JreLoadStatic(JavaLangBoolean, TRUE);
      }
      if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
      case 'N':
      [self readNQStringWithBooleanArray:stop];
      if (!acceptNaN_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      if ([@"NaN" isEqual:xs_]) {
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:JavaLangFloat_valueOfWithFloat_(JavaLangFloat_NaN)];
        return JavaLangFloat_valueOfWithFloat_(JavaLangFloat_NaN);
      }
      if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
      JreStrongAssign(&xo_, [self readNumberWithBooleanArray:stop]);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xo_];
      return xo_;
      default:
      [self readNQStringWithBooleanArray:stop];
      if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
      [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) primitiveWithId:xs_];
      return xs_;
    }
  }
}

- (void)readNoEnd {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)readNQStringWithBooleanArray:(IOSBooleanArray *)stop {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (id)readNumberWithBooleanArray:(IOSBooleanArray *)stop {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<JavaUtilMap>)readObject {
  id<JavaUtilMap> obj = [((id<NetMinidevJsonParserContainerFactory>) nil_chk(self->containerFactory_)) createObjectContainer];
  if (c_ != '{') @throw create_JavaLangRuntimeException_initWithNSString_(@"Internal Error");
  [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) startObject];
  jboolean needData = false;
  jboolean acceptData = true;
  for (; ; ) {
    [self read];
    {
      jint keyStart;
      NSString *key;
      id duplicate;
      switch (c_) {
        case ' ':
        case 0x000d:
        case 0x0009:
        case 0x000a:
        continue;
        case ':':
        case ']':
        case '[':
        case '{':
        @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c_));
        case '}':
        if (needData && !acceptUselessComma_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_((jchar) c_));
        [self read];
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) endObject];
        return obj;
        case ',':
        if (needData && !acceptUselessComma_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_((jchar) c_));
        acceptData = needData = true;
        continue;
        case '"':
        case '\'':
        default:
        keyStart = pos_;
        if (c_ == '"' || c_ == '\'') {
          [self readString];
        }
        else {
          [self readNQStringWithBooleanArray:NetMinidevJsonParserJSONParserBase_stopKey];
          if (!acceptNonQuote_) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, xs_);
        }
        key = xs_;
        if (!acceptData) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, key);
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) startObjectEntryWithNSString:key];
        [self skipSpace];
        if (c_ != ':') {
          if (c_ == NetMinidevJsonParserJSONParserBase_EOI) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_EOF, nil);
          @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c_));
        }
        [self readNoEnd];
        duplicate = [((id<JavaUtilMap>) nil_chk(obj)) putWithId:key withId:[self readMainWithBooleanArray:NetMinidevJsonParserJSONParserBase_stopValue]];
        if (duplicate != nil) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(keyStart, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_DUPLICATE_KEY, key);
        [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) endObjectEntry];
        [self skipSpace];
        if (c_ == '}') {
          [self read];
          [((id<NetMinidevJsonParserContentHandler>) nil_chk(handler_)) endObject];
          return obj;
        }
        if (c_ == NetMinidevJsonParserJSONParserBase_EOI) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_EOF, nil);
        if (c_ == ',') acceptData = needData = true;
        else @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_TOKEN, JavaLangCharacter_valueOfWithChar_(c_));
      }
    }
  }
}

- (void)readS {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)readString {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)readString2 {
  jchar sep = c_;
  for (; ; ) {
    [self read];
    switch (c_) {
      case NetMinidevJsonParserJSONParserBase_EOI:
      @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_ - 1, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_EOF, nil);
      case '"':
      case '\'':
      if (sep == c_) {
        [self read];
        JreStrongAssign(&xs_, [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) description]);
        return;
      }
      [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:c_];
      break;
      case '\\':
      [self read];
      switch (c_) {
        case 't':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:0x0009];
        break;
        case 'n':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:0x000a];
        break;
        case 'r':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:0x000d];
        break;
        case 'f':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:0x000c];
        break;
        case 'b':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:0x0008];
        break;
        case '\\':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:'\\'];
        break;
        case '/':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:'/'];
        break;
        case '\'':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:'\''];
        break;
        case '"':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:'"'];
        break;
        case 'u':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:[self readUnicodeWithInt:4]];
        break;
        case 'x':
        [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:[self readUnicodeWithInt:2]];
        default:
        break;
      }
      break;
      case 0x0000:
      case (jchar) 1:
      case (jchar) 2:
      case (jchar) 3:
      case (jchar) 4:
      case (jchar) 5:
      case (jchar) 6:
      case (jchar) 7:
      case 0x0008:
      case 0x0009:
      case 0x000a:
      case (jchar) 11:
      case 0x000c:
      case 0x000d:
      case (jchar) 14:
      case (jchar) 15:
      case (jchar) 16:
      case (jchar) 17:
      case (jchar) 18:
      case (jchar) 19:
      case (jchar) 20:
      case (jchar) 21:
      case (jchar) 22:
      case (jchar) 23:
      case (jchar) 24:
      case (jchar) 25:
      case (jchar) 27:
      case (jchar) 28:
      case (jchar) 29:
      case (jchar) 30:
      case (jchar) 31:
      case (jchar) 127:
      if (ignoreControlChar_) continue;
      @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_CHAR, JavaLangCharacter_valueOfWithChar_(c_));
      default:
      [((NetMinidevJsonParserJSONParserBase_MSB *) nil_chk(sb_)) appendWithChar:c_];
    }
  }
}

- (jchar)readUnicodeWithInt:(jint)totalChars {
  jint value = 0;
  for (jint i = 0; i < totalChars; i++) {
    value = value * 16;
    [self read];
    if (c_ <= '9' && c_ >= '0') value += c_ - '0';
    else if (c_ <= 'F' && c_ >= 'A') value += (c_ - 'A') + 10;
    else if (c_ >= 'a' && c_ <= 'f') value += (c_ - 'a') + 10;
    else if (c_ == NetMinidevJsonParserJSONParserBase_EOI) @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_EOF, @"EOF");
    else @throw create_NetMinidevJsonParserParseException_initWithInt_withInt_withId_(pos_, NetMinidevJsonParserParseException_ERROR_UNEXPECTED_UNICODE, JavaLangCharacter_valueOfWithChar_(c_));
  }
  return (jchar) value;
}

- (void)skipDigits {
  for (; ; ) {
    if (c_ < '0' || c_ > '9') return;
    [self readS];
  }
}

- (void)skipNQStringWithBooleanArray:(IOSBooleanArray *)stop {
  for (; ; ) {
    if ((c_ == NetMinidevJsonParserJSONParserBase_EOI) || (c_ >= 0 && c_ < NetMinidevJsonParserJSONParserBase_MAX_STOP && IOSBooleanArray_Get(nil_chk(stop), c_))) return;
    [self readS];
  }
}

- (void)skipSpace {
  for (; ; ) {
    if (c_ > ' ' || c_ == NetMinidevJsonParserJSONParserBase_EOI) return;
    [self readS];
  }
}

- (void)dealloc {
  RELEASE_(containerFactory_);
  RELEASE_(handler_);
  RELEASE_(sb_);
  RELEASE_(xo_);
  RELEASE_(xs_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "LNSNumber;", 0x4, -1, -1, 1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x4, 2, 3, 1, -1, -1, -1 },
    { NULL, "LNSNumber;", 0x4, 4, 5, 1, -1, -1, -1 },
    { NULL, "V", 0x404, -1, -1, 6, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x4, -1, -1, 7, 8, -1, -1 },
    { NULL, "LNSObject;", 0x4, 9, 10, 7, -1, -1, -1 },
    { NULL, "V", 0x404, -1, -1, 7, -1, -1, -1 },
    { NULL, "V", 0x404, 11, 10, 6, -1, -1, -1 },
    { NULL, "LNSObject;", 0x404, 12, 10, 7, -1, -1, -1 },
    { NULL, "LJavaUtilMap;", 0x4, -1, -1, 7, 13, -1, -1 },
    { NULL, "V", 0x400, -1, -1, 6, -1, -1, -1 },
    { NULL, "V", 0x404, -1, -1, 7, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 7, -1, -1, -1 },
    { NULL, "C", 0x4, 14, 0, 7, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 6, -1, -1, -1 },
    { NULL, "V", 0x4, 15, 10, 6, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 6, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithInt:);
  methods[1].selector = @selector(checkControleChar);
  methods[2].selector = @selector(checkLeadinZero);
  methods[3].selector = @selector(extractFloat);
  methods[4].selector = @selector(parseWithNetMinidevJsonParserContainerFactory:withNetMinidevJsonParserContentHandler:);
  methods[5].selector = @selector(parseNumberWithNSString:);
  methods[6].selector = @selector(read);
  methods[7].selector = @selector(readArray);
  methods[8].selector = @selector(readMainWithBooleanArray:);
  methods[9].selector = @selector(readNoEnd);
  methods[10].selector = @selector(readNQStringWithBooleanArray:);
  methods[11].selector = @selector(readNumberWithBooleanArray:);
  methods[12].selector = @selector(readObject);
  methods[13].selector = @selector(readS);
  methods[14].selector = @selector(readString);
  methods[15].selector = @selector(readString2);
  methods[16].selector = @selector(readUnicodeWithInt:);
  methods[17].selector = @selector(skipDigits);
  methods[18].selector = @selector(skipNQStringWithBooleanArray:);
  methods[19].selector = @selector(skipSpace);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "c_", "C", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "EOI", "B", .constantValue.asChar = NetMinidevJsonParserJSONParserBase_EOI, 0x19, -1, -1, -1, -1 },
    { "MAX_STOP", "C", .constantValue.asUnichar = NetMinidevJsonParserJSONParserBase_MAX_STOP, 0x1c, -1, -1, -1, -1 },
    { "stopAll", "[Z", .constantValue.asLong = 0, 0xc, -1, 16, -1, -1 },
    { "stopArray", "[Z", .constantValue.asLong = 0, 0xc, -1, 17, -1, -1 },
    { "stopKey", "[Z", .constantValue.asLong = 0, 0xc, -1, 18, -1, -1 },
    { "stopValue", "[Z", .constantValue.asLong = 0, 0xc, -1, 19, -1, -1 },
    { "stopX", "[Z", .constantValue.asLong = 0, 0xc, -1, 20, -1, -1 },
    { "containerFactory_", "LNetMinidevJsonParserContainerFactory;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "handler_", "LNetMinidevJsonParserContentHandler;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "sb_", "LNetMinidevJsonParserJSONParserBase_MSB;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "xo_", "LNSObject;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "xs_", "LNSString;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "acceptLeadinZero_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "acceptNaN_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "acceptNonQuote_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "acceptSimpleQuote_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "acceptUselessComma_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "checkTaillingData_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "checkTaillingSpace_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "ignoreControlChar_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "useHiPrecisionFloat_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "useIntegerStorage_", "Z", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "I", "LNetMinidevJsonParserParseException;", "parse", "LNetMinidevJsonParserContainerFactory;LNetMinidevJsonParserContentHandler;", "parseNumber", "LNSString;", "LJavaIoIOException;", "LNetMinidevJsonParserParseException;LJavaIoIOException;", "()Ljava/util/List<Ljava/lang/Object;>;", "readMain", "[Z", "readNQString", "readNumber", "()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;", "readUnicode", "skipNQString", &NetMinidevJsonParserJSONParserBase_stopAll, &NetMinidevJsonParserJSONParserBase_stopArray, &NetMinidevJsonParserJSONParserBase_stopKey, &NetMinidevJsonParserJSONParserBase_stopValue, &NetMinidevJsonParserJSONParserBase_stopX, "LNetMinidevJsonParserJSONParserBase_MSB;" };
  static const J2ObjcClassInfo _NetMinidevJsonParserJSONParserBase = { "JSONParserBase", "net.minidev.json.parser", ptrTable, methods, fields, 7, 0x400, 20, 24, -1, 21, -1, -1, -1 };
  return &_NetMinidevJsonParserJSONParserBase;
}

+ (void)initialize {
  if (self == [NetMinidevJsonParserJSONParserBase class]) {
    JreStrongAssignAndConsume(&NetMinidevJsonParserJSONParserBase_stopAll, [IOSBooleanArray newArrayWithLength:NetMinidevJsonParserJSONParserBase_MAX_STOP]);
    JreStrongAssignAndConsume(&NetMinidevJsonParserJSONParserBase_stopArray, [IOSBooleanArray newArrayWithLength:NetMinidevJsonParserJSONParserBase_MAX_STOP]);
    JreStrongAssignAndConsume(&NetMinidevJsonParserJSONParserBase_stopKey, [IOSBooleanArray newArrayWithLength:NetMinidevJsonParserJSONParserBase_MAX_STOP]);
    JreStrongAssignAndConsume(&NetMinidevJsonParserJSONParserBase_stopValue, [IOSBooleanArray newArrayWithLength:NetMinidevJsonParserJSONParserBase_MAX_STOP]);
    JreStrongAssignAndConsume(&NetMinidevJsonParserJSONParserBase_stopX, [IOSBooleanArray newArrayWithLength:NetMinidevJsonParserJSONParserBase_MAX_STOP]);
    {
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopKey, ':') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopKey, NetMinidevJsonParserJSONParserBase_EOI) = true;
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopValue, ',') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopValue, '}') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopValue, NetMinidevJsonParserJSONParserBase_EOI) = true;
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopArray, ',') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopArray, ']') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopArray, NetMinidevJsonParserJSONParserBase_EOI) = true;
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopX, NetMinidevJsonParserJSONParserBase_EOI) = true;
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopAll, ',') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopAll, ':') = true;
      *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopAll, ']') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopAll, '}') = *IOSBooleanArray_GetRef(NetMinidevJsonParserJSONParserBase_stopAll, NetMinidevJsonParserJSONParserBase_EOI) = true;
    }
    J2OBJC_SET_INITIALIZED(NetMinidevJsonParserJSONParserBase)
  }
}

@end

void NetMinidevJsonParserJSONParserBase_initWithInt_(NetMinidevJsonParserJSONParserBase *self, jint permissiveMode) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->sb_, new_NetMinidevJsonParserJSONParserBase_MSB_initWithInt_(15));
  self->acceptNaN_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_NAN) > 0);
  self->acceptNonQuote_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_NON_QUOTE) > 0);
  self->acceptSimpleQuote_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_SIMPLE_QUOTE) > 0);
  self->ignoreControlChar_ = ((permissiveMode & NetMinidevJsonParserJSONParser_IGNORE_CONTROL_CHAR) > 0);
  self->useIntegerStorage_ = ((permissiveMode & NetMinidevJsonParserJSONParser_USE_INTEGER_STORAGE) > 0);
  self->acceptLeadinZero_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_LEADING_ZERO) > 0);
  self->acceptUselessComma_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_USELESS_COMMA) > 0);
  self->useHiPrecisionFloat_ = ((permissiveMode & NetMinidevJsonParserJSONParser_USE_HI_PRECISION_FLOAT) > 0);
  self->checkTaillingData_ = ((permissiveMode & (NetMinidevJsonParserJSONParser_ACCEPT_TAILLING_DATA | NetMinidevJsonParserJSONParser_ACCEPT_TAILLING_SPACE)) != (NetMinidevJsonParserJSONParser_ACCEPT_TAILLING_DATA | NetMinidevJsonParserJSONParser_ACCEPT_TAILLING_SPACE));
  self->checkTaillingSpace_ = ((permissiveMode & NetMinidevJsonParserJSONParser_ACCEPT_TAILLING_SPACE) == 0);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetMinidevJsonParserJSONParserBase)

@implementation NetMinidevJsonParserJSONParserBase_MSB

- (instancetype)initWithInt:(jint)size {
  NetMinidevJsonParserJSONParserBase_MSB_initWithInt_(self, size);
  return self;
}

- (void)appendWithChar:(jchar)c {
  p_++;
  if (((IOSCharArray *) nil_chk(b_))->size_ <= p_) {
    IOSCharArray *t = [IOSCharArray arrayWithLength:b_->size_ * 2 + 1];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(b_, 0, t, 0, b_->size_);
    JreStrongAssign(&b_, t);
  }
  *IOSCharArray_GetRef(b_, p_) = c;
}

- (void)appendWithInt:(jint)c {
  p_++;
  if (((IOSCharArray *) nil_chk(b_))->size_ <= p_) {
    IOSCharArray *t = [IOSCharArray arrayWithLength:b_->size_ * 2 + 1];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(b_, 0, t, 0, b_->size_);
    JreStrongAssign(&b_, t);
  }
  *IOSCharArray_GetRef(b_, p_) = (jchar) c;
}

- (NSString *)description {
  return [NSString java_stringWithCharacters:b_ offset:0 length:p_ + 1];
}

- (void)clear {
  p_ = -1;
}

- (void)dealloc {
  RELEASE_(b_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 3, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithInt:);
  methods[1].selector = @selector(appendWithChar:);
  methods[2].selector = @selector(appendWithInt:);
  methods[3].selector = @selector(description);
  methods[4].selector = @selector(clear);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "b_", "[C", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "p_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "I", "append", "C", "toString", "LNetMinidevJsonParserJSONParserBase;" };
  static const J2ObjcClassInfo _NetMinidevJsonParserJSONParserBase_MSB = { "MSB", "net.minidev.json.parser", ptrTable, methods, fields, 7, 0x9, 5, 2, 4, -1, -1, -1, -1 };
  return &_NetMinidevJsonParserJSONParserBase_MSB;
}

@end

void NetMinidevJsonParserJSONParserBase_MSB_initWithInt_(NetMinidevJsonParserJSONParserBase_MSB *self, jint size) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->b_, [IOSCharArray newArrayWithLength:size]);
  self->p_ = -1;
}

NetMinidevJsonParserJSONParserBase_MSB *new_NetMinidevJsonParserJSONParserBase_MSB_initWithInt_(jint size) {
  J2OBJC_NEW_IMPL(NetMinidevJsonParserJSONParserBase_MSB, initWithInt_, size)
}

NetMinidevJsonParserJSONParserBase_MSB *create_NetMinidevJsonParserJSONParserBase_MSB_initWithInt_(jint size) {
  J2OBJC_CREATE_IMPL(NetMinidevJsonParserJSONParserBase_MSB, initWithInt_, size)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetMinidevJsonParserJSONParserBase_MSB)
