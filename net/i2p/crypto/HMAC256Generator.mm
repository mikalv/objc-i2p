//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/HMAC256Generator.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/security/GeneralSecurityException.h"
#include "java/security/Key.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "javax/crypto/Mac.h"
#include "javax/crypto/spec/SecretKeySpec.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/HMAC256Generator.h"
#include "net/i2p/crypto/HMACGenerator.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/SessionKey.h"
#include "org/bouncycastle/oldcrypto/macs/I2PHMac.h"

@implementation NetI2pCryptoHMAC256Generator

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context {
  NetI2pCryptoHMAC256Generator_initWithNetI2pI2PAppContext_(self, context);
  return self;
}

- (OrgBouncycastleOldcryptoMacsI2PHMac *)acquire {
  @throw create_JavaLangUnsupportedOperationException_init();
}

- (NetI2pDataHash *)calculateWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                        withByteArray:(IOSByteArray *)data {
  @throw create_JavaLangUnsupportedOperationException_init();
}

- (void)calculateWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                            withByteArray:(IOSByteArray *)data
                                  withInt:(jint)offset
                                  withInt:(jint)length
                            withByteArray:(IOSByteArray *)target
                                  withInt:(jint)targetOffset {
  @try {
    JavaxCryptoMac *mac = JavaxCryptoMac_getInstanceWithNSString_(@"HmacSHA256");
    id<JavaSecurityKey> keyObj = create_JavaxCryptoSpecSecretKeySpec_initWithByteArray_withNSString_([((NetI2pDataSessionKey *) nil_chk(key)) getData], @"HmacSHA256");
    [((JavaxCryptoMac *) nil_chk(mac)) init__WithJavaSecurityKey:keyObj];
    [mac updateWithByteArray:data withInt:offset withInt:length];
    [mac doFinalWithByteArray:target withInt:targetOffset];
  }
  @catch (JavaSecurityNoSuchAlgorithmException *e) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_withJavaLangThrowable_(@"HmacSHA256", e);
  }
  @catch (JavaSecurityGeneralSecurityException *e) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_withJavaLangThrowable_(@"HmacSHA256", e);
  }
}

- (jboolean)verifyWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                             withByteArray:(IOSByteArray *)curData
                                   withInt:(jint)curOffset
                                   withInt:(jint)curLength
                             withByteArray:(IOSByteArray *)origMAC
                                   withInt:(jint)origMACOffset
                                   withInt:(jint)origMACLength {
  IOSByteArray *calc = [self acquireTmp];
  [self calculateWithNetI2pDataSessionKey:key withByteArray:curData withInt:curOffset withInt:curLength withByteArray:calc withInt:0];
  jboolean eq = NetI2pDataDataHelper_eqWithByteArray_withInt_withByteArray_withInt_withInt_(calc, 0, origMAC, origMACOffset, origMACLength);
  [self releaseTmpWithByteArray:calc];
  return eq;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LOrgBouncycastleOldcryptoMacsI2PHMac;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataHash;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 5, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(acquire);
  methods[2].selector = @selector(calculateWithNetI2pDataSessionKey:withByteArray:);
  methods[3].selector = @selector(calculateWithNetI2pDataSessionKey:withByteArray:withInt:withInt:withByteArray:withInt:);
  methods[4].selector = @selector(verifyWithNetI2pDataSessionKey:withByteArray:withInt:withInt:withByteArray:withInt:withInt:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "calculate", "LNetI2pDataSessionKey;[B", "LNetI2pDataSessionKey;[BII[BI", "verify", "LNetI2pDataSessionKey;[BII[BII" };
  static const J2ObjcClassInfo _NetI2pCryptoHMAC256Generator = { "HMAC256Generator", "net.i2p.crypto", ptrTable, methods, NULL, 7, 0x11, 5, 0, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoHMAC256Generator;
}

@end

void NetI2pCryptoHMAC256Generator_initWithNetI2pI2PAppContext_(NetI2pCryptoHMAC256Generator *self, NetI2pI2PAppContext *context) {
  NetI2pCryptoHMACGenerator_initWithNetI2pI2PAppContext_(self, context);
}

NetI2pCryptoHMAC256Generator *new_NetI2pCryptoHMAC256Generator_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_NEW_IMPL(NetI2pCryptoHMAC256Generator, initWithNetI2pI2PAppContext_, context)
}

NetI2pCryptoHMAC256Generator *create_NetI2pCryptoHMAC256Generator_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoHMAC256Generator, initWithNetI2pI2PAppContext_, context)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoHMAC256Generator)
