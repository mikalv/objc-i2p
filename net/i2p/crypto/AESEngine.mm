//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/AESEngine.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Exception.h"
#include "java/lang/System.h"
#include "java/lang/annotation/Annotation.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/AESEngine.h"
#include "net/i2p/crypto/ElGamalAESEngine.h"
#include "net/i2p/crypto/SHA256Generator.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/SimpleByteCache.h"

__attribute__((unused)) static IOSObjectArray *NetI2pCryptoAESEngine__Annotations$0(void);

__attribute__((unused)) static IOSObjectArray *NetI2pCryptoAESEngine__Annotations$1(void);

@implementation NetI2pCryptoAESEngine

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)ctx {
  NetI2pCryptoAESEngine_initWithNetI2pI2PAppContext_(self, ctx);
  return self;
}

- (void)encryptWithByteArray:(IOSByteArray *)payload
                     withInt:(jint)payloadIndex
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outIndex
    withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
               withByteArray:(IOSByteArray *)iv
                     withInt:(jint)length {
  [self encryptWithByteArray:payload withInt:payloadIndex withByteArray:outArg withInt:outIndex withNetI2pDataSessionKey:sessionKey withByteArray:iv withInt:0 withInt:length];
}

- (void)encryptWithByteArray:(IOSByteArray *)payload
                     withInt:(jint)payloadIndex
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outIndex
    withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
               withByteArray:(IOSByteArray *)iv
                     withInt:(jint)ivOffset
                     withInt:(jint)length {
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, payloadIndex, outArg, outIndex, length);
  [((NetI2pUtilLog *) nil_chk(_log_)) logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:@"AES is disabled"];
}

- (IOSByteArray *)safeEncryptWithByteArray:(IOSByteArray *)payload
                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
                             withByteArray:(IOSByteArray *)iv
                                   withInt:(jint)paddedSize {
  if ((iv == nil) || (payload == nil) || (sessionKey == nil) || (((IOSByteArray *) nil_chk(iv))->size_ != 16)) return nil;
  jint size = NetI2pDataHash_HASH_LENGTH + 4 + ((IOSByteArray *) nil_chk(payload))->size_;
  jint padding = NetI2pCryptoElGamalAESEngine_getPaddingSizeWithInt_withLong_(size, paddedSize);
  IOSByteArray *data = [IOSByteArray arrayWithLength:size + padding];
  [((NetI2pCryptoSHA256Generator *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) sha])) calculateHashWithByteArray:iv withInt:0 withInt:16 withByteArray:data withInt:0];
  jint cur = NetI2pDataHash_HASH_LENGTH;
  NetI2pDataDataHelper_toLongWithByteArray_withInt_withInt_withLong_(data, cur, 4, payload->size_);
  cur += 4;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, 0, data, cur, payload->size_);
  cur += payload->size_;
  IOSByteArray *paddingData = NetI2pCryptoElGamalAESEngine_getPaddingWithNetI2pI2PAppContext_withInt_withLong_(_context_, size, paddedSize);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(paddingData, 0, data, cur, ((IOSByteArray *) nil_chk(paddingData))->size_);
  [self encryptWithByteArray:data withInt:0 withByteArray:data withInt:0 withNetI2pDataSessionKey:sessionKey withByteArray:iv withInt:data->size_];
  return data;
}

- (IOSByteArray *)safeDecryptWithByteArray:(IOSByteArray *)payload
                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
                             withByteArray:(IOSByteArray *)iv {
  if ((iv == nil) || (payload == nil) || (sessionKey == nil) || (((IOSByteArray *) nil_chk(iv))->size_ != 16)) return nil;
  IOSByteArray *decr = [IOSByteArray arrayWithLength:((IOSByteArray *) nil_chk(payload))->size_];
  [self decryptWithByteArray:payload withInt:0 withByteArray:decr withInt:0 withNetI2pDataSessionKey:sessionKey withByteArray:iv withInt:payload->size_];
  IOSByteArray *h = NetI2pUtilSimpleByteCache_acquireWithInt_(NetI2pDataHash_HASH_LENGTH);
  [((NetI2pCryptoSHA256Generator *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) sha])) calculateHashWithByteArray:iv withInt:0 withInt:16 withByteArray:h withInt:0];
  jboolean eq = NetI2pDataDataHelper_eqWithByteArray_withInt_withByteArray_withInt_withInt_(decr, 0, h, 0, NetI2pDataHash_HASH_LENGTH);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(h);
  if (!eq) {
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:JreStrcat("$@$$C", @"Hash does not match [key=", sessionKey, @" / iv =", NetI2pDataDataHelper_toStringWithByteArray_withInt_(iv, ((IOSByteArray *) nil_chk(iv))->size_), ']') withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"Hash error")];
    return nil;
  }
  jint cur = NetI2pDataHash_HASH_LENGTH;
  jlong len = NetI2pDataDataHelper_fromLongWithByteArray_withInt_withInt_(decr, cur, 4);
  cur += 4;
  if (cur + len > decr->size_) {
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:@"Not enough to read"];
    return nil;
  }
  IOSByteArray *data = [IOSByteArray arrayWithLength:(jint) len];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(decr, cur, data, 0, (jint) len);
  return data;
}

- (void)decryptWithByteArray:(IOSByteArray *)payload
                     withInt:(jint)payloadIndex
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outIndex
    withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
               withByteArray:(IOSByteArray *)iv
                     withInt:(jint)length {
  [self decryptWithByteArray:payload withInt:payloadIndex withByteArray:outArg withInt:outIndex withNetI2pDataSessionKey:sessionKey withByteArray:iv withInt:0 withInt:length];
}

- (void)decryptWithByteArray:(IOSByteArray *)payload
                     withInt:(jint)payloadIndex
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outIndex
    withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
               withByteArray:(IOSByteArray *)iv
                     withInt:(jint)ivOffset
                     withInt:(jint)length {
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, payloadIndex, outArg, outIndex, length);
  [((NetI2pUtilLog *) nil_chk(_log_)) logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:@"AES is disabled"];
}

- (void)encryptBlockWithByteArray:(IOSByteArray *)payload
                          withInt:(jint)inIndex
         withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outIndex {
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, inIndex, outArg, outIndex, ((IOSByteArray *) nil_chk(outArg))->size_ - outIndex);
}

- (void)decryptBlockWithByteArray:(IOSByteArray *)payload
                          withInt:(jint)inIndex
         withNetI2pDataSessionKey:(NetI2pDataSessionKey *)sessionKey
                    withByteArray:(IOSByteArray *)rv
                          withInt:(jint)outIndex {
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, inIndex, rv, outIndex, ((IOSByteArray *) nil_chk(rv))->size_ - outIndex);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_context_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 4, 5, -1, -1, 6, -1 },
    { NULL, "[B", 0x1, 7, 8, -1, -1, 9, -1 },
    { NULL, "V", 0x1, 10, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 12, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(encryptWithByteArray:withInt:withByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:);
  methods[2].selector = @selector(encryptWithByteArray:withInt:withByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:withInt:);
  methods[3].selector = @selector(safeEncryptWithByteArray:withNetI2pDataSessionKey:withByteArray:withInt:);
  methods[4].selector = @selector(safeDecryptWithByteArray:withNetI2pDataSessionKey:withByteArray:);
  methods[5].selector = @selector(decryptWithByteArray:withInt:withByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:);
  methods[6].selector = @selector(decryptWithByteArray:withInt:withByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:withInt:);
  methods[7].selector = @selector(encryptBlockWithByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:);
  methods[8].selector = @selector(decryptBlockWithByteArray:withInt:withNetI2pDataSessionKey:withByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "encrypt", "[BI[BILNetI2pDataSessionKey;[BI", "[BI[BILNetI2pDataSessionKey;[BII", "safeEncrypt", "[BLNetI2pDataSessionKey;[BI", (void *)&NetI2pCryptoAESEngine__Annotations$0, "safeDecrypt", "[BLNetI2pDataSessionKey;[B", (void *)&NetI2pCryptoAESEngine__Annotations$1, "decrypt", "encryptBlock", "[BILNetI2pDataSessionKey;[BI", "decryptBlock" };
  static const J2ObjcClassInfo _NetI2pCryptoAESEngine = { "AESEngine", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x1, 9, 2, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoAESEngine;
}

@end

void NetI2pCryptoAESEngine_initWithNetI2pI2PAppContext_(NetI2pCryptoAESEngine *self, NetI2pI2PAppContext *ctx) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, ctx);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) logManager])) getLogWithIOSClass:[self java_getClass]]);
  if ([[self java_getClass] isEqual:NetI2pCryptoAESEngine_class_()]) [((NetI2pUtilLog *) nil_chk(self->_log_)) logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:@"AES is disabled"];
}

NetI2pCryptoAESEngine *new_NetI2pCryptoAESEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *ctx) {
  J2OBJC_NEW_IMPL(NetI2pCryptoAESEngine, initWithNetI2pI2PAppContext_, ctx)
}

NetI2pCryptoAESEngine *create_NetI2pCryptoAESEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *ctx) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoAESEngine, initWithNetI2pI2PAppContext_, ctx)
}

IOSObjectArray *NetI2pCryptoAESEngine__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *NetI2pCryptoAESEngine__Annotations$1() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoAESEngine)
