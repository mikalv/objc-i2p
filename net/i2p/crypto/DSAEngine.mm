//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/DSAEngine.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/lang/ArithmeticException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/math/BigInteger.h"
#include "java/security/GeneralSecurityException.h"
#include "java/security/Key.h"
#include "java/security/MessageDigest.h"
#include "java/security/PrivateKey.h"
#include "java/security/PublicKey.h"
#include "java/security/Signature.h"
#include "java/security/interfaces/DSAKey.h"
#include "java/security/interfaces/DSAPrivateKey.h"
#include "java/security/interfaces/DSAPublicKey.h"
#include "java/security/interfaces/ECKey.h"
#include "java/security/interfaces/RSAKey.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/CryptoConstants.h"
#include "net/i2p/crypto/DSAEngine.h"
#include "net/i2p/crypto/EntropyHarvester.h"
#include "net/i2p/crypto/SHA1.h"
#include "net/i2p/crypto/SHA1Hash.h"
#include "net/i2p/crypto/SigAlgo.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/crypto/SigUtil.h"
#include "net/i2p/crypto/eddsa/EdDSAEngine.h"
#include "net/i2p/crypto/eddsa/EdDSAKey.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/SimpleDataStructure.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/NativeBigInteger.h"
#include "net/i2p/util/RandomSource.h"

@interface NetI2pCryptoDSAEngine () {
 @public
  NetI2pUtilLog *_log_;
  NetI2pI2PAppContext *_context_;
}

- (jboolean)verifySigWithNetI2pDataSignature:(NetI2pDataSignature *)signature
           withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
              withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey;

- (NetI2pDataSignature *)signItWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                                 withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey;

- (jboolean)altVerifySigWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                  withByteArray:(IOSByteArray *)data
                                        withInt:(jint)offset
                                        withInt:(jint)len
                 withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey;

- (jboolean)altVerifySigRawWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey;

- (jboolean)altVerifySigRawWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                         withJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)pubKey;

- (jboolean)altVerifySigSHA1WithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                      withByteArray:(IOSByteArray *)data
                                            withInt:(jint)offset
                                            withInt:(jint)len
                     withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey;

- (NetI2pDataSignature *)altSignWithByteArray:(IOSByteArray *)data
                                      withInt:(jint)offset
                                      withInt:(jint)len
              withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey;

- (NetI2pDataSignature *)altSignRawWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                                     withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey;

- (NetI2pDataSignature *)altSignRawWithNSString:(NSString *)algo
              withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                     withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)privKey
                        withNetI2pCryptoSigType:(NetI2pCryptoSigType *)type;

- (NetI2pDataSignature *)altSignSHA1WithByteArray:(IOSByteArray *)data
                                          withInt:(jint)offset
                                          withInt:(jint)len
                  withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey;

+ (NSString *)getRawAlgoWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type;

+ (NSString *)getRawAlgoWithJavaSecurityKey:(id<JavaSecurityKey>)key;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoDSAEngine, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pCryptoDSAEngine, _context_, NetI2pI2PAppContext *)

inline jboolean NetI2pCryptoDSAEngine_get__useJavaLibs(void);
#define NetI2pCryptoDSAEngine__useJavaLibs false
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoDSAEngine, _useJavaLibs, jboolean)

__attribute__((unused)) static jboolean NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPublicKey *verifyingKey);

__attribute__((unused)) static NetI2pDataSignature *NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPrivateKey *signingKey);

__attribute__((unused)) static jboolean NetI2pCryptoDSAEngine_altVerifySigWithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPublicKey *verifyingKey);

__attribute__((unused)) static jboolean NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPublicKey *verifyingKey);

__attribute__((unused)) static jboolean NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withJavaSecurityPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, id<JavaSecurityPublicKey> pubKey);

__attribute__((unused)) static jboolean NetI2pCryptoDSAEngine_altVerifySigSHA1WithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPublicKey *verifyingKey);

__attribute__((unused)) static NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignWithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPrivateKey *privateKey);

__attribute__((unused)) static NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignRawWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPrivateKey *privateKey);

__attribute__((unused)) static NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignRawWithNSString_withNetI2pDataSimpleDataStructure_withJavaSecurityPrivateKey_withNetI2pCryptoSigType_(NetI2pCryptoDSAEngine *self, NSString *algo, NetI2pDataSimpleDataStructure *hash_, id<JavaSecurityPrivateKey> privKey, NetI2pCryptoSigType *type);

__attribute__((unused)) static NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignSHA1WithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPrivateKey *privateKey);

__attribute__((unused)) static NSString *NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(NetI2pCryptoSigType *type);

__attribute__((unused)) static NSString *NetI2pCryptoDSAEngine_getRawAlgoWithJavaSecurityKey_(id<JavaSecurityKey> key);

@implementation NetI2pCryptoDSAEngine

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context {
  NetI2pCryptoDSAEngine_initWithNetI2pI2PAppContext_(self, context);
  return self;
}

+ (NetI2pCryptoDSAEngine *)getInstance {
  return NetI2pCryptoDSAEngine_getInstance();
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                     withByteArray:(IOSByteArray *)signedData
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return [self verifySignatureWithNetI2pDataSignature:signature withByteArray:signedData withInt:0 withInt:((IOSByteArray *) nil_chk(signedData))->size_ withNetI2pDataSigningPublicKey:verifyingKey];
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                     withByteArray:(IOSByteArray *)signedData
                                           withInt:(jint)offset
                                           withInt:(jint)size
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  jboolean rv;
  NetI2pCryptoSigType *type = [((NetI2pDataSignature *) nil_chk(signature)) getType];
  if (type != [((NetI2pDataSigningPublicKey *) nil_chk(verifyingKey)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch sig=", [signature getType], @" key=", [verifyingKey getType]));
  if (type != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) {
    @try {
      rv = NetI2pCryptoDSAEngine_altVerifySigWithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(self, signature, signedData, offset, size, verifyingKey);
      if ((!rv) && [((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [((NetI2pUtilLog *) nil_chk(_log_)) warnWithNSString:JreStrcat("@$", type, @" Sig Verify Fail")];
      return rv;
    }
    @catch (JavaSecurityGeneralSecurityException *gse) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("@$", type, @" Sig Verify Fail") withJavaLangThrowable:gse];
      return false;
    }
  }
  rv = [self verifySignatureWithNetI2pDataSignature:signature withNetI2pCryptoSHA1Hash:NetI2pCryptoDSAEngine_calculateHashWithByteArray_withInt_withInt_(signedData, offset, size) withNetI2pDataSigningPublicKey:verifyingKey];
  if ((!rv) && [((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [((NetI2pUtilLog *) nil_chk(_log_)) warnWithNSString:@"TheCrypto DSA Sig Verify Fail"];
  return rv;
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                             withJavaIoInputStream:(JavaIoInputStream *)inArg
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return [self verifySignatureWithNetI2pDataSignature:signature withNetI2pCryptoSHA1Hash:[self calculateHashWithJavaIoInputStream:inArg] withNetI2pDataSigningPublicKey:verifyingKey];
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                          withNetI2pCryptoSHA1Hash:(NetI2pCryptoSHA1Hash *)hash_
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                withNetI2pDataHash:(NetI2pDataHash *)hash_
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  NetI2pCryptoSigType *type = [((NetI2pDataSignature *) nil_chk(signature)) getType];
  if (type != [((NetI2pDataSigningPublicKey *) nil_chk(verifyingKey)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch sig=", type, @" key=", [verifyingKey getType]));
  jint hashlen = [((NetI2pCryptoSigType *) nil_chk(type)) getHashLen];
  if ([((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) length] != hashlen) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch hash=", [hash_ java_getClass], @" sig=", type));
  if (type == JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) return NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
  @try {
    return NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("@$", type, @" Sig Verify Fail") withJavaLangThrowable:gse];
    return false;
  }
}

- (jboolean)verifySignatureWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                         withJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)pubKey {
  @try {
    return NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withJavaSecurityPublicKey_(self, signature, hash_, pubKey);
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("@$", [((NetI2pDataSignature *) nil_chk(signature)) getType], @" Sig Verify Fail") withJavaLangThrowable:gse];
    return false;
  }
}

- (jboolean)verifySigWithNetI2pDataSignature:(NetI2pDataSignature *)signature
           withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
              withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
}

- (NetI2pDataSignature *)signWithByteArray:(IOSByteArray *)data
           withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  return [self signWithByteArray:data withInt:0 withInt:((IOSByteArray *) nil_chk(data))->size_ withNetI2pDataSigningPrivateKey:signingKey];
}

- (NetI2pDataSignature *)signWithByteArray:(IOSByteArray *)data
                                   withInt:(jint)offset
                                   withInt:(jint)length
           withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  if ((signingKey == nil) || (data == nil) || (((IOSByteArray *) nil_chk(data))->size_ <= 0)) return nil;
  NetI2pCryptoSigType *type = [((NetI2pDataSigningPrivateKey *) nil_chk(signingKey)) getType];
  if (type != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) {
    @try {
      return NetI2pCryptoDSAEngine_altSignWithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(self, data, offset, length, signingKey);
    }
    @catch (JavaSecurityGeneralSecurityException *gse) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("@$", type, @" Sign Fail") withJavaLangThrowable:gse];
      return nil;
    }
  }
  NetI2pCryptoSHA1Hash *h = NetI2pCryptoDSAEngine_calculateHashWithByteArray_withInt_withInt_(data, offset, length);
  return [self signWithNetI2pCryptoSHA1Hash:h withNetI2pDataSigningPrivateKey:signingKey];
}

- (NetI2pDataSignature *)signWithJavaIoInputStream:(JavaIoInputStream *)inArg
                   withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  if ((signingKey == nil) || (inArg == nil)) return nil;
  NetI2pCryptoSHA1Hash *h = [self calculateHashWithJavaIoInputStream:inArg];
  return [self signWithNetI2pCryptoSHA1Hash:h withNetI2pDataSigningPrivateKey:signingKey];
}

- (NetI2pDataSignature *)signWithNetI2pCryptoSHA1Hash:(NetI2pCryptoSHA1Hash *)hash_
                      withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  return NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, signingKey);
}

- (NetI2pDataSignature *)signWithNetI2pDataHash:(NetI2pDataHash *)hash_
                withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  return NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, signingKey);
}

- (NetI2pDataSignature *)signWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                               withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  NetI2pCryptoSigType *type = [((NetI2pDataSigningPrivateKey *) nil_chk(signingKey)) getType];
  jint hashlen = [((NetI2pCryptoSigType *) nil_chk(type)) getHashLen];
  if ([((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) length] != hashlen) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch hash=", [hash_ java_getClass], @" key=", type));
  if (type == JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) return NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, signingKey);
  @try {
    return NetI2pCryptoDSAEngine_altSignRawWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, signingKey);
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("@$", type, @" Sign Fail") withJavaLangThrowable:gse];
    return nil;
  }
}

- (NetI2pDataSignature *)signWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                                    withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)privKey
                                       withNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  NSString *algo = NetI2pCryptoDSAEngine_getRawAlgoWithJavaSecurityKey_(privKey);
  NSString *talgo = NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(type);
  if (![((NSString *) nil_chk(algo)) isEqual:talgo]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$$", @"type mismatch type=", type, @" key=", [[((id<JavaSecurityPrivateKey>) nil_chk(privKey)) java_getClass] getSimpleName]));
  @try {
    return NetI2pCryptoDSAEngine_altSignRawWithNSString_withNetI2pDataSimpleDataStructure_withJavaSecurityPrivateKey_withNetI2pCryptoSigType_(self, algo, hash_, privKey, type);
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("@$", type, @" Sign Fail") withJavaLangThrowable:gse];
    return nil;
  }
}

- (NetI2pDataSignature *)signItWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                                 withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingKey {
  return NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, signingKey);
}

- (NetI2pCryptoSHA1Hash *)calculateHashWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  JavaSecurityMessageDigest *digest = NetI2pCryptoSHA1_getInstance();
  IOSByteArray *buf = [IOSByteArray arrayWithLength:64];
  jint read = 0;
  @try {
    while ((read = [((JavaIoInputStream *) nil_chk(inArg)) readWithByteArray:buf]) != -1) {
      [((JavaSecurityMessageDigest *) nil_chk(digest)) updateWithByteArray:buf withInt:0 withInt:read];
    }
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to hash the stream" withJavaLangThrowable:ioe];
    return nil;
  }
  return create_NetI2pCryptoSHA1Hash_initWithByteArray_([((JavaSecurityMessageDigest *) nil_chk(digest)) digest]);
}

+ (NetI2pCryptoSHA1Hash *)calculateHashWithByteArray:(IOSByteArray *)source
                                             withInt:(jint)offset
                                             withInt:(jint)len {
  return NetI2pCryptoDSAEngine_calculateHashWithByteArray_withInt_withInt_(source, offset, len);
}

- (jboolean)altVerifySigWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                  withByteArray:(IOSByteArray *)data
                                        withInt:(jint)offset
                                        withInt:(jint)len
                 withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_altVerifySigWithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(self, signature, data, offset, len, verifyingKey);
}

- (jboolean)altVerifySigRawWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(self, signature, hash_, verifyingKey);
}

- (jboolean)altVerifySigRawWithNetI2pDataSignature:(NetI2pDataSignature *)signature
                 withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                         withJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)pubKey {
  return NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withJavaSecurityPublicKey_(self, signature, hash_, pubKey);
}

- (jboolean)altVerifySigSHA1WithNetI2pDataSignature:(NetI2pDataSignature *)signature
                                      withByteArray:(IOSByteArray *)data
                                            withInt:(jint)offset
                                            withInt:(jint)len
                     withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)verifyingKey {
  return NetI2pCryptoDSAEngine_altVerifySigSHA1WithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(self, signature, data, offset, len, verifyingKey);
}

- (NetI2pDataSignature *)altSignWithByteArray:(IOSByteArray *)data
                                      withInt:(jint)offset
                                      withInt:(jint)len
              withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey {
  return NetI2pCryptoDSAEngine_altSignWithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(self, data, offset, len, privateKey);
}

- (NetI2pDataSignature *)altSignRawWithNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                                     withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey {
  return NetI2pCryptoDSAEngine_altSignRawWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(self, hash_, privateKey);
}

- (NetI2pDataSignature *)altSignRawWithNSString:(NSString *)algo
              withNetI2pDataSimpleDataStructure:(NetI2pDataSimpleDataStructure *)hash_
                     withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)privKey
                        withNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  return NetI2pCryptoDSAEngine_altSignRawWithNSString_withNetI2pDataSimpleDataStructure_withJavaSecurityPrivateKey_withNetI2pCryptoSigType_(self, algo, hash_, privKey, type);
}

- (NetI2pDataSignature *)altSignSHA1WithByteArray:(IOSByteArray *)data
                                          withInt:(jint)offset
                                          withInt:(jint)len
                  withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)privateKey {
  return NetI2pCryptoDSAEngine_altSignSHA1WithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(self, data, offset, len, privateKey);
}

+ (NSString *)getRawAlgoWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  return NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(type);
}

+ (NSString *)getRawAlgoWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  return NetI2pCryptoDSAEngine_getRawAlgoWithJavaSecurityKey_(key);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_context_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoDSAEngine;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 9, 7, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 12, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 13, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 14, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 15, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 16, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 10, 17, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x2, 18, 16, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSHA1Hash;", 0x1, 19, 20, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSHA1Hash;", 0x9, 19, 21, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 22, 3, 23, -1, -1, -1 },
    { NULL, "Z", 0x2, 24, 7, 23, -1, -1, -1 },
    { NULL, "Z", 0x2, 24, 8, 23, -1, -1, -1 },
    { NULL, "Z", 0x2, 25, 3, 23, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x2, 26, 12, 23, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x2, 27, 16, 23, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x2, 27, 28, 23, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x2, 29, 12, 23, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 30, 31, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 30, 32, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(getInstance);
  methods[2].selector = @selector(verifySignatureWithNetI2pDataSignature:withByteArray:withNetI2pDataSigningPublicKey:);
  methods[3].selector = @selector(verifySignatureWithNetI2pDataSignature:withByteArray:withInt:withInt:withNetI2pDataSigningPublicKey:);
  methods[4].selector = @selector(verifySignatureWithNetI2pDataSignature:withJavaIoInputStream:withNetI2pDataSigningPublicKey:);
  methods[5].selector = @selector(verifySignatureWithNetI2pDataSignature:withNetI2pCryptoSHA1Hash:withNetI2pDataSigningPublicKey:);
  methods[6].selector = @selector(verifySignatureWithNetI2pDataSignature:withNetI2pDataHash:withNetI2pDataSigningPublicKey:);
  methods[7].selector = @selector(verifySignatureWithNetI2pDataSignature:withNetI2pDataSimpleDataStructure:withNetI2pDataSigningPublicKey:);
  methods[8].selector = @selector(verifySignatureWithNetI2pDataSignature:withNetI2pDataSimpleDataStructure:withJavaSecurityPublicKey:);
  methods[9].selector = @selector(verifySigWithNetI2pDataSignature:withNetI2pDataSimpleDataStructure:withNetI2pDataSigningPublicKey:);
  methods[10].selector = @selector(signWithByteArray:withNetI2pDataSigningPrivateKey:);
  methods[11].selector = @selector(signWithByteArray:withInt:withInt:withNetI2pDataSigningPrivateKey:);
  methods[12].selector = @selector(signWithJavaIoInputStream:withNetI2pDataSigningPrivateKey:);
  methods[13].selector = @selector(signWithNetI2pCryptoSHA1Hash:withNetI2pDataSigningPrivateKey:);
  methods[14].selector = @selector(signWithNetI2pDataHash:withNetI2pDataSigningPrivateKey:);
  methods[15].selector = @selector(signWithNetI2pDataSimpleDataStructure:withNetI2pDataSigningPrivateKey:);
  methods[16].selector = @selector(signWithNetI2pDataSimpleDataStructure:withJavaSecurityPrivateKey:withNetI2pCryptoSigType:);
  methods[17].selector = @selector(signItWithNetI2pDataSimpleDataStructure:withNetI2pDataSigningPrivateKey:);
  methods[18].selector = @selector(calculateHashWithJavaIoInputStream:);
  methods[19].selector = @selector(calculateHashWithByteArray:withInt:withInt:);
  methods[20].selector = @selector(altVerifySigWithNetI2pDataSignature:withByteArray:withInt:withInt:withNetI2pDataSigningPublicKey:);
  methods[21].selector = @selector(altVerifySigRawWithNetI2pDataSignature:withNetI2pDataSimpleDataStructure:withNetI2pDataSigningPublicKey:);
  methods[22].selector = @selector(altVerifySigRawWithNetI2pDataSignature:withNetI2pDataSimpleDataStructure:withJavaSecurityPublicKey:);
  methods[23].selector = @selector(altVerifySigSHA1WithNetI2pDataSignature:withByteArray:withInt:withInt:withNetI2pDataSigningPublicKey:);
  methods[24].selector = @selector(altSignWithByteArray:withInt:withInt:withNetI2pDataSigningPrivateKey:);
  methods[25].selector = @selector(altSignRawWithNetI2pDataSimpleDataStructure:withNetI2pDataSigningPrivateKey:);
  methods[26].selector = @selector(altSignRawWithNSString:withNetI2pDataSimpleDataStructure:withJavaSecurityPrivateKey:withNetI2pCryptoSigType:);
  methods[27].selector = @selector(altSignSHA1WithByteArray:withInt:withInt:withNetI2pDataSigningPrivateKey:);
  methods[28].selector = @selector(getRawAlgoWithNetI2pCryptoSigType:);
  methods[29].selector = @selector(getRawAlgoWithJavaSecurityKey:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_useJavaLibs", "Z", .constantValue.asBOOL = NetI2pCryptoDSAEngine__useJavaLibs, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "verifySignature", "LNetI2pDataSignature;[BLNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;[BIILNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;LJavaIoInputStream;LNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;LNetI2pCryptoSHA1Hash;LNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;LNetI2pDataHash;LNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;LNetI2pDataSimpleDataStructure;LNetI2pDataSigningPublicKey;", "LNetI2pDataSignature;LNetI2pDataSimpleDataStructure;LJavaSecurityPublicKey;", "verifySig", "sign", "[BLNetI2pDataSigningPrivateKey;", "[BIILNetI2pDataSigningPrivateKey;", "LJavaIoInputStream;LNetI2pDataSigningPrivateKey;", "LNetI2pCryptoSHA1Hash;LNetI2pDataSigningPrivateKey;", "LNetI2pDataHash;LNetI2pDataSigningPrivateKey;", "LNetI2pDataSimpleDataStructure;LNetI2pDataSigningPrivateKey;", "LNetI2pDataSimpleDataStructure;LJavaSecurityPrivateKey;LNetI2pCryptoSigType;", "signIt", "calculateHash", "LJavaIoInputStream;", "[BII", "altVerifySig", "LJavaSecurityGeneralSecurityException;", "altVerifySigRaw", "altVerifySigSHA1", "altSign", "altSignRaw", "LNSString;LNetI2pDataSimpleDataStructure;LJavaSecurityPrivateKey;LNetI2pCryptoSigType;", "altSignSHA1", "getRawAlgo", "LNetI2pCryptoSigType;", "LJavaSecurityKey;" };
  static const J2ObjcClassInfo _NetI2pCryptoDSAEngine = { "DSAEngine", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x11, 30, 3, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoDSAEngine;
}

@end

void NetI2pCryptoDSAEngine_initWithNetI2pI2PAppContext_(NetI2pCryptoDSAEngine *self, NetI2pI2PAppContext *context) {
  NSObject_init(self);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) logManager])) getLogWithIOSClass:NetI2pCryptoDSAEngine_class_()]);
  JreStrongAssign(&self->_context_, context);
}

NetI2pCryptoDSAEngine *new_NetI2pCryptoDSAEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_NEW_IMPL(NetI2pCryptoDSAEngine, initWithNetI2pI2PAppContext_, context)
}

NetI2pCryptoDSAEngine *create_NetI2pCryptoDSAEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoDSAEngine, initWithNetI2pI2PAppContext_, context)
}

NetI2pCryptoDSAEngine *NetI2pCryptoDSAEngine_getInstance() {
  NetI2pCryptoDSAEngine_initialize();
  return [((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) dsa];
}

jboolean NetI2pCryptoDSAEngine_verifySigWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPublicKey *verifyingKey) {
  if ([((NetI2pDataSignature *) nil_chk(signature)) getType] != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Bad sig type ", [signature getType]));
  if ([((NetI2pDataSigningPublicKey *) nil_chk(verifyingKey)) getType] != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Bad key type ", [verifyingKey getType]));
  jlong start = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) clock])) now];
  @try {
    IOSByteArray *sigbytes = [signature getData];
    IOSByteArray *rbytes = [IOSByteArray arrayWithLength:20];
    IOSByteArray *sbytes = [IOSByteArray arrayWithLength:20];
    for (jint x = 0; x < 40; x++) {
      if (x < 20) {
        *IOSByteArray_GetRef(rbytes, x) = IOSByteArray_Get(nil_chk(sigbytes), x);
      }
      else {
        *IOSByteArray_GetRef(sbytes, x - 20) = IOSByteArray_Get(nil_chk(sigbytes), x);
      }
    }
    JavaMathBigInteger *s = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, sbytes);
    JavaMathBigInteger *r = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, rbytes);
    JavaMathBigInteger *y = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, [verifyingKey getData]);
    JavaMathBigInteger *w;
    @try {
      w = [s modInverseWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
    }
    @catch (JavaLangArithmeticException *ae) {
      [((NetI2pUtilLog *) nil_chk(self->_log_)) warnWithNSString:@"modInverse() error" withJavaLangThrowable:ae];
      return false;
    }
    IOSByteArray *data = [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) getData];
    NetI2pUtilNativeBigInteger *bi = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, data);
    JavaMathBigInteger *u1 = [((JavaMathBigInteger *) nil_chk([bi multiplyWithJavaMathBigInteger:w])) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
    JavaMathBigInteger *u2 = [((JavaMathBigInteger *) nil_chk([r multiplyWithJavaMathBigInteger:w])) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
    JavaMathBigInteger *modval = [((NetI2pUtilNativeBigInteger *) nil_chk(JreLoadStatic(NetI2pCryptoCryptoConstants, dsag))) modPowWithJavaMathBigInteger:u1 withJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsap)];
    JavaMathBigInteger *modmulval = [((JavaMathBigInteger *) nil_chk(modval)) multiplyWithJavaMathBigInteger:[y modPowWithJavaMathBigInteger:u2 withJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsap)]];
    JavaMathBigInteger *v = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk((modmulval))) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsap)])) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
    jboolean ok = [((JavaMathBigInteger *) nil_chk(v)) compareToWithId:r] == 0;
    jlong diff = [((NetI2pUtilClock *) nil_chk([self->_context_ clock])) now] - start;
    if (diff > 1000) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$J$", @"Took too long to verify the signature (", diff, @"ms)")];
    }
    return ok;
  }
  @catch (JavaLangRuntimeException *e) {
    [((NetI2pUtilLog *) nil_chk(self->_log_)) logWithInt:NetI2pUtilLog_CRIT withNSString:@"Error verifying the signature" withJavaLangThrowable:e];
    return false;
  }
}

NetI2pDataSignature *NetI2pCryptoDSAEngine_signItWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPrivateKey *signingKey) {
  if ((signingKey == nil) || (hash_ == nil)) return nil;
  if ([((NetI2pDataSigningPrivateKey *) nil_chk(signingKey)) getType] != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Bad key type ", [signingKey getType]));
  jlong start = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) clock])) now];
  JavaMathBigInteger *k;
  jboolean ok;
  do {
    k = create_NetI2pUtilNativeBigInteger_initWithInt_withJavaUtilRandom_(160, [self->_context_ random]);
    ok = ([k compareToWithId:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)] != 1);
    ok = (ok && ![k isEqual:JreLoadStatic(JavaMathBigInteger, ZERO)]);
  }
  while (!ok);
  JavaMathBigInteger *r = [((JavaMathBigInteger *) nil_chk([((NetI2pUtilNativeBigInteger *) nil_chk(JreLoadStatic(NetI2pCryptoCryptoConstants, dsag))) modPowCTWithJavaMathBigInteger:k withJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsap)])) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
  JavaMathBigInteger *kinv = [k modInverseWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
  JavaMathBigInteger *M = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) getData]);
  JavaMathBigInteger *x = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, [signingKey getData]);
  JavaMathBigInteger *s = [((JavaMathBigInteger *) nil_chk(([((JavaMathBigInteger *) nil_chk(kinv)) multiplyWithJavaMathBigInteger:[M addWithJavaMathBigInteger:[x multiplyWithJavaMathBigInteger:r]]]))) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, dsaq)];
  IOSByteArray *rbytes = [((JavaMathBigInteger *) nil_chk(r)) toByteArray];
  IOSByteArray *sbytes = [((JavaMathBigInteger *) nil_chk(s)) toByteArray];
  IOSByteArray *out = [IOSByteArray arrayWithLength:40];
  [((id<NetI2pCryptoEntropyHarvester>) nil_chk([((NetI2pUtilRandomSource *) nil_chk([self->_context_ random])) harvester])) feedEntropyWithNSString:@"DSA.sign" withByteArray:rbytes withInt:0 withInt:((IOSByteArray *) nil_chk(rbytes))->size_];
  if (rbytes->size_ == 20) {
    for (jint i = 0; i < 20; i++) {
      *IOSByteArray_GetRef(out, i) = IOSByteArray_Get(rbytes, i);
    }
  }
  else if (rbytes->size_ == 21) {
    for (jint i = 0; i < 20; i++) {
      *IOSByteArray_GetRef(out, i) = IOSByteArray_Get(rbytes, i + 1);
    }
  }
  else if (rbytes->size_ > 21) {
    [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:JreStrcat("$I", @"Bad R length ", rbytes->size_)];
    return nil;
  }
  else {
    for (jint i = 0; i < rbytes->size_; i++) *IOSByteArray_GetRef(out, i + 20 - rbytes->size_) = IOSByteArray_Get(rbytes, i);
  }
  if (((IOSByteArray *) nil_chk(sbytes))->size_ == 20) {
    for (jint i = 0; i < 20; i++) {
      *IOSByteArray_GetRef(out, i + 20) = IOSByteArray_Get(sbytes, i);
    }
  }
  else if (sbytes->size_ == 21) {
    for (jint i = 0; i < 20; i++) {
      *IOSByteArray_GetRef(out, i + 20) = IOSByteArray_Get(sbytes, i + 1);
    }
  }
  else if (sbytes->size_ > 21) {
    [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:JreStrcat("$I", @"Bad S length ", sbytes->size_)];
    return nil;
  }
  else {
    for (jint i = 0; i < sbytes->size_; i++) *IOSByteArray_GetRef(out, i + 20 + 20 - sbytes->size_) = IOSByteArray_Get(sbytes, i);
  }
  jlong diff = [((NetI2pUtilClock *) nil_chk([self->_context_ clock])) now] - start;
  if (diff > 1000) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$J$", @"Took too long to sign (", diff, @"ms)")];
  }
  return create_NetI2pDataSignature_initWithByteArray_(out);
}

NetI2pCryptoSHA1Hash *NetI2pCryptoDSAEngine_calculateHashWithByteArray_withInt_withInt_(IOSByteArray *source, jint offset, jint len) {
  NetI2pCryptoDSAEngine_initialize();
  JavaSecurityMessageDigest *h = NetI2pCryptoSHA1_getInstance();
  [((JavaSecurityMessageDigest *) nil_chk(h)) updateWithByteArray:source withInt:offset withInt:len];
  IOSByteArray *digested = [h digest];
  return create_NetI2pCryptoSHA1Hash_initWithByteArray_(digested);
}

jboolean NetI2pCryptoDSAEngine_altVerifySigWithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPublicKey *verifyingKey) {
  NetI2pCryptoSigType *type = [((NetI2pDataSignature *) nil_chk(signature)) getType];
  if (type != [((NetI2pDataSigningPublicKey *) nil_chk(verifyingKey)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch sig=", type, @" key=", [verifyingKey getType]));
  if (type == JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) return NetI2pCryptoDSAEngine_altVerifySigSHA1WithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(self, signature, data, offset, len, verifyingKey);
  id<JavaSecurityPublicKey> pubKey = NetI2pCryptoSigUtil_toJavaKeyWithNetI2pDataSigningPublicKey_(verifyingKey);
  IOSByteArray *sigbytes = NetI2pCryptoSigUtil_toJavaSigWithNetI2pDataSignature_(signature);
  jboolean rv;
  if ([((NetI2pCryptoSigType *) nil_chk(type)) getBaseAlgorithm] == JreLoadEnum(NetI2pCryptoSigAlgo, EdDSA)) {
    NetI2pCryptoEddsaEdDSAEngine *jsig = create_NetI2pCryptoEddsaEdDSAEngine_initWithJavaSecurityMessageDigest_([type getDigestInstance]);
    [jsig initVerifyWithJavaSecurityPublicKey:pubKey];
    rv = [jsig verifyOneShotWithByteArray:data withInt:offset withInt:len withByteArray:sigbytes];
  }
  else {
    JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_([type getAlgorithmName]);
    [((JavaSecuritySignature *) nil_chk(jsig)) initVerifyWithJavaSecurityPublicKey:pubKey];
    [jsig updateWithByteArray:data withInt:offset withInt:len];
    rv = [jsig verifyWithByteArray:sigbytes];
  }
  return rv;
}

jboolean NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPublicKey *verifyingKey) {
  NetI2pCryptoSigType *type = [((NetI2pDataSignature *) nil_chk(signature)) getType];
  if (type != [((NetI2pDataSigningPublicKey *) nil_chk(verifyingKey)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch sig=", type, @" key=", [verifyingKey getType]));
  id<JavaSecurityPublicKey> pubKey = NetI2pCryptoSigUtil_toJavaKeyWithNetI2pDataSigningPublicKey_(verifyingKey);
  return [self verifySignatureWithNetI2pDataSignature:signature withNetI2pDataSimpleDataStructure:hash_ withJavaSecurityPublicKey:pubKey];
}

jboolean NetI2pCryptoDSAEngine_altVerifySigRawWithNetI2pDataSignature_withNetI2pDataSimpleDataStructure_withJavaSecurityPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, NetI2pDataSimpleDataStructure *hash_, id<JavaSecurityPublicKey> pubKey) {
  NetI2pCryptoSigType *type = [((NetI2pDataSignature *) nil_chk(signature)) getType];
  jint hashlen = [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) length];
  if ([((NetI2pCryptoSigType *) nil_chk(type)) getHashLen] != hashlen) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch hash=", [hash_ java_getClass], @" key=", type));
  IOSByteArray *sigbytes = NetI2pCryptoSigUtil_toJavaSigWithNetI2pDataSignature_(signature);
  jboolean rv;
  if ([type getBaseAlgorithm] == JreLoadEnum(NetI2pCryptoSigAlgo, EdDSA)) {
    NetI2pCryptoEddsaEdDSAEngine *jsig = create_NetI2pCryptoEddsaEdDSAEngine_init();
    [jsig initVerifyWithJavaSecurityPublicKey:pubKey];
    rv = [jsig verifyOneShotWithByteArray:[hash_ getData] withByteArray:sigbytes];
  }
  else {
    NSString *algo = NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(type);
    JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_(algo);
    [((JavaSecuritySignature *) nil_chk(jsig)) initVerifyWithJavaSecurityPublicKey:pubKey];
    [jsig updateWithByteArray:[hash_ getData]];
    rv = [jsig verifyWithByteArray:sigbytes];
  }
  return rv;
}

jboolean NetI2pCryptoDSAEngine_altVerifySigSHA1WithNetI2pDataSignature_withByteArray_withInt_withInt_withNetI2pDataSigningPublicKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSignature *signature, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPublicKey *verifyingKey) {
  JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_(@"SHA1withDSA");
  id<JavaSecurityPublicKey> pubKey = NetI2pCryptoSigUtil_toJavaDSAKeyWithNetI2pDataSigningPublicKey_(verifyingKey);
  [((JavaSecuritySignature *) nil_chk(jsig)) initVerifyWithJavaSecurityPublicKey:pubKey];
  [jsig updateWithByteArray:data withInt:offset withInt:len];
  jboolean rv = [jsig verifyWithByteArray:NetI2pCryptoSigUtil_toJavaSigWithNetI2pDataSignature_(signature)];
  return rv;
}

NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignWithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPrivateKey *privateKey) {
  NetI2pCryptoSigType *type = [((NetI2pDataSigningPrivateKey *) nil_chk(privateKey)) getType];
  if (type == JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) return NetI2pCryptoDSAEngine_altSignSHA1WithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(self, data, offset, len, privateKey);
  id<JavaSecurityPrivateKey> privKey = NetI2pCryptoSigUtil_toJavaKeyWithNetI2pDataSigningPrivateKey_(privateKey);
  IOSByteArray *sigbytes;
  if ([((NetI2pCryptoSigType *) nil_chk(type)) getBaseAlgorithm] == JreLoadEnum(NetI2pCryptoSigAlgo, EdDSA)) {
    NetI2pCryptoEddsaEdDSAEngine *jsig = create_NetI2pCryptoEddsaEdDSAEngine_initWithJavaSecurityMessageDigest_([type getDigestInstance]);
    [jsig initSignWithJavaSecurityPrivateKey:privKey];
    sigbytes = [jsig signOneShotWithByteArray:data withInt:offset withInt:len];
  }
  else {
    JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_([type getAlgorithmName]);
    [((JavaSecuritySignature *) nil_chk(jsig)) initSignWithJavaSecurityPrivateKey:privKey withJavaSecuritySecureRandom:[((NetI2pI2PAppContext *) nil_chk(self->_context_)) random]];
    [jsig updateWithByteArray:data withInt:offset withInt:len];
    sigbytes = [jsig sign];
  }
  return NetI2pCryptoSigUtil_fromJavaSigWithByteArray_withNetI2pCryptoSigType_(sigbytes, type);
}

NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignRawWithNetI2pDataSimpleDataStructure_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, NetI2pDataSimpleDataStructure *hash_, NetI2pDataSigningPrivateKey *privateKey) {
  NetI2pCryptoSigType *type = [((NetI2pDataSigningPrivateKey *) nil_chk(privateKey)) getType];
  NSString *algo = NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(type);
  id<JavaSecurityPrivateKey> privKey = NetI2pCryptoSigUtil_toJavaKeyWithNetI2pDataSigningPrivateKey_(privateKey);
  return NetI2pCryptoDSAEngine_altSignRawWithNSString_withNetI2pDataSimpleDataStructure_withJavaSecurityPrivateKey_withNetI2pCryptoSigType_(self, algo, hash_, privKey, type);
}

NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignRawWithNSString_withNetI2pDataSimpleDataStructure_withJavaSecurityPrivateKey_withNetI2pCryptoSigType_(NetI2pCryptoDSAEngine *self, NSString *algo, NetI2pDataSimpleDataStructure *hash_, id<JavaSecurityPrivateKey> privKey, NetI2pCryptoSigType *type) {
  jint hashlen = [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) length];
  if ([((NetI2pCryptoSigType *) nil_chk(type)) getHashLen] != hashlen) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"type mismatch hash=", [hash_ java_getClass], @" key=", type));
  IOSByteArray *sigbytes;
  if ([type getBaseAlgorithm] == JreLoadEnum(NetI2pCryptoSigAlgo, EdDSA)) {
    NetI2pCryptoEddsaEdDSAEngine *jsig = create_NetI2pCryptoEddsaEdDSAEngine_init();
    [jsig initSignWithJavaSecurityPrivateKey:privKey];
    sigbytes = [jsig signOneShotWithByteArray:[hash_ getData]];
  }
  else {
    JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_(algo);
    [((JavaSecuritySignature *) nil_chk(jsig)) initSignWithJavaSecurityPrivateKey:privKey withJavaSecuritySecureRandom:[((NetI2pI2PAppContext *) nil_chk(self->_context_)) random]];
    [jsig updateWithByteArray:[hash_ getData]];
    sigbytes = [jsig sign];
  }
  return NetI2pCryptoSigUtil_fromJavaSigWithByteArray_withNetI2pCryptoSigType_(sigbytes, type);
}

NetI2pDataSignature *NetI2pCryptoDSAEngine_altSignSHA1WithByteArray_withInt_withInt_withNetI2pDataSigningPrivateKey_(NetI2pCryptoDSAEngine *self, IOSByteArray *data, jint offset, jint len, NetI2pDataSigningPrivateKey *privateKey) {
  JavaSecuritySignature *jsig = JavaSecuritySignature_getInstanceWithNSString_(@"SHA1withDSA");
  id<JavaSecurityPrivateKey> privKey = NetI2pCryptoSigUtil_toJavaDSAKeyWithNetI2pDataSigningPrivateKey_(privateKey);
  [((JavaSecuritySignature *) nil_chk(jsig)) initSignWithJavaSecurityPrivateKey:privKey withJavaSecuritySecureRandom:[((NetI2pI2PAppContext *) nil_chk(self->_context_)) random]];
  [jsig updateWithByteArray:data withInt:offset withInt:len];
  return NetI2pCryptoSigUtil_fromJavaSigWithByteArray_withNetI2pCryptoSigType_([jsig sign], JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1));
}

NSString *NetI2pCryptoDSAEngine_getRawAlgoWithNetI2pCryptoSigType_(NetI2pCryptoSigType *type) {
  NetI2pCryptoDSAEngine_initialize();
  switch ([[((NetI2pCryptoSigType *) nil_chk(type)) getBaseAlgorithm] ordinal]) {
    case NetI2pCryptoSigAlgo_Enum_DSA:
    return @"NONEwithDSA";
    case NetI2pCryptoSigAlgo_Enum_EC:
    return @"NONEwithECDSA";
    case NetI2pCryptoSigAlgo_Enum_EdDSA:
    return @"NONEwithEdDSA";
    case NetI2pCryptoSigAlgo_Enum_RSA:
    return @"NONEwithRSA";
    default:
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(JreStrcat("$@", @"Raw signatures unsupported for ", type));
  }
}

NSString *NetI2pCryptoDSAEngine_getRawAlgoWithJavaSecurityKey_(id<JavaSecurityKey> key) {
  NetI2pCryptoDSAEngine_initialize();
  if ([JavaSecurityInterfacesDSAKey_class_() isInstance:key]) return @"NONEwithDSA";
  if ([JavaSecurityInterfacesECKey_class_() isInstance:key]) return @"NONEwithECDSA";
  if ([NetI2pCryptoEddsaEdDSAKey_class_() isInstance:key]) return @"NONEwithEdDSA";
  if ([JavaSecurityInterfacesRSAKey_class_() isInstance:key]) return @"NONEwithRSA";
  @throw create_JavaLangUnsupportedOperationException_initWithNSString_(JreStrcat("$$", @"Raw signatures unsupported for ", [[((id<JavaSecurityKey>) nil_chk(key)) java_getClass] getName]));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoDSAEngine)
