//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/SU3File.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "gnu/getopt/Getopt.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/BufferedOutputStream.h"
#include "java/io/EOFException.h"
#include "java/io/File.h"
#include "java/io/FileDescriptor.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/PrintStream.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/Throwable.h"
#include "java/security/DigestInputStream.h"
#include "java/security/DigestOutputStream.h"
#include "java/security/GeneralSecurityException.h"
#include "java/security/MessageDigest.h"
#include "java/security/PrivateKey.h"
#include "java/security/PublicKey.h"
#include "java/security/cert/X509CRL.h"
#include "java/security/cert/X509Certificate.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/EnumSet.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/Map.h"
#include "java/util/NoSuchElementException.h"
#include "java/util/Properties.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/CertUtil.h"
#include "net/i2p/crypto/DSAEngine.h"
#include "net/i2p/crypto/DirKeyRing.h"
#include "net/i2p/crypto/KeyRing.h"
#include "net/i2p/crypto/KeyStoreUtil.h"
#include "net/i2p/crypto/SU3File.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/crypto/SigUtil.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/SimpleDataStructure.h"
#include "net/i2p/util/SecureFileOutputStream.h"

@class NetI2pCryptoSU3File_ContentType;

@interface NetI2pCryptoSU3File () {
 @public
  NetI2pI2PAppContext *_context_;
  JavaIoFile *_file_;
  NSString *_version_;
  jint _versionLength_;
  NSString *_signer_;
  jint _signatureLength_;
  jint _signerLength_;
  jint _fileType_;
  NetI2pCryptoSU3File_ContentType *_contentType_;
  jlong _contentLength_;
  id<JavaSecurityPublicKey> _signerPubkey_;
  jboolean _headerVerified_;
  NetI2pCryptoSigType *_sigType_;
  jboolean _verifySignature_;
  JavaIoFile *_certFile_;
}

- (void)setPublicKeyCertificateWithJavaIoFile:(JavaIoFile *)certFile;

- (void)verifyHeaderWithJavaIoInputStream:(JavaIoInputStream *)inArg;

+ (void)skipWithJavaIoInputStream:(JavaIoInputStream *)inArg
                          withInt:(jint)cnt;

- (jint)getContentOffset;

+ (void)showUsageCLI;

+ (NSString *)dumpTypes;

+ (NetI2pCryptoSU3File_ContentType *)parseContentTypeWithNSString:(NSString *)ctype;

+ (jboolean)showVersionCLIWithNSString:(NSString *)signedFile;

+ (jboolean)bulkSignCLIWithNSString:(NSString *)stype
                       withNSString:(NSString *)ctype
                       withNSString:(NSString *)dir
                       withNSString:(NSString *)privateKeyFile
                       withNSString:(NSString *)version_
                       withNSString:(NSString *)signerName
                       withNSString:(NSString *)kspass;

+ (jboolean)signCLIWithNSString:(NSString *)stype
                   withNSString:(NSString *)ctype
                   withNSString:(NSString *)ftype
                   withNSString:(NSString *)inputFile
                   withNSString:(NSString *)signedFile
                   withNSString:(NSString *)privateKeyFile
                   withNSString:(NSString *)version_
                   withNSString:(NSString *)signerName
                   withNSString:(NSString *)keypw
                   withNSString:(NSString *)kspass;

+ (jboolean)signCLIWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type
       withNetI2pCryptoSU3File_ContentType:(NetI2pCryptoSU3File_ContentType *)ctype
                                   withInt:(jint)ftype
                              withNSString:(NSString *)inputFile
                              withNSString:(NSString *)signedFile
                              withNSString:(NSString *)privateKeyFile
                              withNSString:(NSString *)version_
                              withNSString:(NSString *)signerName
                              withNSString:(NSString *)keypw
                              withNSString:(NSString *)kspass;

+ (jboolean)verifySigCLIWithNSString:(NSString *)signedFile
                        withNSString:(NSString *)pkFile;

+ (jboolean)extractCLIWithNSString:(NSString *)signedFile
                      withNSString:(NSString *)outFile
                       withBoolean:(jboolean)verifySig
                      withNSString:(NSString *)pkFile;

+ (jboolean)genKeysCLIWithNSString:(NSString *)stype
                      withNSString:(NSString *)publicKeyFile
                      withNSString:(NSString *)privateKeyFile
                      withNSString:(NSString *)crlFile
                      withNSString:(NSString *)alias
                      withNSString:(NSString *)kspass;

+ (jboolean)genKeysCLIWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type
                                 withNSString:(NSString *)publicKeyFile
                                 withNSString:(NSString *)privateKeyFile
                                 withNSString:(NSString *)crlFile
                                 withNSString:(NSString *)alias
                                 withNSString:(NSString *)kspass;

+ (id<JavaSecurityPublicKey>)loadKeyWithJavaIoFile:(JavaIoFile *)kd;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _context_, NetI2pI2PAppContext *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _file_, JavaIoFile *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _version_, NSString *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _signer_, NSString *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _contentType_, NetI2pCryptoSU3File_ContentType *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _signerPubkey_, id<JavaSecurityPublicKey>)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _sigType_, NetI2pCryptoSigType *)
J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File, _certFile_, JavaIoFile *)

inline IOSByteArray *NetI2pCryptoSU3File_get_MAGIC_BYTES(void);
static IOSByteArray *NetI2pCryptoSU3File_MAGIC_BYTES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoSU3File, MAGIC_BYTES, IOSByteArray *)

inline jint NetI2pCryptoSU3File_get_FILE_VERSION(void);
#define NetI2pCryptoSU3File_FILE_VERSION 0
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoSU3File, FILE_VERSION, jint)

inline jint NetI2pCryptoSU3File_get_MIN_VERSION_BYTES(void);
#define NetI2pCryptoSU3File_MIN_VERSION_BYTES 16
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoSU3File, MIN_VERSION_BYTES, jint)

inline jint NetI2pCryptoSU3File_get_VERSION_OFFSET(void);
#define NetI2pCryptoSU3File_VERSION_OFFSET 40
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoSU3File, VERSION_OFFSET, jint)

inline id<JavaUtilMap> NetI2pCryptoSU3File_get_BY_CODE(void);
static id<JavaUtilMap> NetI2pCryptoSU3File_BY_CODE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoSU3File, BY_CODE, id<JavaUtilMap>)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_get_DEFAULT_CONTENT_TYPE(void);
static NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_DEFAULT_CONTENT_TYPE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoSU3File, DEFAULT_CONTENT_TYPE, NetI2pCryptoSU3File_ContentType *)

inline jint NetI2pCryptoSU3File_get_DEFAULT_SIG_CODE(void);
#define NetI2pCryptoSU3File_DEFAULT_SIG_CODE 6
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoSU3File, DEFAULT_SIG_CODE, jint)

__attribute__((unused)) static void NetI2pCryptoSU3File_setPublicKeyCertificateWithJavaIoFile_(NetI2pCryptoSU3File *self, JavaIoFile *certFile);

__attribute__((unused)) static void NetI2pCryptoSU3File_verifyHeaderWithJavaIoInputStream_(NetI2pCryptoSU3File *self, JavaIoInputStream *inArg);

__attribute__((unused)) static void NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint cnt);

__attribute__((unused)) static jint NetI2pCryptoSU3File_getContentOffset(NetI2pCryptoSU3File *self);

__attribute__((unused)) static void NetI2pCryptoSU3File_showUsageCLI(void);

__attribute__((unused)) static NSString *NetI2pCryptoSU3File_dumpTypes(void);

__attribute__((unused)) static NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_parseContentTypeWithNSString_(NSString *ctype);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_showVersionCLIWithNSString_(NSString *signedFile);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_bulkSignCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *ctype, NSString *dir, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *kspass);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_signCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *ctype, NSString *ftype, NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *keypw, NSString *kspass);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_signCLIWithNetI2pCryptoSigType_withNetI2pCryptoSU3File_ContentType_withInt_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NetI2pCryptoSigType *type, NetI2pCryptoSU3File_ContentType *ctype, jint ftype, NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *keypw, NSString *kspass);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_verifySigCLIWithNSString_withNSString_(NSString *signedFile, NSString *pkFile);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_extractCLIWithNSString_withNSString_withBoolean_withNSString_(NSString *signedFile, NSString *outFile, jboolean verifySig, NSString *pkFile);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_genKeysCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *publicKeyFile, NSString *privateKeyFile, NSString *crlFile, NSString *alias, NSString *kspass);

__attribute__((unused)) static jboolean NetI2pCryptoSU3File_genKeysCLIWithNetI2pCryptoSigType_withNSString_withNSString_withNSString_withNSString_withNSString_(NetI2pCryptoSigType *type, NSString *publicKeyFile, NSString *privateKeyFile, NSString *crlFile, NSString *alias, NSString *kspass);

__attribute__((unused)) static id<JavaSecurityPublicKey> NetI2pCryptoSU3File_loadKeyWithJavaIoFile_(JavaIoFile *kd);

typedef NS_ENUM(NSUInteger, NetI2pCryptoSU3File_ContentType_Enum) {
  NetI2pCryptoSU3File_ContentType_Enum_UNKNOWN = 0,
  NetI2pCryptoSU3File_ContentType_Enum_ROUTER = 1,
  NetI2pCryptoSU3File_ContentType_Enum_PLUGIN = 2,
  NetI2pCryptoSU3File_ContentType_Enum_RESEED = 3,
  NetI2pCryptoSU3File_ContentType_Enum_NEWS = 4,
  NetI2pCryptoSU3File_ContentType_Enum_BLOCKLIST = 5,
};

@interface NetI2pCryptoSU3File_ContentType : JavaLangEnum {
 @public
  jint code_;
  NSString *name_ContentType_;
}

@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *UNKNOWN NS_SWIFT_NAME(UNKNOWN);
@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *ROUTER NS_SWIFT_NAME(ROUTER);
@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *PLUGIN NS_SWIFT_NAME(PLUGIN);
@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *RESEED NS_SWIFT_NAME(RESEED);
@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *NEWS NS_SWIFT_NAME(NEWS);
@property (readonly, class, nonnull) NetI2pCryptoSU3File_ContentType *BLOCKLIST NS_SWIFT_NAME(BLOCKLIST);
- (jint)getCode;

- (NSString *)getName;

+ (NetI2pCryptoSU3File_ContentType *)getByCodeWithInt:(jint)code;

+ (IOSObjectArray *)values;

+ (NetI2pCryptoSU3File_ContentType *)valueOfWithNSString:(NSString *)name;

- (NetI2pCryptoSU3File_ContentType_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(NetI2pCryptoSU3File_ContentType)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_values_[];

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_UNKNOWN(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, UNKNOWN)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_ROUTER(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, ROUTER)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_PLUGIN(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, PLUGIN)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_RESEED(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, RESEED)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_NEWS(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, NEWS)

inline NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_get_BLOCKLIST(void);
J2OBJC_ENUM_CONSTANT(NetI2pCryptoSU3File_ContentType, BLOCKLIST)

J2OBJC_FIELD_SETTER(NetI2pCryptoSU3File_ContentType, name_ContentType_, NSString *)

__attribute__((unused)) static void NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(NetI2pCryptoSU3File_ContentType *self, jint code, NSString *name, NSString *__name, jint __ordinal);

__attribute__((unused)) static NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_getByCodeWithInt_(jint code);

__attribute__((unused)) static IOSObjectArray *NetI2pCryptoSU3File_ContentType_values(void);

__attribute__((unused)) static NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pCryptoSU3File_ContentType)

J2OBJC_INITIALIZED_DEFN(NetI2pCryptoSU3File)

NSString *NetI2pCryptoSU3File_MAGIC = @"I2Psu3";

@implementation NetI2pCryptoSU3File

+ (NSString *)MAGIC {
  return NetI2pCryptoSU3File_MAGIC;
}

+ (jint)TYPE_ZIP {
  return NetI2pCryptoSU3File_TYPE_ZIP;
}

+ (jint)TYPE_XML {
  return NetI2pCryptoSU3File_TYPE_XML;
}

+ (jint)TYPE_HTML {
  return NetI2pCryptoSU3File_TYPE_HTML;
}

+ (jint)TYPE_XML_GZ {
  return NetI2pCryptoSU3File_TYPE_XML_GZ;
}

+ (jint)TYPE_TXT_GZ {
  return NetI2pCryptoSU3File_TYPE_TXT_GZ;
}

+ (jint)CONTENT_UNKNOWN {
  return NetI2pCryptoSU3File_CONTENT_UNKNOWN;
}

+ (jint)CONTENT_ROUTER {
  return NetI2pCryptoSU3File_CONTENT_ROUTER;
}

+ (jint)CONTENT_PLUGIN {
  return NetI2pCryptoSU3File_CONTENT_PLUGIN;
}

+ (jint)CONTENT_RESEED {
  return NetI2pCryptoSU3File_CONTENT_RESEED;
}

+ (jint)CONTENT_NEWS {
  return NetI2pCryptoSU3File_CONTENT_NEWS;
}

+ (jint)CONTENT_BLOCKLIST {
  return NetI2pCryptoSU3File_CONTENT_BLOCKLIST;
}

- (instancetype)initWithNSString:(NSString *)file {
  NetI2pCryptoSU3File_initWithNSString_(self, file);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file {
  NetI2pCryptoSU3File_initWithJavaIoFile_(self, file);
  return self;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                             withJavaIoFile:(JavaIoFile *)file {
  NetI2pCryptoSU3File_initWithNetI2pI2PAppContext_withJavaIoFile_(self, context, file);
  return self;
}

- (void)setVerifySignatureWithBoolean:(jboolean)shouldVerify {
  _verifySignature_ = shouldVerify;
}

- (void)setPublicKeyCertificateWithJavaIoFile:(JavaIoFile *)certFile {
  NetI2pCryptoSU3File_setPublicKeyCertificateWithJavaIoFile_(self, certFile);
}

- (NSString *)getVersionString {
  [self verifyHeader];
  return _version_;
}

- (NSString *)getSignerString {
  [self verifyHeader];
  return _signer_;
}

- (NetI2pCryptoSigType *)getSigType {
  [self verifyHeader];
  return _sigType_;
}

- (jint)getContentType {
  [self verifyHeader];
  return _contentType_ != nil ? [_contentType_ getCode] : -1;
}

- (jint)getFileType {
  [self verifyHeader];
  return _fileType_;
}

- (void)verifyHeader {
  if (_headerVerified_) return;
  JavaIoInputStream *in = nil;
  @try {
    in = create_JavaIoFileInputStream_initWithJavaIoFile_(_file_);
    NetI2pCryptoSU3File_verifyHeaderWithJavaIoInputStream_(self, in);
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"foo");
    [ioe initCauseWithJavaLangThrowable:dfe];
    @throw ioe;
  }
  @finally {
    if (in != nil) @try {
      [in close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
}

- (void)verifyHeaderWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  NetI2pCryptoSU3File_verifyHeaderWithJavaIoInputStream_(self, inArg);
}

+ (void)skipWithJavaIoInputStream:(JavaIoInputStream *)inArg
                          withInt:(jint)cnt {
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, cnt);
}

- (jint)getContentOffset {
  return NetI2pCryptoSU3File_getContentOffset(self);
}

- (jboolean)verify {
  return [self verifyAndMigrateWithJavaIoFile:nil];
}

- (jboolean)verifyAndMigrateWithJavaIoFile:(JavaIoFile *)migrateTo {
  JavaIoInputStream *in = nil;
  JavaIoFileOutputStream *out = nil;
  jboolean rv = false;
  @try {
    in = create_JavaIoBufferedInputStream_initWithJavaIoInputStream_(create_JavaIoFileInputStream_initWithJavaIoFile_(_file_));
    [in markWithInt:10];
    IOSByteArray *magic = [IOSByteArray arrayWithLength:((IOSByteArray *) nil_chk(NetI2pCryptoSU3File_MAGIC_BYTES))->size_];
    NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(in, magic);
    if (!NetI2pDataDataHelper_eqWithByteArray_withByteArray_(magic, NetI2pCryptoSU3File_MAGIC_BYTES)) @throw create_JavaIoIOException_initWithNSString_(@"Not an su3 file");
    NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(in, 1);
    jint foo = [in read];
    if (foo != NetI2pCryptoSU3File_FILE_VERSION) @throw create_JavaIoIOException_initWithNSString_(@"bad file version");
    NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(in, 1);
    jint sigTypeCode = [in read];
    JreStrongAssign(&_sigType_, NetI2pCryptoSigType_getByCodeWithInt_(sigTypeCode));
    if (_sigType_ == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$I", @"unknown sig type: ", sigTypeCode));
    [in reset];
    JavaSecurityMessageDigest *md = [((NetI2pCryptoSigType *) nil_chk(_sigType_)) getDigestInstance];
    JavaSecurityDigestInputStream *din = create_JavaSecurityDigestInputStream_initWithJavaIoInputStream_withJavaSecurityMessageDigest_(in, md);
    in = din;
    if (!_headerVerified_) NetI2pCryptoSU3File_verifyHeaderWithJavaIoInputStream_(self, in);
    else NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(in, NetI2pCryptoSU3File_getContentOffset(self));
    if (_verifySignature_) {
      if (_signerPubkey_ == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$$$$", @"unknown signer: ", _signer_, @" for content type: ", [((NetI2pCryptoSU3File_ContentType *) nil_chk(_contentType_)) getName]));
    }
    if (migrateTo != nil) out = create_NetI2pUtilSecureFileOutputStream_initWithJavaIoFile_(migrateTo);
    IOSByteArray *buf = [IOSByteArray arrayWithLength:16 * 1024];
    jlong tot = 0;
    while (tot < _contentLength_) {
      jint read = [in readWithByteArray:buf withInt:0 withInt:(jint) JavaLangMath_minWithLong_withLong_(buf->size_, _contentLength_ - tot)];
      if (read < 0) @throw create_JavaIoEOFException_init();
      if (migrateTo != nil) [((JavaIoFileOutputStream *) nil_chk(out)) writeWithByteArray:buf withInt:0 withInt:read];
      tot += read;
    }
    if (_verifySignature_) {
      IOSByteArray *sha = [((JavaSecurityMessageDigest *) nil_chk(md)) digest];
      [din onWithBoolean:false];
      NetI2pDataSignature *signature = create_NetI2pDataSignature_initWithNetI2pCryptoSigType_(_sigType_);
      [signature readBytesWithJavaIoInputStream:in];
      jint avail = [in available];
      if (avail > 0) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("I$", avail, @" bytes data after sig"));
      NetI2pDataSimpleDataStructure *hash_ = [((NetI2pCryptoSigType *) nil_chk(_sigType_)) getHashInstance];
      [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) setDataWithByteArray:sha];
      rv = [((NetI2pCryptoDSAEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) dsa])) verifySignatureWithNetI2pDataSignature:signature withNetI2pDataSimpleDataStructure:hash_ withJavaSecurityPublicKey:_signerPubkey_];
    }
    else {
      rv = true;
    }
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"foo");
    [ioe initCauseWithJavaLangThrowable:dfe];
    @throw ioe;
  }
  @finally {
    if (in != nil) @try {
      [in close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (out != nil) {
      @try {
        [out flush];
        [((JavaIoFileDescriptor *) nil_chk([out getFD])) sync];
      }
      @catch (JavaIoIOException *ioe) {
      }
      @try {
        [out close];
      }
      @catch (JavaIoIOException *ioe) {
      }
    }
    if (migrateTo != nil && !rv) [migrateTo delete__];
  }
  return rv;
}

- (void)writeWithJavaIoFile:(JavaIoFile *)content
                    withInt:(jint)fileType
                    withInt:(jint)contentType
               withNSString:(NSString *)version_
               withNSString:(NSString *)signer
 withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)privkey
    withNetI2pCryptoSigType:(NetI2pCryptoSigType *)sigType {
  JavaIoInputStream *in = nil;
  JavaSecurityDigestOutputStream *out = nil;
  jboolean ok = false;
  @try {
    in = create_JavaIoBufferedInputStream_initWithJavaIoInputStream_(create_JavaIoFileInputStream_initWithJavaIoFile_(content));
    JavaSecurityMessageDigest *md = [((NetI2pCryptoSigType *) nil_chk(sigType)) getDigestInstance];
    out = create_JavaSecurityDigestOutputStream_initWithJavaIoOutputStream_withJavaSecurityMessageDigest_(create_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(create_JavaIoFileOutputStream_initWithJavaIoFile_(_file_)), md);
    [out writeWithByteArray:NetI2pCryptoSU3File_MAGIC_BYTES];
    [out writeWithInt:(jbyte) 0];
    [out writeWithInt:(jbyte) NetI2pCryptoSU3File_FILE_VERSION];
    NetI2pDataDataHelper_writeLongWithJavaIoOutputStream_withInt_withLong_(out, 2, [sigType getCode]);
    NetI2pDataDataHelper_writeLongWithJavaIoOutputStream_withInt_withLong_(out, 2, [sigType getSigLen]);
    [out writeWithInt:(jbyte) 0];
    IOSByteArray *verBytes = NetI2pDataDataHelper_getUTF8WithNSString_(version_);
    if (((IOSByteArray *) nil_chk(verBytes))->size_ == 0 || verBytes->size_ > 255) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"bad version length");
    jint verLen = JavaLangMath_maxWithInt_withInt_(verBytes->size_, NetI2pCryptoSU3File_MIN_VERSION_BYTES);
    [out writeWithInt:(jbyte) verLen];
    [out writeWithInt:(jbyte) 0];
    IOSByteArray *signerBytes = NetI2pDataDataHelper_getUTF8WithNSString_(signer);
    if (((IOSByteArray *) nil_chk(signerBytes))->size_ == 0 || signerBytes->size_ > 255) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"bad signer length");
    [out writeWithInt:(jbyte) signerBytes->size_];
    jlong contentLength = [((JavaIoFile *) nil_chk(content)) length];
    if (contentLength <= 0) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"No content");
    NetI2pDataDataHelper_writeLongWithJavaIoOutputStream_withInt_withLong_(out, 8, contentLength);
    [out writeWithInt:(jbyte) 0];
    if (fileType < 0 || fileType > 255) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"bad content type");
    [out writeWithInt:(jbyte) fileType];
    [out writeWithInt:(jbyte) 0];
    if (contentType < 0 || contentType > 255) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"bad content type");
    [out writeWithInt:(jbyte) contentType];
    [out writeWithByteArray:[IOSByteArray arrayWithLength:12]];
    [out writeWithByteArray:verBytes];
    if (verBytes->size_ < NetI2pCryptoSU3File_MIN_VERSION_BYTES) [out writeWithByteArray:[IOSByteArray arrayWithLength:NetI2pCryptoSU3File_MIN_VERSION_BYTES - verBytes->size_]];
    [out writeWithByteArray:signerBytes];
    IOSByteArray *buf = [IOSByteArray arrayWithLength:16 * 1024];
    jlong tot = 0;
    while (tot < contentLength) {
      jint read = [in readWithByteArray:buf withInt:0 withInt:(jint) JavaLangMath_minWithLong_withLong_(buf->size_, contentLength - tot)];
      if (read < 0) @throw create_JavaIoEOFException_init();
      [out writeWithByteArray:buf withInt:0 withInt:read];
      tot += read;
    }
    IOSByteArray *sha = [((JavaSecurityMessageDigest *) nil_chk(md)) digest];
    [out onWithBoolean:false];
    NetI2pDataSimpleDataStructure *hash_ = [sigType getHashInstance];
    [((NetI2pDataSimpleDataStructure *) nil_chk(hash_)) setDataWithByteArray:sha];
    NetI2pDataSignature *signature = [((NetI2pCryptoDSAEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) dsa])) signWithNetI2pDataSimpleDataStructure:hash_ withJavaSecurityPrivateKey:privkey withNetI2pCryptoSigType:sigType];
    if (signature == nil) @throw create_JavaIoIOException_initWithNSString_(@"sig fail");
    [signature writeBytesWithJavaIoOutputStream:out];
    ok = true;
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"foo");
    [ioe initCauseWithJavaLangThrowable:dfe];
    @throw ioe;
  }
  @finally {
    if (in != nil) @try {
      [in close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (out != nil) @try {
      [out close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (!ok) [((JavaIoFile *) nil_chk(_file_)) delete__];
  }
}

+ (void)mainWithNSStringArray:(IOSObjectArray *)args {
  NetI2pCryptoSU3File_mainWithNSStringArray_(args);
}

+ (void)showUsageCLI {
  NetI2pCryptoSU3File_showUsageCLI();
}

+ (NSString *)dumpTypes {
  return NetI2pCryptoSU3File_dumpTypes();
}

+ (NetI2pCryptoSU3File_ContentType *)parseContentTypeWithNSString:(NSString *)ctype {
  return NetI2pCryptoSU3File_parseContentTypeWithNSString_(ctype);
}

+ (jboolean)showVersionCLIWithNSString:(NSString *)signedFile {
  return NetI2pCryptoSU3File_showVersionCLIWithNSString_(signedFile);
}

+ (jboolean)bulkSignCLIWithNSString:(NSString *)stype
                       withNSString:(NSString *)ctype
                       withNSString:(NSString *)dir
                       withNSString:(NSString *)privateKeyFile
                       withNSString:(NSString *)version_
                       withNSString:(NSString *)signerName
                       withNSString:(NSString *)kspass {
  return NetI2pCryptoSU3File_bulkSignCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, ctype, dir, privateKeyFile, version_, signerName, kspass);
}

+ (jboolean)signCLIWithNSString:(NSString *)stype
                   withNSString:(NSString *)ctype
                   withNSString:(NSString *)ftype
                   withNSString:(NSString *)inputFile
                   withNSString:(NSString *)signedFile
                   withNSString:(NSString *)privateKeyFile
                   withNSString:(NSString *)version_
                   withNSString:(NSString *)signerName
                   withNSString:(NSString *)keypw
                   withNSString:(NSString *)kspass {
  return NetI2pCryptoSU3File_signCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, ctype, ftype, inputFile, signedFile, privateKeyFile, version_, signerName, keypw, kspass);
}

+ (jboolean)signCLIWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type
       withNetI2pCryptoSU3File_ContentType:(NetI2pCryptoSU3File_ContentType *)ctype
                                   withInt:(jint)ftype
                              withNSString:(NSString *)inputFile
                              withNSString:(NSString *)signedFile
                              withNSString:(NSString *)privateKeyFile
                              withNSString:(NSString *)version_
                              withNSString:(NSString *)signerName
                              withNSString:(NSString *)keypw
                              withNSString:(NSString *)kspass {
  return NetI2pCryptoSU3File_signCLIWithNetI2pCryptoSigType_withNetI2pCryptoSU3File_ContentType_withInt_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(type, ctype, ftype, inputFile, signedFile, privateKeyFile, version_, signerName, keypw, kspass);
}

+ (jboolean)verifySigCLIWithNSString:(NSString *)signedFile
                        withNSString:(NSString *)pkFile {
  return NetI2pCryptoSU3File_verifySigCLIWithNSString_withNSString_(signedFile, pkFile);
}

+ (jboolean)extractCLIWithNSString:(NSString *)signedFile
                      withNSString:(NSString *)outFile
                       withBoolean:(jboolean)verifySig
                      withNSString:(NSString *)pkFile {
  return NetI2pCryptoSU3File_extractCLIWithNSString_withNSString_withBoolean_withNSString_(signedFile, outFile, verifySig, pkFile);
}

+ (jboolean)genKeysCLIWithNSString:(NSString *)stype
                      withNSString:(NSString *)publicKeyFile
                      withNSString:(NSString *)privateKeyFile
                      withNSString:(NSString *)crlFile
                      withNSString:(NSString *)alias
                      withNSString:(NSString *)kspass {
  return NetI2pCryptoSU3File_genKeysCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, publicKeyFile, privateKeyFile, crlFile, alias, kspass);
}

+ (jboolean)genKeysCLIWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type
                                 withNSString:(NSString *)publicKeyFile
                                 withNSString:(NSString *)privateKeyFile
                                 withNSString:(NSString *)crlFile
                                 withNSString:(NSString *)alias
                                 withNSString:(NSString *)kspass {
  return NetI2pCryptoSU3File_genKeysCLIWithNetI2pCryptoSigType_withNSString_withNSString_withNSString_withNSString_withNSString_(type, publicKeyFile, privateKeyFile, crlFile, alias, kspass);
}

+ (id<JavaSecurityPublicKey>)loadKeyWithJavaIoFile:(JavaIoFile *)kd {
  return NetI2pCryptoSU3File_loadKeyWithJavaIoFile_(kd);
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_file_);
  RELEASE_(_version_);
  RELEASE_(_signer_);
  RELEASE_(_contentType_);
  RELEASE_(_signerPubkey_);
  RELEASE_(_sigType_);
  RELEASE_(_certFile_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 5, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSigType;", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 8, 9, -1, -1, -1 },
    { NULL, "V", 0xa, 10, 11, 6, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 6, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 6, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 1, 6, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, 6, -1, -1, -1 },
    { NULL, "V", 0x9, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x1a, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSU3File_ContentType;", 0xa, 17, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 18, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 19, 20, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 21, 22, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 21, 23, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 24, 25, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 26, 27, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 28, 29, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 28, 30, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityPublicKey;", 0xa, 31, 1, 6, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(initWithJavaIoFile:);
  methods[2].selector = @selector(initWithNetI2pI2PAppContext:withJavaIoFile:);
  methods[3].selector = @selector(setVerifySignatureWithBoolean:);
  methods[4].selector = @selector(setPublicKeyCertificateWithJavaIoFile:);
  methods[5].selector = @selector(getVersionString);
  methods[6].selector = @selector(getSignerString);
  methods[7].selector = @selector(getSigType);
  methods[8].selector = @selector(getContentType);
  methods[9].selector = @selector(getFileType);
  methods[10].selector = @selector(verifyHeader);
  methods[11].selector = @selector(verifyHeaderWithJavaIoInputStream:);
  methods[12].selector = @selector(skipWithJavaIoInputStream:withInt:);
  methods[13].selector = @selector(getContentOffset);
  methods[14].selector = @selector(verify);
  methods[15].selector = @selector(verifyAndMigrateWithJavaIoFile:);
  methods[16].selector = @selector(writeWithJavaIoFile:withInt:withInt:withNSString:withNSString:withJavaSecurityPrivateKey:withNetI2pCryptoSigType:);
  methods[17].selector = @selector(mainWithNSStringArray:);
  methods[18].selector = @selector(showUsageCLI);
  methods[19].selector = @selector(dumpTypes);
  methods[20].selector = @selector(parseContentTypeWithNSString:);
  methods[21].selector = @selector(showVersionCLIWithNSString:);
  methods[22].selector = @selector(bulkSignCLIWithNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:);
  methods[23].selector = @selector(signCLIWithNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:);
  methods[24].selector = @selector(signCLIWithNetI2pCryptoSigType:withNetI2pCryptoSU3File_ContentType:withInt:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:);
  methods[25].selector = @selector(verifySigCLIWithNSString:withNSString:);
  methods[26].selector = @selector(extractCLIWithNSString:withNSString:withBoolean:withNSString:);
  methods[27].selector = @selector(genKeysCLIWithNSString:withNSString:withNSString:withNSString:withNSString:withNSString:);
  methods[28].selector = @selector(genKeysCLIWithNetI2pCryptoSigType:withNSString:withNSString:withNSString:withNSString:withNSString:);
  methods[29].selector = @selector(loadKeyWithJavaIoFile:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_file_", "LJavaIoFile;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_version_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_versionLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_signer_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_signatureLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_signerLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_fileType_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_contentType_", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_contentLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_signerPubkey_", "LJavaSecurityPublicKey;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_headerVerified_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_sigType_", "LNetI2pCryptoSigType;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_verifySignature_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_certFile_", "LJavaIoFile;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "MAGIC", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 32, -1, -1 },
    { "MAGIC_BYTES", "[B", .constantValue.asLong = 0, 0x1a, -1, 33, -1, -1 },
    { "FILE_VERSION", "I", .constantValue.asInt = NetI2pCryptoSU3File_FILE_VERSION, 0x1a, -1, -1, -1, -1 },
    { "MIN_VERSION_BYTES", "I", .constantValue.asInt = NetI2pCryptoSU3File_MIN_VERSION_BYTES, 0x1a, -1, -1, -1, -1 },
    { "VERSION_OFFSET", "I", .constantValue.asInt = NetI2pCryptoSU3File_VERSION_OFFSET, 0x1a, -1, -1, -1, -1 },
    { "TYPE_ZIP", "I", .constantValue.asInt = NetI2pCryptoSU3File_TYPE_ZIP, 0x19, -1, -1, -1, -1 },
    { "TYPE_XML", "I", .constantValue.asInt = NetI2pCryptoSU3File_TYPE_XML, 0x19, -1, -1, -1, -1 },
    { "TYPE_HTML", "I", .constantValue.asInt = NetI2pCryptoSU3File_TYPE_HTML, 0x19, -1, -1, -1, -1 },
    { "TYPE_XML_GZ", "I", .constantValue.asInt = NetI2pCryptoSU3File_TYPE_XML_GZ, 0x19, -1, -1, -1, -1 },
    { "TYPE_TXT_GZ", "I", .constantValue.asInt = NetI2pCryptoSU3File_TYPE_TXT_GZ, 0x19, -1, -1, -1, -1 },
    { "CONTENT_UNKNOWN", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_UNKNOWN, 0x19, -1, -1, -1, -1 },
    { "CONTENT_ROUTER", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_ROUTER, 0x19, -1, -1, -1, -1 },
    { "CONTENT_PLUGIN", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_PLUGIN, 0x19, -1, -1, -1, -1 },
    { "CONTENT_RESEED", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_RESEED, 0x19, -1, -1, -1, -1 },
    { "CONTENT_NEWS", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_NEWS, 0x19, -1, -1, -1, -1 },
    { "CONTENT_BLOCKLIST", "I", .constantValue.asInt = NetI2pCryptoSU3File_CONTENT_BLOCKLIST, 0x19, -1, -1, -1, -1 },
    { "BY_CODE", "LJavaUtilMap;", .constantValue.asLong = 0, 0x1a, -1, 34, 35, -1 },
    { "DEFAULT_CONTENT_TYPE", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x1a, -1, 36, -1, -1 },
    { "DEFAULT_SIG_CODE", "I", .constantValue.asInt = NetI2pCryptoSU3File_DEFAULT_SIG_CODE, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;", "LJavaIoFile;", "LNetI2pI2PAppContext;LJavaIoFile;", "setVerifySignature", "Z", "setPublicKeyCertificate", "LJavaIoIOException;", "verifyHeader", "LJavaIoInputStream;", "LJavaIoIOException;LNetI2pDataDataFormatException;", "skip", "LJavaIoInputStream;I", "verifyAndMigrate", "write", "LJavaIoFile;IILNSString;LNSString;LJavaSecurityPrivateKey;LNetI2pCryptoSigType;", "main", "[LNSString;", "parseContentType", "showVersionCLI", "bulkSignCLI", "LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;", "signCLI", "LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;", "LNetI2pCryptoSigType;LNetI2pCryptoSU3File_ContentType;ILNSString;LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;", "verifySigCLI", "LNSString;LNSString;", "extractCLI", "LNSString;LNSString;ZLNSString;", "genKeysCLI", "LNSString;LNSString;LNSString;LNSString;LNSString;LNSString;", "LNetI2pCryptoSigType;LNSString;LNSString;LNSString;LNSString;LNSString;", "loadKey", &NetI2pCryptoSU3File_MAGIC, &NetI2pCryptoSU3File_MAGIC_BYTES, &NetI2pCryptoSU3File_BY_CODE, "Ljava/util/Map<Ljava/lang/Integer;Lnet/i2p/crypto/SU3File$ContentType;>;", &NetI2pCryptoSU3File_DEFAULT_CONTENT_TYPE, "LNetI2pCryptoSU3File_ContentType;" };
  static const J2ObjcClassInfo _NetI2pCryptoSU3File = { "SU3File", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x1, 30, 34, -1, 37, -1, -1, -1 };
  return &_NetI2pCryptoSU3File;
}

+ (void)initialize {
  if (self == [NetI2pCryptoSU3File class]) {
    JreStrongAssign(&NetI2pCryptoSU3File_MAGIC_BYTES, NetI2pDataDataHelper_getASCIIWithNSString_(NetI2pCryptoSU3File_MAGIC));
    JreStrongAssignAndConsume(&NetI2pCryptoSU3File_BY_CODE, new_JavaUtilHashMap_init());
    {
      {
        IOSObjectArray *a__ = NetI2pCryptoSU3File_ContentType_values();
        NetI2pCryptoSU3File_ContentType * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
        NetI2pCryptoSU3File_ContentType * const *e__ = b__ + a__->size_;
        while (b__ < e__) {
          NetI2pCryptoSU3File_ContentType *type = *b__++;
          [NetI2pCryptoSU3File_BY_CODE putWithId:JavaLangInteger_valueOfWithInt_([((NetI2pCryptoSU3File_ContentType *) nil_chk(type)) getCode]) withId:type];
        }
      }
    }
    JreStrongAssign(&NetI2pCryptoSU3File_DEFAULT_CONTENT_TYPE, JreLoadEnum(NetI2pCryptoSU3File_ContentType, UNKNOWN));
    J2OBJC_SET_INITIALIZED(NetI2pCryptoSU3File)
  }
}

@end

void NetI2pCryptoSU3File_initWithNSString_(NetI2pCryptoSU3File *self, NSString *file) {
  NetI2pCryptoSU3File_initWithJavaIoFile_(self, create_JavaIoFile_initWithNSString_(file));
}

NetI2pCryptoSU3File *new_NetI2pCryptoSU3File_initWithNSString_(NSString *file) {
  J2OBJC_NEW_IMPL(NetI2pCryptoSU3File, initWithNSString_, file)
}

NetI2pCryptoSU3File *create_NetI2pCryptoSU3File_initWithNSString_(NSString *file) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoSU3File, initWithNSString_, file)
}

void NetI2pCryptoSU3File_initWithJavaIoFile_(NetI2pCryptoSU3File *self, JavaIoFile *file) {
  NetI2pCryptoSU3File_initWithNetI2pI2PAppContext_withJavaIoFile_(self, NetI2pI2PAppContext_getGlobalContext(), file);
}

NetI2pCryptoSU3File *new_NetI2pCryptoSU3File_initWithJavaIoFile_(JavaIoFile *file) {
  J2OBJC_NEW_IMPL(NetI2pCryptoSU3File, initWithJavaIoFile_, file)
}

NetI2pCryptoSU3File *create_NetI2pCryptoSU3File_initWithJavaIoFile_(JavaIoFile *file) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoSU3File, initWithJavaIoFile_, file)
}

void NetI2pCryptoSU3File_initWithNetI2pI2PAppContext_withJavaIoFile_(NetI2pCryptoSU3File *self, NetI2pI2PAppContext *context, JavaIoFile *file) {
  NSObject_init(self);
  self->_fileType_ = -1;
  self->_verifySignature_ = true;
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_file_, file);
}

NetI2pCryptoSU3File *new_NetI2pCryptoSU3File_initWithNetI2pI2PAppContext_withJavaIoFile_(NetI2pI2PAppContext *context, JavaIoFile *file) {
  J2OBJC_NEW_IMPL(NetI2pCryptoSU3File, initWithNetI2pI2PAppContext_withJavaIoFile_, context, file)
}

NetI2pCryptoSU3File *create_NetI2pCryptoSU3File_initWithNetI2pI2PAppContext_withJavaIoFile_(NetI2pI2PAppContext *context, JavaIoFile *file) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoSU3File, initWithNetI2pI2PAppContext_withJavaIoFile_, context, file)
}

void NetI2pCryptoSU3File_setPublicKeyCertificateWithJavaIoFile_(NetI2pCryptoSU3File *self, JavaIoFile *certFile) {
  JreStrongAssign(&self->_certFile_, certFile);
}

void NetI2pCryptoSU3File_verifyHeaderWithJavaIoInputStream_(NetI2pCryptoSU3File *self, JavaIoInputStream *inArg) {
  IOSByteArray *magic = [IOSByteArray arrayWithLength:((IOSByteArray *) nil_chk(NetI2pCryptoSU3File_MAGIC_BYTES))->size_];
  NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(inArg, magic);
  if (!NetI2pDataDataHelper_eqWithByteArray_withByteArray_(magic, NetI2pCryptoSU3File_MAGIC_BYTES)) @throw create_JavaIoIOException_initWithNSString_(@"Not an su3 file");
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 1);
  jint foo = [((JavaIoInputStream *) nil_chk(inArg)) read];
  if (foo != NetI2pCryptoSU3File_FILE_VERSION) @throw create_JavaIoIOException_initWithNSString_(@"bad file version");
  jint sigTypeCode = (jint) NetI2pDataDataHelper_readLongWithJavaIoInputStream_withInt_(inArg, 2);
  JreStrongAssign(&self->_sigType_, NetI2pCryptoSigType_getByCodeWithInt_(sigTypeCode));
  if (self->_sigType_ == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$I", @"unknown sig type: ", sigTypeCode));
  self->_signatureLength_ = (jint) NetI2pDataDataHelper_readLongWithJavaIoInputStream_withInt_(inArg, 2);
  if (self->_signatureLength_ != [((NetI2pCryptoSigType *) nil_chk(self->_sigType_)) getSigLen]) @throw create_JavaIoIOException_initWithNSString_(@"bad sig length");
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 1);
  jint _versionLength = [inArg read];
  if (_versionLength < NetI2pCryptoSU3File_MIN_VERSION_BYTES) @throw create_JavaIoIOException_initWithNSString_(@"bad version length");
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 1);
  self->_signerLength_ = [inArg read];
  if (self->_signerLength_ <= 0) @throw create_JavaIoIOException_initWithNSString_(@"bad signer length");
  self->_contentLength_ = NetI2pDataDataHelper_readLongWithJavaIoInputStream_withInt_(inArg, 8);
  if (self->_contentLength_ <= 0) @throw create_JavaIoIOException_initWithNSString_(@"bad content length");
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 1);
  self->_fileType_ = [inArg read];
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 1);
  jint cType = [inArg read];
  JreStrongAssign(&self->_contentType_, [((id<JavaUtilMap>) nil_chk(NetI2pCryptoSU3File_BY_CODE)) getWithId:JavaLangInteger_valueOfWithInt_(cType)]);
  if (self->_contentType_ == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$I", @"unknown content type ", cType));
  NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(inArg, 12);
  IOSByteArray *data = [IOSByteArray arrayWithLength:_versionLength];
  jint bytesRead = NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(inArg, data);
  if (bytesRead != _versionLength) @throw create_JavaIoEOFException_init();
  jint zbyte;
  for (zbyte = 0; zbyte < _versionLength; zbyte++) {
    if (IOSByteArray_Get(data, zbyte) == (jint) 0x00) break;
  }
  JreStrongAssign(&self->_version_, [NSString java_stringWithBytes:data offset:0 length:zbyte charsetName:@"UTF-8"]);
  data = [IOSByteArray arrayWithLength:self->_signerLength_];
  bytesRead = NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(inArg, data);
  if (bytesRead != self->_signerLength_) @throw create_JavaIoEOFException_init();
  JreStrongAssign(&self->_signer_, NetI2pDataDataHelper_getUTF8WithByteArray_(data));
  if (self->_verifySignature_) {
    if (self->_certFile_ != nil) {
      JreStrongAssign(&self->_signerPubkey_, NetI2pCryptoSU3File_loadKeyWithJavaIoFile_(self->_certFile_));
    }
    else {
      id<NetI2pCryptoKeyRing> ring = create_NetI2pCryptoDirKeyRing_initWithJavaIoFile_(create_JavaIoFile_initWithJavaIoFile_withNSString_([((NetI2pI2PAppContext *) nil_chk(self->_context_)) getBaseDir], @"certificates"));
      @try {
        JreStrongAssign(&self->_signerPubkey_, [ring getKeyWithNSString:self->_signer_ withNSString:[((NetI2pCryptoSU3File_ContentType *) nil_chk(self->_contentType_)) getName] withNetI2pCryptoSigType:self->_sigType_]);
      }
      @catch (JavaSecurityGeneralSecurityException *gse) {
        JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(JreStrcat("$$$@", @"Certificate error for ", self->_signer_, @": ", gse));
        [ioe initCauseWithJavaLangThrowable:gse];
        @throw ioe;
      }
      if (self->_signerPubkey_ == nil) {
        jboolean diff = true;
        @try {
          diff = ![((NSString *) nil_chk([((JavaIoFile *) nil_chk([self->_context_ getBaseDir])) getCanonicalPath])) isEqual:[((JavaIoFile *) nil_chk([self->_context_ getConfigDir])) getCanonicalPath]];
        }
        @catch (JavaIoIOException *ioe) {
        }
        if (diff) {
          ring = create_NetI2pCryptoDirKeyRing_initWithJavaIoFile_(create_JavaIoFile_initWithJavaIoFile_withNSString_([self->_context_ getConfigDir], @"certificates"));
          @try {
            JreStrongAssign(&self->_signerPubkey_, [ring getKeyWithNSString:self->_signer_ withNSString:[((NetI2pCryptoSU3File_ContentType *) nil_chk(self->_contentType_)) getName] withNetI2pCryptoSigType:self->_sigType_]);
          }
          @catch (JavaSecurityGeneralSecurityException *gse) {
            JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(JreStrcat("$$$@", @"Certificate error for ", self->_signer_, @": ", gse));
            [ioe initCauseWithJavaLangThrowable:gse];
            @throw ioe;
          }
        }
        if (self->_signerPubkey_ == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$$$$", @"unknown signer: ", self->_signer_, @" for content type: ", [((NetI2pCryptoSU3File_ContentType *) nil_chk(self->_contentType_)) getName]));
      }
    }
  }
  self->_headerVerified_ = true;
}

void NetI2pCryptoSU3File_skipWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint cnt) {
  NetI2pCryptoSU3File_initialize();
  for (jint i = 0; i < cnt; i++) {
    if ([((JavaIoInputStream *) nil_chk(inArg)) read] < 0) @throw create_JavaIoEOFException_init();
  }
}

jint NetI2pCryptoSU3File_getContentOffset(NetI2pCryptoSU3File *self) {
  [self verifyHeader];
  return NetI2pCryptoSU3File_VERSION_OFFSET + self->_versionLength_ + self->_signerLength_;
}

void NetI2pCryptoSU3File_mainWithNSStringArray_(IOSObjectArray *args) {
  NetI2pCryptoSU3File_initialize();
  jboolean ok = false;
  @try {
    NSString *stype = nil;
    NSString *ctype = nil;
    NSString *ftype = nil;
    NSString *kfile = nil;
    NSString *crlfile = nil;
    NSString *kspass = NetI2pCryptoKeyStoreUtil_DEFAULT_KEYSTORE_PASSWORD;
    jboolean error = false;
    jboolean shouldVerify = true;
    GnuGetoptGetopt *g = create_GnuGetoptGetopt_initWithNSString_withNSStringArray_withNSString_(@"SU3File", args, @"t:c:f:k:xp:r:");
    jint c;
    while ((c = [g getopt]) != -1) {
      switch (c) {
        case 't':
        stype = [g getOptarg];
        break;
        case 'c':
        ctype = [g getOptarg];
        break;
        case 'f':
        ftype = [g getOptarg];
        break;
        case 'k':
        kfile = [g getOptarg];
        break;
        case 'r':
        crlfile = [g getOptarg];
        break;
        case 'x':
        shouldVerify = false;
        break;
        case 'p':
        kspass = [g getOptarg];
        break;
        case '?':
        case ':':
        default:
        error = true;
      }
    }
    jint idx = [g getOptind];
    NSString *cmd = IOSObjectArray_Get(nil_chk(args), idx);
    id<JavaUtilList> a = create_JavaUtilArrayList_initWithJavaUtilCollection_([((id<JavaUtilList>) nil_chk(JavaUtilArrays_asListWithNSObjectArray_(args))) subListWithInt:idx + 1 withInt:args->size_]);
    if (error) {
      NetI2pCryptoSU3File_showUsageCLI();
    }
    else if ([@"showversion" isEqual:cmd]) {
      ok = NetI2pCryptoSU3File_showVersionCLIWithNSString_([a getWithInt:0]);
    }
    else if ([@"sign" isEqual:cmd]) {
      JavaUtilProperties *props = create_JavaUtilProperties_init();
      [props setPropertyWithNSString:@"prng.bufferSize" withNSString:@"16384"];
      create_NetI2pI2PAppContext_initWithJavaUtilProperties_(props);
      ok = NetI2pCryptoSU3File_signCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, ctype, ftype, [a getWithInt:0], [a getWithInt:1], [a getWithInt:2], [a getWithInt:3], [a getWithInt:4], @"", kspass);
    }
    else if ([@"bulksign" isEqual:cmd]) {
      JavaUtilProperties *props = create_JavaUtilProperties_init();
      [props setPropertyWithNSString:@"prng.bufferSize" withNSString:@"16384"];
      create_NetI2pI2PAppContext_initWithJavaUtilProperties_(props);
      ok = NetI2pCryptoSU3File_bulkSignCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, ctype, [a getWithInt:0], [a getWithInt:1], [a getWithInt:2], [a getWithInt:3], kspass);
    }
    else if ([@"verifysig" isEqual:cmd]) {
      ok = NetI2pCryptoSU3File_verifySigCLIWithNSString_withNSString_([a getWithInt:0], kfile);
    }
    else if ([@"keygen" isEqual:cmd]) {
      JavaUtilProperties *props = create_JavaUtilProperties_init();
      [props setPropertyWithNSString:@"prng.bufferSize" withNSString:@"16384"];
      create_NetI2pI2PAppContext_initWithJavaUtilProperties_(props);
      ok = NetI2pCryptoSU3File_genKeysCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, [a getWithInt:0], [a getWithInt:1], crlfile, [a getWithInt:2], kspass);
    }
    else if ([@"extract" isEqual:cmd]) {
      ok = NetI2pCryptoSU3File_extractCLIWithNSString_withNSString_withBoolean_withNSString_([a getWithInt:0], [a getWithInt:1], shouldVerify, kfile);
    }
    else {
      NetI2pCryptoSU3File_showUsageCLI();
    }
  }
  @catch (JavaUtilNoSuchElementException *nsee) {
    NetI2pCryptoSU3File_showUsageCLI();
  }
  @catch (JavaLangIndexOutOfBoundsException *ioobe) {
    NetI2pCryptoSU3File_showUsageCLI();
  }
  if (!ok) JavaLangSystem_exitWithInt_(1);
}

void NetI2pCryptoSU3File_showUsageCLI() {
  NetI2pCryptoSU3File_initialize();
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"Usage: SU3File keygen       [-t type|code] [-p keystorepw] [-r crlFile.crl] publicKeyFile.crt keystore.ks you@mail.i2p\n       SU3File sign         [-t type|code] [-c type|code] [-f type|code] [-p keystorepw] inputFile.zip signedFile.su3 keystore.ks version you@mail.i2p\n       SU3File bulksign     [-t type|code] [-c type|code] [-p keystorepw] directory keystore.ks version you@mail.i2p\n                            (signs all .zip, .xml, and .xml.gz files in the directory)\n       SU3File showversion  signedFile.su3\n       SU3File verifysig    [-k file.crt] signedFile.su3  ## -k use this pubkey cert for verification\n       SU3File extract      [-x] [-k file.crt] signedFile.su3 outFile   ## -x don't check sig"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$C", @"Default keystore password: \"", NetI2pCryptoKeyStoreUtil_DEFAULT_KEYSTORE_PASSWORD, '"')];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:NetI2pCryptoSU3File_dumpTypes()];
}

NSString *NetI2pCryptoSU3File_dumpTypes() {
  NetI2pCryptoSU3File_initialize();
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(256);
  [buf appendWithNSString:@"Available signature types (-t):\n"];
  for (NetI2pCryptoSigType * __strong t in nil_chk(JavaUtilEnumSet_allOfWithIOSClass_(NetI2pCryptoSigType_class_()))) {
    if (![((NetI2pCryptoSigType *) nil_chk(t)) isAvailable]) continue;
    if (t == JreLoadEnum(NetI2pCryptoSigType, EdDSA_SHA512_Ed25519)) continue;
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"      "])) appendWithId:t])) appendWithNSString:@"\t(code: "])) appendWithInt:[t getCode]])) appendWithChar:')'];
    if ([t getCode] == NetI2pCryptoSU3File_DEFAULT_SIG_CODE) [buf appendWithNSString:@" DEFAULT"];
    if (![t isAvailable]) [buf appendWithNSString:@" UNAVAILABLE"];
    [buf appendWithChar:0x000a];
  }
  [buf appendWithNSString:@"Available content types (-c):\n"];
  for (NetI2pCryptoSU3File_ContentType * __strong t in nil_chk(JavaUtilEnumSet_allOfWithIOSClass_(NetI2pCryptoSU3File_ContentType_class_()))) {
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"      "])) appendWithId:t])) appendWithNSString:@"\t(code: "])) appendWithInt:[((NetI2pCryptoSU3File_ContentType *) nil_chk(t)) getCode]])) appendWithChar:')'];
    if (t == NetI2pCryptoSU3File_DEFAULT_CONTENT_TYPE) [buf appendWithNSString:@" DEFAULT"];
    [buf appendWithChar:0x000a];
  }
  [buf appendWithNSString:@"Available file types (-f):\n      ZIP\t(code: 0) DEFAULT\n      XML\t(code: 1)\n      HTML\t(code: 2)\n      XML_GZ\t(code: 3)\n      TXT_GZ\t(code: 4)\n      (user defined)\t(code: 5-255)\n"];
  return [buf description];
}

NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_parseContentTypeWithNSString_(NSString *ctype) {
  NetI2pCryptoSU3File_initialize();
  @try {
    return NetI2pCryptoSU3File_ContentType_valueOfWithNSString_([((NSString *) nil_chk(ctype)) java_uppercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, US)]);
  }
  @catch (JavaLangIllegalArgumentException *iae) {
    @try {
      jint code = JavaLangInteger_parseIntWithNSString_(ctype);
      return NetI2pCryptoSU3File_ContentType_getByCodeWithInt_(code);
    }
    @catch (JavaLangNumberFormatException *nfe) {
      return nil;
    }
  }
}

jboolean NetI2pCryptoSU3File_showVersionCLIWithNSString_(NSString *signedFile) {
  NetI2pCryptoSU3File_initialize();
  @try {
    NetI2pCryptoSU3File *file = create_NetI2pCryptoSU3File_initWithNSString_(signedFile);
    [file setVerifySignatureWithBoolean:false];
    NSString *versionString = [file getVersionString];
    if ([((NSString *) nil_chk(versionString)) isEqual:@""]) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"No version string found in file '", signedFile, '\'')];
    else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Version:  ", versionString)];
    NSString *signerString = [file getSignerString];
    if ([((NSString *) nil_chk(signerString)) isEqual:@""]) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"No signer string found in file '", signedFile, '\'')];
    else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Signer:   ", signerString)];
    if (file->_sigType_ != nil) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"SigType:  ", file->_sigType_)];
    if (file->_contentType_ != nil) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Content:  ", file->_contentType_)];
    NSString *ftype;
    if (file->_fileType_ == NetI2pCryptoSU3File_TYPE_ZIP) ftype = @"ZIP";
    else if (file->_fileType_ == NetI2pCryptoSU3File_TYPE_XML) ftype = @"XML";
    else if (file->_fileType_ == NetI2pCryptoSU3File_TYPE_HTML) ftype = @"HTML";
    else if (file->_fileType_ == NetI2pCryptoSU3File_TYPE_XML_GZ) ftype = @"XML_GZ";
    else ftype = JavaLangInteger_toStringWithInt_(file->_fileType_);
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"FileType: ", ftype)];
    return ![versionString isEqual:@""];
  }
  @catch (JavaIoIOException *ioe) {
    [ioe printStackTrace];
    return false;
  }
}

jboolean NetI2pCryptoSU3File_bulkSignCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *ctype, NSString *dir, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *kspass) {
  NetI2pCryptoSU3File_initialize();
  JavaIoFile *d = create_JavaIoFile_initWithNSString_(dir);
  if (![d isDirectory]) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Directory does not exist: ", d)];
    return false;
  }
  IOSObjectArray *files = [d listFiles];
  if (files == nil || files->size_ == 0) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"No zip files found in ", d)];
    return false;
  }
  NSString *keypw = @"";
  @try {
    while ([keypw java_length] < 6) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printWithNSString:JreStrcat("$$$", @"Enter password for key \"", signerName, @"\": ")];
      keypw = NetI2pDataDataHelper_readLineWithJavaIoInputStream_(JreLoadStatic(JavaLangSystem, in));
      if (keypw == nil) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"\nEOF reading password"];
        return false;
      }
      keypw = [keypw java_trim];
      if ([((NSString *) nil_chk(keypw)) java_length] > 0 && [keypw java_length] < 6) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Key password must be at least 6 characters"];
    }
  }
  @catch (JavaIoIOException *ioe) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Error asking for password"];
    [ioe printStackTrace];
    return false;
  }
  jint success = 0;
  {
    IOSObjectArray *a__ = files;
    JavaIoFile * const *b__ = a__->buffer_;
    JavaIoFile * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      JavaIoFile *in = *b__++;
      NSString *inputFile = [((JavaIoFile *) nil_chk(in)) getPath];
      jint len;
      NSString *ftype;
      if ([((NSString *) nil_chk(inputFile)) java_hasSuffix:@".zip"]) {
        len = 4;
        ftype = @"ZIP";
      }
      else if ([inputFile java_hasSuffix:@".xml"]) {
        len = 4;
        ftype = @"XML";
      }
      else if ([inputFile java_hasSuffix:@".xml.gz"]) {
        len = 7;
        ftype = @"XML_GZ";
      }
      else {
        continue;
      }
      NSString *signedFile = JreStrcat("$$", [inputFile java_substring:0 endIndex:[inputFile java_length] - len], @".su3");
      jboolean rv = NetI2pCryptoSU3File_signCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(stype, ctype, ftype, inputFile, signedFile, privateKeyFile, version_, signerName, keypw, kspass);
      if (!rv) return false;
      success++;
    }
  }
  if (success == 0) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"No files processed in ", d)];
  return success > 0;
}

jboolean NetI2pCryptoSU3File_signCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *ctype, NSString *ftype, NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *keypw, NSString *kspass) {
  NetI2pCryptoSU3File_initialize();
  NetI2pCryptoSigType *type = stype == nil ? NetI2pCryptoSigType_getByCodeWithInt_([JavaLangInteger_valueOfWithInt_(NetI2pCryptoSU3File_DEFAULT_SIG_CODE) intValue]) : NetI2pCryptoSigType_parseSigTypeWithNSString_(stype);
  if (type == nil) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"Signature type ", stype, @" is not supported")];
    return false;
  }
  NetI2pCryptoSU3File_ContentType *ct = ctype == nil ? NetI2pCryptoSU3File_DEFAULT_CONTENT_TYPE : NetI2pCryptoSU3File_parseContentTypeWithNSString_(ctype);
  if (ct == nil) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"Content type ", ctype, @" is not supported")];
    return false;
  }
  jint ft = NetI2pCryptoSU3File_TYPE_ZIP;
  if (ftype != nil) {
    if ([ftype java_equalsIgnoreCase:@"ZIP"]) {
      ft = NetI2pCryptoSU3File_TYPE_ZIP;
    }
    else if ([ftype java_equalsIgnoreCase:@"XML"]) {
      ft = NetI2pCryptoSU3File_TYPE_XML;
    }
    else if ([ftype java_equalsIgnoreCase:@"HTML"]) {
      ft = NetI2pCryptoSU3File_TYPE_HTML;
    }
    else if ([ftype java_equalsIgnoreCase:@"XML_GZ"]) {
      ft = NetI2pCryptoSU3File_TYPE_XML_GZ;
    }
    else {
      @try {
        ft = JavaLangInteger_parseIntWithNSString_(ftype);
      }
      @catch (JavaLangNumberFormatException *nfe) {
        ft = -1;
      }
      if (ft < 0 || ft > 255) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"File type ", ftype, @" is not supported")];
        return false;
      }
      if (ft > NetI2pCryptoSU3File_TYPE_XML_GZ) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"Warning: File type ", ftype, @" is undefined")];
    }
  }
  return NetI2pCryptoSU3File_signCLIWithNetI2pCryptoSigType_withNetI2pCryptoSU3File_ContentType_withInt_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(type, ct, ft, inputFile, signedFile, privateKeyFile, version_, signerName, keypw, kspass);
}

jboolean NetI2pCryptoSU3File_signCLIWithNetI2pCryptoSigType_withNetI2pCryptoSU3File_ContentType_withInt_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NetI2pCryptoSigType *type, NetI2pCryptoSU3File_ContentType *ctype, jint ftype, NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_, NSString *signerName, NSString *keypw, NSString *kspass) {
  NetI2pCryptoSU3File_initialize();
  @try {
    while ([((NSString *) nil_chk(keypw)) java_length] < 6) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printWithNSString:JreStrcat("$$$", @"Enter password for key \"", signerName, @"\": ")];
      keypw = NetI2pDataDataHelper_readLineWithJavaIoInputStream_(JreLoadStatic(JavaLangSystem, in));
      if (keypw == nil) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"\nEOF reading password"];
        return false;
      }
      keypw = [keypw java_trim];
      if ([((NSString *) nil_chk(keypw)) java_length] > 0 && [keypw java_length] < 6) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Key password must be at least 6 characters"];
    }
    JavaIoFile *pkfile = create_JavaIoFile_initWithNSString_(privateKeyFile);
    id<JavaSecurityPrivateKey> pk = NetI2pCryptoKeyStoreUtil_getPrivateKeyWithJavaIoFile_withNSString_withNSString_withNSString_(pkfile, kspass, signerName, keypw);
    if (pk == nil) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$$", @"Private key for ", signerName, @" not found in keystore ", privateKeyFile)];
      return false;
    }
    NetI2pCryptoSigType *oldType = type;
    type = [((NetI2pDataSigningPrivateKey *) nil_chk(NetI2pCryptoSigUtil_fromJavaKeyWithJavaSecurityPrivateKey_(pk))) getType];
    if (oldType != type) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@$@", @"Warning: Using private key type ", type, @", ignoring specified type ", oldType)];
    NetI2pCryptoSU3File *file = create_NetI2pCryptoSU3File_initWithNSString_(signedFile);
    [file writeWithJavaIoFile:create_JavaIoFile_initWithNSString_(inputFile) withInt:ftype withInt:[((NetI2pCryptoSU3File_ContentType *) nil_chk(ctype)) getCode] withNSString:version_ withNSString:signerName withJavaSecurityPrivateKey:pk withNetI2pCryptoSigType:type];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$$C", @"Input file '", inputFile, @"' signed and written to '", signedFile, '\'')];
    return true;
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"Error signing input file '", inputFile, '\'')];
    [gse printStackTrace];
    return false;
  }
  @catch (JavaIoIOException *ioe) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"Error signing input file '", inputFile, '\'')];
    [ioe printStackTrace];
    return false;
  }
}

jboolean NetI2pCryptoSU3File_verifySigCLIWithNSString_withNSString_(NSString *signedFile, NSString *pkFile) {
  NetI2pCryptoSU3File_initialize();
  JavaIoInputStream *in = nil;
  @try {
    NetI2pCryptoSU3File *file = create_NetI2pCryptoSU3File_initWithNSString_(signedFile);
    if (pkFile != nil) NetI2pCryptoSU3File_setPublicKeyCertificateWithJavaIoFile_(file, create_JavaIoFile_initWithNSString_(pkFile));
    jboolean isValidSignature = [file verify];
    if (isValidSignature) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C@C", @"Signature VALID (signed by ", [file getSignerString], ' ', file->_sigType_, ')')];
    else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C@C", @"Signature INVALID (signed by ", [file getSignerString], ' ', file->_sigType_, ')')];
    return isValidSignature;
  }
  @catch (JavaIoIOException *ioe) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"Error verifying input file '", signedFile, '\'')];
    [ioe printStackTrace];
    return false;
  }
}

jboolean NetI2pCryptoSU3File_extractCLIWithNSString_withNSString_withBoolean_withNSString_(NSString *signedFile, NSString *outFile, jboolean verifySig, NSString *pkFile) {
  NetI2pCryptoSU3File_initialize();
  JavaIoInputStream *in = nil;
  @try {
    NetI2pCryptoSU3File *file = create_NetI2pCryptoSU3File_initWithNSString_(signedFile);
    if (pkFile != nil) NetI2pCryptoSU3File_setPublicKeyCertificateWithJavaIoFile_(file, create_JavaIoFile_initWithNSString_(pkFile));
    [file setVerifySignatureWithBoolean:verifySig];
    JavaIoFile *out = create_JavaIoFile_initWithNSString_(outFile);
    jboolean ok = [file verifyAndMigrateWithJavaIoFile:out];
    if (ok) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C@C", @"File extracted (signed by ", [file getSignerString], ' ', file->_sigType_, ')')];
    else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C@C", @"Signature INVALID (signed by ", [file getSignerString], ' ', file->_sigType_, ')')];
    return ok;
  }
  @catch (JavaIoIOException *ioe) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"Error extracting from file '", signedFile, '\'')];
    [ioe printStackTrace];
    return false;
  }
}

jboolean NetI2pCryptoSU3File_genKeysCLIWithNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(NSString *stype, NSString *publicKeyFile, NSString *privateKeyFile, NSString *crlFile, NSString *alias, NSString *kspass) {
  NetI2pCryptoSU3File_initialize();
  NetI2pCryptoSigType *type = stype == nil ? NetI2pCryptoSigType_getByCodeWithInt_([JavaLangInteger_valueOfWithInt_(NetI2pCryptoSU3File_DEFAULT_SIG_CODE) intValue]) : NetI2pCryptoSigType_parseSigTypeWithNSString_(stype);
  if (type == nil) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"Signature type ", stype, @" is not supported")];
    return false;
  }
  return NetI2pCryptoSU3File_genKeysCLIWithNetI2pCryptoSigType_withNSString_withNSString_withNSString_withNSString_withNSString_(type, publicKeyFile, privateKeyFile, crlFile, alias, kspass);
}

jboolean NetI2pCryptoSU3File_genKeysCLIWithNetI2pCryptoSigType_withNSString_withNSString_withNSString_withNSString_withNSString_(NetI2pCryptoSigType *type, NSString *publicKeyFile, NSString *privateKeyFile, NSString *crlFile, NSString *alias, NSString *kspass) {
  NetI2pCryptoSU3File_initialize();
  JavaIoFile *pubFile = create_JavaIoFile_initWithNSString_(publicKeyFile);
  if ([pubFile exists]) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Error: Not overwriting file ", publicKeyFile)];
    return false;
  }
  JavaIoFile *ksFile = create_JavaIoFile_initWithNSString_(privateKeyFile);
  NSString *keypw = @"";
  @try {
    while ([((NSString *) nil_chk(alias)) java_length] == 0) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printWithNSString:@"Enter key name (example@mail.i2p): "];
      alias = NetI2pDataDataHelper_readLineWithJavaIoInputStream_(JreLoadStatic(JavaLangSystem, in));
      if (alias == nil) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"\nEOF reading key name"];
        return false;
      }
      alias = [alias java_trim];
    }
    while ([keypw java_length] < 6) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printWithNSString:@"Enter new key password: "];
      keypw = NetI2pDataDataHelper_readLineWithJavaIoInputStream_(JreLoadStatic(JavaLangSystem, in));
      if (keypw == nil) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"\nEOF reading password"];
        return false;
      }
      keypw = [keypw java_trim];
      if ([((NSString *) nil_chk(keypw)) java_length] > 0 && [keypw java_length] < 6) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Key password must be at least 6 characters"];
    }
  }
  @catch (JavaIoIOException *ioe) {
    return false;
  }
  JavaIoOutputStream *out = nil;
  @try {
    IOSObjectArray *rv = NetI2pCryptoKeyStoreUtil_createKeysAndCRLWithJavaIoFile_withNSString_withNSString_withNSString_withNSString_withInt_withNetI2pCryptoSigType_withNSString_(ksFile, kspass, alias, alias, @"I2P", 3652, type, keypw);
    JavaSecurityCertX509Certificate *cert = (JavaSecurityCertX509Certificate *) cast_chk(IOSObjectArray_Get(nil_chk(rv), 2), [JavaSecurityCertX509Certificate class]);
    out = create_NetI2pUtilSecureFileOutputStream_initWithNSString_(publicKeyFile);
    NetI2pCryptoCertUtil_exportCertWithJavaSecurityCertCertificate_withJavaIoOutputStream_(cert, out);
    if (crlFile != nil) {
      [out close];
      JavaSecurityCertX509CRL *crl = (JavaSecurityCertX509CRL *) cast_chk(IOSObjectArray_Get(rv, 3), [JavaSecurityCertX509CRL class]);
      out = create_NetI2pUtilSecureFileOutputStream_initWithNSString_(crlFile);
      NetI2pCryptoCertUtil_exportCRLWithJavaSecurityCertX509CRL_withJavaIoOutputStream_(crl, out);
    }
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$", @"Error creating keys for ", alias)];
    [gse printStackTrace];
    return false;
  }
  @catch (JavaIoIOException *ioe) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$", @"Error creating keys for ", alias)];
    [ioe printStackTrace];
    return false;
  }
  @finally {
    if (out != nil) @try {
      [out close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return true;
}

id<JavaSecurityPublicKey> NetI2pCryptoSU3File_loadKeyWithJavaIoFile_(JavaIoFile *kd) {
  NetI2pCryptoSU3File_initialize();
  @try {
    return NetI2pCryptoCertUtil_loadKeyWithJavaIoFile_(kd);
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"cert error");
    [ioe initCauseWithJavaLangThrowable:gse];
    @throw ioe;
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoSU3File)

J2OBJC_INITIALIZED_DEFN(NetI2pCryptoSU3File_ContentType)

NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_values_[6];

@implementation NetI2pCryptoSU3File_ContentType

+ (NetI2pCryptoSU3File_ContentType *)UNKNOWN {
  return JreEnum(NetI2pCryptoSU3File_ContentType, UNKNOWN);
}

+ (NetI2pCryptoSU3File_ContentType *)ROUTER {
  return JreEnum(NetI2pCryptoSU3File_ContentType, ROUTER);
}

+ (NetI2pCryptoSU3File_ContentType *)PLUGIN {
  return JreEnum(NetI2pCryptoSU3File_ContentType, PLUGIN);
}

+ (NetI2pCryptoSU3File_ContentType *)RESEED {
  return JreEnum(NetI2pCryptoSU3File_ContentType, RESEED);
}

+ (NetI2pCryptoSU3File_ContentType *)NEWS {
  return JreEnum(NetI2pCryptoSU3File_ContentType, NEWS);
}

+ (NetI2pCryptoSU3File_ContentType *)BLOCKLIST {
  return JreEnum(NetI2pCryptoSU3File_ContentType, BLOCKLIST);
}

- (jint)getCode {
  return code_;
}

- (NSString *)getName {
  return name_ContentType_;
}

+ (NetI2pCryptoSU3File_ContentType *)getByCodeWithInt:(jint)code {
  return NetI2pCryptoSU3File_ContentType_getByCodeWithInt_(code);
}

+ (IOSObjectArray *)values {
  return NetI2pCryptoSU3File_ContentType_values();
}

+ (NetI2pCryptoSU3File_ContentType *)valueOfWithNSString:(NSString *)name {
  return NetI2pCryptoSU3File_ContentType_valueOfWithNSString_(name);
}

- (NetI2pCryptoSU3File_ContentType_Enum)toNSEnum {
  return (NetI2pCryptoSU3File_ContentType_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSU3File_ContentType;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "[LNetI2pCryptoSU3File_ContentType;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSU3File_ContentType;", 0x9, 2, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getCode);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(getByCodeWithInt:);
  methods[3].selector = @selector(values);
  methods[4].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "UNKNOWN", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "ROUTER", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 5, -1, -1 },
    { "PLUGIN", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 6, -1, -1 },
    { "RESEED", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 7, -1, -1 },
    { "NEWS", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 8, -1, -1 },
    { "BLOCKLIST", "LNetI2pCryptoSU3File_ContentType;", .constantValue.asLong = 0, 0x4019, -1, 9, -1, -1 },
    { "code_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "name_ContentType_", "LNSString;", .constantValue.asLong = 0, 0x12, 10, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getByCode", "I", "valueOf", "LNSString;", &JreEnum(NetI2pCryptoSU3File_ContentType, UNKNOWN), &JreEnum(NetI2pCryptoSU3File_ContentType, ROUTER), &JreEnum(NetI2pCryptoSU3File_ContentType, PLUGIN), &JreEnum(NetI2pCryptoSU3File_ContentType, RESEED), &JreEnum(NetI2pCryptoSU3File_ContentType, NEWS), &JreEnum(NetI2pCryptoSU3File_ContentType, BLOCKLIST), "name", "LNetI2pCryptoSU3File;", "Ljava/lang/Enum<Lnet/i2p/crypto/SU3File$ContentType;>;" };
  static const J2ObjcClassInfo _NetI2pCryptoSU3File_ContentType = { "ContentType", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x401a, 5, 8, 11, -1, -1, 12, -1 };
  return &_NetI2pCryptoSU3File_ContentType;
}

+ (void)initialize {
  if (self == [NetI2pCryptoSU3File_ContentType class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 6 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, UNKNOWN) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_UNKNOWN, @"unknown", @"UNKNOWN", 0);
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, ROUTER) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_ROUTER, @"router", @"ROUTER", 1);
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, PLUGIN) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_PLUGIN, @"plugin", @"PLUGIN", 2);
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, RESEED) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_RESEED, @"reseed", @"RESEED", 3);
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, NEWS) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_NEWS, @"news", @"NEWS", 4);
    ((void) (JreEnum(NetI2pCryptoSU3File_ContentType, BLOCKLIST) = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
    NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(e, NetI2pCryptoSU3File_CONTENT_BLOCKLIST, @"blocklist", @"BLOCKLIST", 5);
    J2OBJC_SET_INITIALIZED(NetI2pCryptoSU3File_ContentType)
  }
}

@end

void NetI2pCryptoSU3File_ContentType_initWithInt_withNSString_withNSString_withInt_(NetI2pCryptoSU3File_ContentType *self, jint code, NSString *name, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
  self->code_ = code;
  JreStrongAssign(&self->name_ContentType_, name);
}

NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_getByCodeWithInt_(jint code) {
  NetI2pCryptoSU3File_ContentType_initialize();
  return [((id<JavaUtilMap>) nil_chk(JreLoadStatic(NetI2pCryptoSU3File, BY_CODE))) getWithId:JavaLangInteger_valueOfWithInt_(code)];
}

IOSObjectArray *NetI2pCryptoSU3File_ContentType_values() {
  NetI2pCryptoSU3File_ContentType_initialize();
  return [IOSObjectArray arrayWithObjects:NetI2pCryptoSU3File_ContentType_values_ count:6 type:NetI2pCryptoSU3File_ContentType_class_()];
}

NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_valueOfWithNSString_(NSString *name) {
  NetI2pCryptoSU3File_ContentType_initialize();
  for (int i = 0; i < 6; i++) {
    NetI2pCryptoSU3File_ContentType *e = NetI2pCryptoSU3File_ContentType_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

NetI2pCryptoSU3File_ContentType *NetI2pCryptoSU3File_ContentType_fromOrdinal(NSUInteger ordinal) {
  NetI2pCryptoSU3File_ContentType_initialize();
  if (ordinal >= 6) {
    return nil;
  }
  return NetI2pCryptoSU3File_ContentType_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoSU3File_ContentType)
