//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/eddsa/EdDSAPrivateKey.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"
#include "java/security/spec/InvalidKeySpecException.h"
#include "java/security/spec/PKCS8EncodedKeySpec.h"
#include "java/util/Arrays.h"
#include "net/i2p/crypto/eddsa/EdDSAKey.h"
#include "net/i2p/crypto/eddsa/EdDSAPrivateKey.h"
#include "net/i2p/crypto/eddsa/math/GroupElement.h"
#include "net/i2p/crypto/eddsa/spec/EdDSANamedCurveSpec.h"
#include "net/i2p/crypto/eddsa/spec/EdDSANamedCurveTable.h"
#include "net/i2p/crypto/eddsa/spec/EdDSAParameterSpec.h"
#include "net/i2p/crypto/eddsa/spec/EdDSAPrivateKeySpec.h"

@interface NetI2pCryptoEddsaEdDSAPrivateKey () {
 @public
  IOSByteArray *seed_;
  IOSByteArray *h_;
  IOSByteArray *a_;
  NetI2pCryptoEddsaMathGroupElement *A_;
  IOSByteArray *Abyte_;
  NetI2pCryptoEddsaSpecEdDSAParameterSpec *edDsaSpec_;
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)d;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, seed_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, h_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, a_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, A_, NetI2pCryptoEddsaMathGroupElement *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, Abyte_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPrivateKey, edDsaSpec_, NetI2pCryptoEddsaSpecEdDSAParameterSpec *)

inline jlong NetI2pCryptoEddsaEdDSAPrivateKey_get_serialVersionUID(void);
#define NetI2pCryptoEddsaEdDSAPrivateKey_serialVersionUID 23495873459878957LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPrivateKey, serialVersionUID, jlong)

inline jint NetI2pCryptoEddsaEdDSAPrivateKey_get_OID_OLD(void);
#define NetI2pCryptoEddsaEdDSAPrivateKey_OID_OLD 100
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPrivateKey, OID_OLD, jint)

inline jint NetI2pCryptoEddsaEdDSAPrivateKey_get_OID_ED25519(void);
#define NetI2pCryptoEddsaEdDSAPrivateKey_OID_ED25519 112
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPrivateKey, OID_ED25519, jint)

inline jint NetI2pCryptoEddsaEdDSAPrivateKey_get_OID_BYTE(void);
#define NetI2pCryptoEddsaEdDSAPrivateKey_OID_BYTE 11
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPrivateKey, OID_BYTE, jint)

inline jint NetI2pCryptoEddsaEdDSAPrivateKey_get_IDLEN_BYTE(void);
#define NetI2pCryptoEddsaEdDSAPrivateKey_IDLEN_BYTE 6
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPrivateKey, IDLEN_BYTE, jint)

__attribute__((unused)) static IOSByteArray *NetI2pCryptoEddsaEdDSAPrivateKey_decodeWithByteArray_(IOSByteArray *d);

@implementation NetI2pCryptoEddsaEdDSAPrivateKey

- (instancetype)initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec:(NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec *)spec {
  NetI2pCryptoEddsaEdDSAPrivateKey_initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_(self, spec);
  return self;
}

- (instancetype)initWithJavaSecuritySpecPKCS8EncodedKeySpec:(JavaSecuritySpecPKCS8EncodedKeySpec *)spec {
  NetI2pCryptoEddsaEdDSAPrivateKey_initWithJavaSecuritySpecPKCS8EncodedKeySpec_(self, spec);
  return self;
}

- (NSString *)getAlgorithm {
  return NetI2pCryptoEddsaEdDSAKey_KEY_ALGORITHM;
}

- (NSString *)getFormat {
  return @"PKCS#8";
}

- (IOSByteArray *)getEncoded {
  if (![((NetI2pCryptoEddsaSpecEdDSAParameterSpec *) nil_chk(edDsaSpec_)) isEqual:JreLoadStatic(NetI2pCryptoEddsaSpecEdDSANamedCurveTable, ED_25519_CURVE_SPEC)]) return nil;
  if (seed_ == nil) return nil;
  jint totlen = 16 + seed_->size_;
  IOSByteArray *rv = [IOSByteArray arrayWithLength:totlen];
  jint idx = 0;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x30;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) (totlen - 2);
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x02;
  *IOSByteArray_GetRef(rv, idx++) = 1;
  *IOSByteArray_GetRef(rv, idx++) = 0;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x30;
  *IOSByteArray_GetRef(rv, idx++) = 5;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x06;
  *IOSByteArray_GetRef(rv, idx++) = 3;
  *IOSByteArray_GetRef(rv, idx++) = (1 * 40) + 3;
  *IOSByteArray_GetRef(rv, idx++) = 101;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) NetI2pCryptoEddsaEdDSAPrivateKey_OID_ED25519;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x04;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) (2 + seed_->size_);
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x04;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) seed_->size_;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(seed_, 0, rv, idx, seed_->size_);
  return rv;
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)d {
  return NetI2pCryptoEddsaEdDSAPrivateKey_decodeWithByteArray_(d);
}

- (NetI2pCryptoEddsaSpecEdDSAParameterSpec *)getParams {
  return edDsaSpec_;
}

- (IOSByteArray *)getSeed {
  return seed_;
}

- (IOSByteArray *)getH {
  return h_;
}

- (IOSByteArray *)geta {
  return a_;
}

- (NetI2pCryptoEddsaMathGroupElement *)getA {
  return A_;
}

- (IOSByteArray *)getAbyte {
  return Abyte_;
}

- (NSUInteger)hash {
  return JavaUtilArrays_hashCodeWithByteArray_(seed_);
}

- (jboolean)isEqual:(id)o {
  if (o == self) return true;
  if (!([o isKindOfClass:[NetI2pCryptoEddsaEdDSAPrivateKey class]])) return false;
  NetI2pCryptoEddsaEdDSAPrivateKey *pk = (NetI2pCryptoEddsaEdDSAPrivateKey *) cast_chk(o, [NetI2pCryptoEddsaEdDSAPrivateKey class]);
  return JavaUtilArrays_equalsWithByteArray_withByteArray_(seed_, [((NetI2pCryptoEddsaEdDSAPrivateKey *) nil_chk(pk)) getSeed]) && [((NetI2pCryptoEddsaSpecEdDSAParameterSpec *) nil_chk(edDsaSpec_)) isEqual:[pk getParams]];
}

- (void)dealloc {
  RELEASE_(seed_);
  RELEASE_(h_);
  RELEASE_(a_);
  RELEASE_(A_);
  RELEASE_(Abyte_);
  RELEASE_(edDsaSpec_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, 2, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 3, 4, 2, -1, -1, -1 },
    { NULL, "LNetI2pCryptoEddsaSpecEdDSAParameterSpec;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoEddsaMathGroupElement;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 7, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec:);
  methods[1].selector = @selector(initWithJavaSecuritySpecPKCS8EncodedKeySpec:);
  methods[2].selector = @selector(getAlgorithm);
  methods[3].selector = @selector(getFormat);
  methods[4].selector = @selector(getEncoded);
  methods[5].selector = @selector(decodeWithByteArray:);
  methods[6].selector = @selector(getParams);
  methods[7].selector = @selector(getSeed);
  methods[8].selector = @selector(getH);
  methods[9].selector = @selector(geta);
  methods[10].selector = @selector(getA);
  methods[11].selector = @selector(getAbyte);
  methods[12].selector = @selector(hash);
  methods[13].selector = @selector(isEqual:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = NetI2pCryptoEddsaEdDSAPrivateKey_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "seed_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "h_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "a_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "A_", "LNetI2pCryptoEddsaMathGroupElement;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "Abyte_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "edDsaSpec_", "LNetI2pCryptoEddsaSpecEdDSAParameterSpec;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "OID_OLD", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPrivateKey_OID_OLD, 0x1a, -1, -1, -1, -1 },
    { "OID_ED25519", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPrivateKey_OID_ED25519, 0x1a, -1, -1, -1, -1 },
    { "OID_BYTE", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPrivateKey_OID_BYTE, 0x1a, -1, -1, -1, -1 },
    { "IDLEN_BYTE", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPrivateKey_IDLEN_BYTE, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec;", "LJavaSecuritySpecPKCS8EncodedKeySpec;", "LJavaSecuritySpecInvalidKeySpecException;", "decode", "[B", "hashCode", "equals", "LNSObject;" };
  static const J2ObjcClassInfo _NetI2pCryptoEddsaEdDSAPrivateKey = { "EdDSAPrivateKey", "net.i2p.crypto.eddsa", ptrTable, methods, fields, 7, 0x1, 14, 11, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoEddsaEdDSAPrivateKey;
}

@end

void NetI2pCryptoEddsaEdDSAPrivateKey_initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_(NetI2pCryptoEddsaEdDSAPrivateKey *self, NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec *spec) {
  NSObject_init(self);
  JreStrongAssign(&self->seed_, [((NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec *) nil_chk(spec)) getSeed]);
  JreStrongAssign(&self->h_, [spec getH]);
  JreStrongAssign(&self->a_, [spec geta]);
  JreStrongAssign(&self->A_, [spec getA]);
  JreStrongAssign(&self->Abyte_, [((NetI2pCryptoEddsaMathGroupElement *) nil_chk(self->A_)) toByteArray]);
  JreStrongAssign(&self->edDsaSpec_, [spec getParams]);
}

NetI2pCryptoEddsaEdDSAPrivateKey *new_NetI2pCryptoEddsaEdDSAPrivateKey_initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_(NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec *spec) {
  J2OBJC_NEW_IMPL(NetI2pCryptoEddsaEdDSAPrivateKey, initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_, spec)
}

NetI2pCryptoEddsaEdDSAPrivateKey *create_NetI2pCryptoEddsaEdDSAPrivateKey_initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_(NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec *spec) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoEddsaEdDSAPrivateKey, initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_, spec)
}

void NetI2pCryptoEddsaEdDSAPrivateKey_initWithJavaSecuritySpecPKCS8EncodedKeySpec_(NetI2pCryptoEddsaEdDSAPrivateKey *self, JavaSecuritySpecPKCS8EncodedKeySpec *spec) {
  NetI2pCryptoEddsaEdDSAPrivateKey_initWithNetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_(self, create_NetI2pCryptoEddsaSpecEdDSAPrivateKeySpec_initWithByteArray_withNetI2pCryptoEddsaSpecEdDSAParameterSpec_(NetI2pCryptoEddsaEdDSAPrivateKey_decodeWithByteArray_([((JavaSecuritySpecPKCS8EncodedKeySpec *) nil_chk(spec)) getEncoded]), JreLoadStatic(NetI2pCryptoEddsaSpecEdDSANamedCurveTable, ED_25519_CURVE_SPEC)));
}

NetI2pCryptoEddsaEdDSAPrivateKey *new_NetI2pCryptoEddsaEdDSAPrivateKey_initWithJavaSecuritySpecPKCS8EncodedKeySpec_(JavaSecuritySpecPKCS8EncodedKeySpec *spec) {
  J2OBJC_NEW_IMPL(NetI2pCryptoEddsaEdDSAPrivateKey, initWithJavaSecuritySpecPKCS8EncodedKeySpec_, spec)
}

NetI2pCryptoEddsaEdDSAPrivateKey *create_NetI2pCryptoEddsaEdDSAPrivateKey_initWithJavaSecuritySpecPKCS8EncodedKeySpec_(JavaSecuritySpecPKCS8EncodedKeySpec *spec) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoEddsaEdDSAPrivateKey, initWithJavaSecuritySpecPKCS8EncodedKeySpec_, spec)
}

IOSByteArray *NetI2pCryptoEddsaEdDSAPrivateKey_decodeWithByteArray_(IOSByteArray *d) {
  NetI2pCryptoEddsaEdDSAPrivateKey_initialize();
  @try {
    jint totlen = 48;
    jint idlen = 5;
    jint doid = IOSByteArray_Get(nil_chk(d), NetI2pCryptoEddsaEdDSAPrivateKey_OID_BYTE);
    if (doid == NetI2pCryptoEddsaEdDSAPrivateKey_OID_OLD) {
      totlen = 49;
      idlen = 8;
    }
    else if (doid == NetI2pCryptoEddsaEdDSAPrivateKey_OID_ED25519) {
      if (IOSByteArray_Get(d, NetI2pCryptoEddsaEdDSAPrivateKey_IDLEN_BYTE) == 7) {
        totlen = 50;
        idlen = 7;
      }
    }
    else {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    if (d->size_ != totlen) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"invalid key spec length");
    }
    jint idx = 0;
    if (IOSByteArray_Get(d, idx++) != (jint) 0x30 || IOSByteArray_Get(d, idx++) != (totlen - 2) || IOSByteArray_Get(d, idx++) != (jint) 0x02 || IOSByteArray_Get(d, idx++) != 1 || IOSByteArray_Get(d, idx++) != 0 || IOSByteArray_Get(d, idx++) != (jint) 0x30 || IOSByteArray_Get(d, idx++) != idlen || IOSByteArray_Get(d, idx++) != (jint) 0x06 || IOSByteArray_Get(d, idx++) != 3 || IOSByteArray_Get(d, idx++) != (1 * 40) + 3 || IOSByteArray_Get(d, idx++) != 101) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    idx++;
    if (doid == NetI2pCryptoEddsaEdDSAPrivateKey_OID_OLD) {
      if (IOSByteArray_Get(d, idx++) != (jint) 0x0a || IOSByteArray_Get(d, idx++) != 1 || IOSByteArray_Get(d, idx++) != 1) {
        @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
      }
    }
    else {
      if (idlen == 7) {
        if (IOSByteArray_Get(d, idx++) != (jint) 0x05 || IOSByteArray_Get(d, idx++) != 0) {
          @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
        }
      }
      if (IOSByteArray_Get(d, idx++) != (jint) 0x04 || IOSByteArray_Get(d, idx++) != 34) {
        @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
      }
    }
    if (IOSByteArray_Get(d, idx++) != (jint) 0x04 || IOSByteArray_Get(d, idx++) != 32) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    IOSByteArray *rv = [IOSByteArray arrayWithLength:32];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(d, idx, rv, 0, 32);
    return rv;
  }
  @catch (JavaLangIndexOutOfBoundsException *ioobe) {
    @throw create_JavaSecuritySpecInvalidKeySpecException_initWithJavaLangThrowable_(ioobe);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoEddsaEdDSAPrivateKey)
