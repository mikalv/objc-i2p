//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/eddsa/EdDSAPublicKey.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"
#include "java/security/spec/InvalidKeySpecException.h"
#include "java/security/spec/X509EncodedKeySpec.h"
#include "java/util/Arrays.h"
#include "net/i2p/crypto/eddsa/EdDSAKey.h"
#include "net/i2p/crypto/eddsa/EdDSAPublicKey.h"
#include "net/i2p/crypto/eddsa/math/GroupElement.h"
#include "net/i2p/crypto/eddsa/spec/EdDSANamedCurveSpec.h"
#include "net/i2p/crypto/eddsa/spec/EdDSANamedCurveTable.h"
#include "net/i2p/crypto/eddsa/spec/EdDSAParameterSpec.h"
#include "net/i2p/crypto/eddsa/spec/EdDSAPublicKeySpec.h"

@interface NetI2pCryptoEddsaEdDSAPublicKey () {
 @public
  NetI2pCryptoEddsaMathGroupElement *A_;
  NetI2pCryptoEddsaMathGroupElement *Aneg_;
  IOSByteArray *Abyte_;
  NetI2pCryptoEddsaSpecEdDSAParameterSpec *edDsaSpec_;
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)d;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPublicKey, A_, NetI2pCryptoEddsaMathGroupElement *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPublicKey, Aneg_, NetI2pCryptoEddsaMathGroupElement *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPublicKey, Abyte_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pCryptoEddsaEdDSAPublicKey, edDsaSpec_, NetI2pCryptoEddsaSpecEdDSAParameterSpec *)

inline jlong NetI2pCryptoEddsaEdDSAPublicKey_get_serialVersionUID(void);
#define NetI2pCryptoEddsaEdDSAPublicKey_serialVersionUID 9837459837498475LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPublicKey, serialVersionUID, jlong)

inline jint NetI2pCryptoEddsaEdDSAPublicKey_get_OID_OLD(void);
#define NetI2pCryptoEddsaEdDSAPublicKey_OID_OLD 100
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPublicKey, OID_OLD, jint)

inline jint NetI2pCryptoEddsaEdDSAPublicKey_get_OID_ED25519(void);
#define NetI2pCryptoEddsaEdDSAPublicKey_OID_ED25519 112
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPublicKey, OID_ED25519, jint)

inline jint NetI2pCryptoEddsaEdDSAPublicKey_get_OID_BYTE(void);
#define NetI2pCryptoEddsaEdDSAPublicKey_OID_BYTE 8
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPublicKey, OID_BYTE, jint)

inline jint NetI2pCryptoEddsaEdDSAPublicKey_get_IDLEN_BYTE(void);
#define NetI2pCryptoEddsaEdDSAPublicKey_IDLEN_BYTE 3
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoEddsaEdDSAPublicKey, IDLEN_BYTE, jint)

__attribute__((unused)) static IOSByteArray *NetI2pCryptoEddsaEdDSAPublicKey_decodeWithByteArray_(IOSByteArray *d);

@implementation NetI2pCryptoEddsaEdDSAPublicKey

- (instancetype)initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec:(NetI2pCryptoEddsaSpecEdDSAPublicKeySpec *)spec {
  NetI2pCryptoEddsaEdDSAPublicKey_initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_(self, spec);
  return self;
}

- (instancetype)initWithJavaSecuritySpecX509EncodedKeySpec:(JavaSecuritySpecX509EncodedKeySpec *)spec {
  NetI2pCryptoEddsaEdDSAPublicKey_initWithJavaSecuritySpecX509EncodedKeySpec_(self, spec);
  return self;
}

- (NSString *)getAlgorithm {
  return NetI2pCryptoEddsaEdDSAKey_KEY_ALGORITHM;
}

- (NSString *)getFormat {
  return @"X.509";
}

- (IOSByteArray *)getEncoded {
  if (![((NetI2pCryptoEddsaSpecEdDSAParameterSpec *) nil_chk(edDsaSpec_)) isEqual:JreLoadStatic(NetI2pCryptoEddsaSpecEdDSANamedCurveTable, ED_25519_CURVE_SPEC)]) return nil;
  jint totlen = 12 + ((IOSByteArray *) nil_chk(Abyte_))->size_;
  IOSByteArray *rv = [IOSByteArray arrayWithLength:totlen];
  jint idx = 0;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x30;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) (totlen - 2);
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x30;
  *IOSByteArray_GetRef(rv, idx++) = 5;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x06;
  *IOSByteArray_GetRef(rv, idx++) = 3;
  *IOSByteArray_GetRef(rv, idx++) = (1 * 40) + 3;
  *IOSByteArray_GetRef(rv, idx++) = 101;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) NetI2pCryptoEddsaEdDSAPublicKey_OID_ED25519;
  *IOSByteArray_GetRef(rv, idx++) = (jint) 0x03;
  *IOSByteArray_GetRef(rv, idx++) = (jbyte) (1 + Abyte_->size_);
  *IOSByteArray_GetRef(rv, idx++) = 0;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(Abyte_, 0, rv, idx, Abyte_->size_);
  return rv;
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)d {
  return NetI2pCryptoEddsaEdDSAPublicKey_decodeWithByteArray_(d);
}

- (NetI2pCryptoEddsaSpecEdDSAParameterSpec *)getParams {
  return edDsaSpec_;
}

- (NetI2pCryptoEddsaMathGroupElement *)getA {
  return A_;
}

- (NetI2pCryptoEddsaMathGroupElement *)getNegativeA {
  NetI2pCryptoEddsaMathGroupElement *ourAneg = Aneg_;
  if (ourAneg == nil) {
    ourAneg = [((NetI2pCryptoEddsaMathGroupElement *) nil_chk(A_)) negate];
    JreStrongAssign(&Aneg_, ourAneg);
  }
  return ourAneg;
}

- (IOSByteArray *)getAbyte {
  return Abyte_;
}

- (NSUInteger)hash {
  return JavaUtilArrays_hashCodeWithByteArray_(Abyte_);
}

- (jboolean)isEqual:(id)o {
  if (o == self) return true;
  if (!([o isKindOfClass:[NetI2pCryptoEddsaEdDSAPublicKey class]])) return false;
  NetI2pCryptoEddsaEdDSAPublicKey *pk = (NetI2pCryptoEddsaEdDSAPublicKey *) cast_chk(o, [NetI2pCryptoEddsaEdDSAPublicKey class]);
  return JavaUtilArrays_equalsWithByteArray_withByteArray_(Abyte_, [((NetI2pCryptoEddsaEdDSAPublicKey *) nil_chk(pk)) getAbyte]) && [((NetI2pCryptoEddsaSpecEdDSAParameterSpec *) nil_chk(edDsaSpec_)) isEqual:[pk getParams]];
}

- (void)dealloc {
  RELEASE_(A_);
  RELEASE_(Aneg_);
  RELEASE_(Abyte_);
  RELEASE_(edDsaSpec_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, 2, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 3, 4, 2, -1, -1, -1 },
    { NULL, "LNetI2pCryptoEddsaSpecEdDSAParameterSpec;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoEddsaMathGroupElement;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoEddsaMathGroupElement;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 7, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec:);
  methods[1].selector = @selector(initWithJavaSecuritySpecX509EncodedKeySpec:);
  methods[2].selector = @selector(getAlgorithm);
  methods[3].selector = @selector(getFormat);
  methods[4].selector = @selector(getEncoded);
  methods[5].selector = @selector(decodeWithByteArray:);
  methods[6].selector = @selector(getParams);
  methods[7].selector = @selector(getA);
  methods[8].selector = @selector(getNegativeA);
  methods[9].selector = @selector(getAbyte);
  methods[10].selector = @selector(hash);
  methods[11].selector = @selector(isEqual:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = NetI2pCryptoEddsaEdDSAPublicKey_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "A_", "LNetI2pCryptoEddsaMathGroupElement;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "Aneg_", "LNetI2pCryptoEddsaMathGroupElement;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "Abyte_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "edDsaSpec_", "LNetI2pCryptoEddsaSpecEdDSAParameterSpec;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "OID_OLD", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPublicKey_OID_OLD, 0x1a, -1, -1, -1, -1 },
    { "OID_ED25519", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPublicKey_OID_ED25519, 0x1a, -1, -1, -1, -1 },
    { "OID_BYTE", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPublicKey_OID_BYTE, 0x1a, -1, -1, -1, -1 },
    { "IDLEN_BYTE", "I", .constantValue.asInt = NetI2pCryptoEddsaEdDSAPublicKey_IDLEN_BYTE, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pCryptoEddsaSpecEdDSAPublicKeySpec;", "LJavaSecuritySpecX509EncodedKeySpec;", "LJavaSecuritySpecInvalidKeySpecException;", "decode", "[B", "hashCode", "equals", "LNSObject;" };
  static const J2ObjcClassInfo _NetI2pCryptoEddsaEdDSAPublicKey = { "EdDSAPublicKey", "net.i2p.crypto.eddsa", ptrTable, methods, fields, 7, 0x1, 12, 9, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoEddsaEdDSAPublicKey;
}

@end

void NetI2pCryptoEddsaEdDSAPublicKey_initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_(NetI2pCryptoEddsaEdDSAPublicKey *self, NetI2pCryptoEddsaSpecEdDSAPublicKeySpec *spec) {
  NSObject_init(self);
  JreStrongAssign(&self->A_, [((NetI2pCryptoEddsaSpecEdDSAPublicKeySpec *) nil_chk(spec)) getA]);
  JreStrongAssign(&self->Abyte_, [((NetI2pCryptoEddsaMathGroupElement *) nil_chk(self->A_)) toByteArray]);
  JreStrongAssign(&self->edDsaSpec_, [spec getParams]);
}

NetI2pCryptoEddsaEdDSAPublicKey *new_NetI2pCryptoEddsaEdDSAPublicKey_initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_(NetI2pCryptoEddsaSpecEdDSAPublicKeySpec *spec) {
  J2OBJC_NEW_IMPL(NetI2pCryptoEddsaEdDSAPublicKey, initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_, spec)
}

NetI2pCryptoEddsaEdDSAPublicKey *create_NetI2pCryptoEddsaEdDSAPublicKey_initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_(NetI2pCryptoEddsaSpecEdDSAPublicKeySpec *spec) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoEddsaEdDSAPublicKey, initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_, spec)
}

void NetI2pCryptoEddsaEdDSAPublicKey_initWithJavaSecuritySpecX509EncodedKeySpec_(NetI2pCryptoEddsaEdDSAPublicKey *self, JavaSecuritySpecX509EncodedKeySpec *spec) {
  NetI2pCryptoEddsaEdDSAPublicKey_initWithNetI2pCryptoEddsaSpecEdDSAPublicKeySpec_(self, create_NetI2pCryptoEddsaSpecEdDSAPublicKeySpec_initWithByteArray_withNetI2pCryptoEddsaSpecEdDSAParameterSpec_(NetI2pCryptoEddsaEdDSAPublicKey_decodeWithByteArray_([((JavaSecuritySpecX509EncodedKeySpec *) nil_chk(spec)) getEncoded]), JreLoadStatic(NetI2pCryptoEddsaSpecEdDSANamedCurveTable, ED_25519_CURVE_SPEC)));
}

NetI2pCryptoEddsaEdDSAPublicKey *new_NetI2pCryptoEddsaEdDSAPublicKey_initWithJavaSecuritySpecX509EncodedKeySpec_(JavaSecuritySpecX509EncodedKeySpec *spec) {
  J2OBJC_NEW_IMPL(NetI2pCryptoEddsaEdDSAPublicKey, initWithJavaSecuritySpecX509EncodedKeySpec_, spec)
}

NetI2pCryptoEddsaEdDSAPublicKey *create_NetI2pCryptoEddsaEdDSAPublicKey_initWithJavaSecuritySpecX509EncodedKeySpec_(JavaSecuritySpecX509EncodedKeySpec *spec) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoEddsaEdDSAPublicKey, initWithJavaSecuritySpecX509EncodedKeySpec_, spec)
}

IOSByteArray *NetI2pCryptoEddsaEdDSAPublicKey_decodeWithByteArray_(IOSByteArray *d) {
  NetI2pCryptoEddsaEdDSAPublicKey_initialize();
  @try {
    jint totlen = 44;
    jint idlen = 5;
    jint doid = IOSByteArray_Get(nil_chk(d), NetI2pCryptoEddsaEdDSAPublicKey_OID_BYTE);
    if (doid == NetI2pCryptoEddsaEdDSAPublicKey_OID_OLD) {
      totlen = 47;
      idlen = 8;
    }
    else if (doid == NetI2pCryptoEddsaEdDSAPublicKey_OID_ED25519) {
      if (IOSByteArray_Get(d, NetI2pCryptoEddsaEdDSAPublicKey_IDLEN_BYTE) == 7) {
        totlen = 46;
        idlen = 7;
      }
    }
    else {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    if (d->size_ != totlen) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"invalid key spec length");
    }
    jint idx = 0;
    if (IOSByteArray_Get(d, idx++) != (jint) 0x30 || IOSByteArray_Get(d, idx++) != (totlen - 2) || IOSByteArray_Get(d, idx++) != (jint) 0x30 || IOSByteArray_Get(d, idx++) != idlen || IOSByteArray_Get(d, idx++) != (jint) 0x06 || IOSByteArray_Get(d, idx++) != 3 || IOSByteArray_Get(d, idx++) != (1 * 40) + 3 || IOSByteArray_Get(d, idx++) != 101) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    idx++;
    if (doid == NetI2pCryptoEddsaEdDSAPublicKey_OID_OLD) {
      if (IOSByteArray_Get(d, idx++) != (jint) 0x0a || IOSByteArray_Get(d, idx++) != 1 || IOSByteArray_Get(d, idx++) != 1) {
        @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
      }
    }
    else {
      if (idlen == 7) {
        if (IOSByteArray_Get(d, idx++) != (jint) 0x05 || IOSByteArray_Get(d, idx++) != 0) {
          @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
        }
      }
    }
    if (IOSByteArray_Get(d, idx++) != (jint) 0x03 || IOSByteArray_Get(d, idx++) != 33 || IOSByteArray_Get(d, idx++) != 0) {
      @throw create_JavaSecuritySpecInvalidKeySpecException_initWithNSString_(@"unsupported key spec");
    }
    IOSByteArray *rv = [IOSByteArray arrayWithLength:32];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(d, idx, rv, 0, 32);
    return rv;
  }
  @catch (JavaLangIndexOutOfBoundsException *ioobe) {
    @throw create_JavaSecuritySpecInvalidKeySpecException_initWithJavaLangThrowable_(ioobe);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoEddsaEdDSAPublicKey)
