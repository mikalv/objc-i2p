//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/ElGamalAESEngine.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/AESEngine.h"
#include "net/i2p/crypto/ElGamalAESEngine.h"
#include "net/i2p/crypto/ElGamalEngine.h"
#include "net/i2p/crypto/EntropyHarvester.h"
#include "net/i2p/crypto/SHA256Generator.h"
#include "net/i2p/crypto/SessionKeyManager.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/PrivateKey.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/data/SessionTag.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"
#include "net/i2p/util/SimpleByteCache.h"

@interface NetI2pCryptoElGamalAESEngine () {
 @public
  NetI2pUtilLog *_log_;
  NetI2pI2PAppContext *_context_;
}

- (IOSByteArray *)decryptNewSessionWithByteArray:(IOSByteArray *)data
                        withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey
                                 withJavaUtilSet:(id<JavaUtilSet>)foundTags
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)usedKey
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)foundKey;

- (IOSByteArray *)decryptExistingSessionWithByteArray:(IOSByteArray *)data
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                             withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey
                                      withJavaUtilSet:(id<JavaUtilSet>)foundTags
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)usedKey
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)foundKey;

- (IOSByteArray *)encryptNewSessionWithByteArray:(IOSByteArray *)data
                         withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                        withLong:(jlong)paddedSize;

- (IOSByteArray *)encryptExistingSessionWithByteArray:(IOSByteArray *)data
                              withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                      withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                             withNetI2pDataSessionTag:(NetI2pDataSessionTag *)currentTag
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                             withLong:(jlong)paddedSize;

- (IOSByteArray *)halfHashWithByteArray:(IOSByteArray *)preIV;

- (IOSByteArray *)encryptAESBlockWithByteArray:(IOSByteArray *)data
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withByteArray:(IOSByteArray *)iv
                               withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                      withLong:(jlong)paddedSize
                                       withInt:(jint)prefixBytes;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoElGamalAESEngine, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pCryptoElGamalAESEngine, _context_, NetI2pI2PAppContext *)

inline jint NetI2pCryptoElGamalAESEngine_get_MIN_ENCRYPTED_SIZE(void);
#define NetI2pCryptoElGamalAESEngine_MIN_ENCRYPTED_SIZE 80
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoElGamalAESEngine, MIN_ENCRYPTED_SIZE, jint)

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_decryptNewSessionWithByteArray_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPrivateKey *targetPrivateKey, id<JavaUtilSet> foundTags, NetI2pDataSessionKey *usedKey, NetI2pDataSessionKey *foundKey);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_decryptExistingSessionWithByteArray_withNetI2pDataSessionKey_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, NetI2pDataPrivateKey *targetPrivateKey, id<JavaUtilSet> foundTags, NetI2pDataSessionKey *usedKey, NetI2pDataSessionKey *foundKey);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptNewSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPublicKey *target, NetI2pDataSessionKey *key, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptExistingSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionTag_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPublicKey *target, NetI2pDataSessionKey *key, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionTag *currentTag, NetI2pDataSessionKey *newKey, jlong paddedSize);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *preIV);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, IOSByteArray *iv, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize);

__attribute__((unused)) static IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_withInt_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, IOSByteArray *iv, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize, jint prefixBytes);

@implementation NetI2pCryptoElGamalAESEngine

+ (jint)MAX_TAGS_RECEIVED {
  return NetI2pCryptoElGamalAESEngine_MAX_TAGS_RECEIVED;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)ctx {
  NetI2pCryptoElGamalAESEngine_initWithNetI2pI2PAppContext_(self, ctx);
  return self;
}

- (IOSByteArray *)decryptWithByteArray:(IOSByteArray *)data
              withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey {
  return [self decryptWithByteArray:data withNetI2pDataPrivateKey:targetPrivateKey withNetI2pCryptoSessionKeyManager:[((NetI2pI2PAppContext *) nil_chk(_context_)) sessionKeyManager]];
}

- (IOSByteArray *)decryptWithByteArray:(IOSByteArray *)data
              withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey
     withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)keyManager {
  if (data == nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Null data being decrypted?"];
    return nil;
  }
  else if (data->size_ < NetI2pCryptoElGamalAESEngine_MIN_ENCRYPTED_SIZE) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$I$IC", @"Data is less than the minimum size (", data->size_, @" < ", NetI2pCryptoElGamalAESEngine_MIN_ENCRYPTED_SIZE, ')')];
    return nil;
  }
  IOSByteArray *tag = [IOSByteArray arrayWithLength:32];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, tag, 0, 32);
  NetI2pDataSessionTag *st = create_NetI2pDataSessionTag_initWithByteArray_(tag);
  NetI2pDataSessionKey *key = [((NetI2pCryptoSessionKeyManager *) nil_chk(keyManager)) consumeTagWithNetI2pDataSessionTag:st];
  NetI2pDataSessionKey *foundKey = create_NetI2pDataSessionKey_init();
  NetI2pDataSessionKey *usedKey = create_NetI2pDataSessionKey_init();
  id<JavaUtilSet> foundTags = create_JavaUtilHashSet_init();
  IOSByteArray *decrypted = nil;
  jboolean wasExisting = false;
  if (key != nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$$$$I$", @"Decrypting existing session encrypted with tag: ", [st description], @": key: ", [key toBase64], @": ", data->size_, @" bytes ")];
    decrypted = NetI2pCryptoElGamalAESEngine_decryptExistingSessionWithByteArray_withNetI2pDataSessionKey_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(self, data, key, targetPrivateKey, foundTags, usedKey, foundKey);
    if (decrypted != nil) {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.decryptExistingSession"];
      if ((![foundTags isEmpty]) && ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG])) [_log_ debugWithNSString:JreStrcat("$@$@", @"ElG/AES decrypt success with ", st, @": found tags: ", foundTags)];
      wasExisting = true;
    }
    else {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.decryptFailed"];
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) {
        [_log_ warnWithNSString:JreStrcat("$@$", @"ElG decrypt fail: known tag [", st, @"], failed decrypt")];
      }
    }
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@", @"Key is NOT known for tag ", st)];
    decrypted = NetI2pCryptoElGamalAESEngine_decryptNewSessionWithByteArray_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(self, data, targetPrivateKey, foundTags, usedKey, foundKey);
    if (decrypted != nil) {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.decryptNewSession"];
      if ((![foundTags isEmpty]) && ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG])) [_log_ debugWithNSString:JreStrcat("$@", @"ElG decrypt success: found tags: ", foundTags)];
    }
    else {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.decryptFailed"];
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@", @"ElG decrypt fail: unknown tag: ", st)];
    }
  }
  if ((key == nil) && (decrypted == nil)) {
  }
  if (![foundTags isEmpty]) {
    if ([foundKey getData] != nil) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$$@$Z", @"Found key: ", [foundKey toBase64], @" tags: ", foundTags, @" wasExisting? ", wasExisting)];
      [keyManager tagsReceivedWithNetI2pDataSessionKey:foundKey withJavaUtilSet:foundTags];
    }
    else if ([usedKey getData] != nil) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$$@$Z", @"Used key: ", [usedKey toBase64], @" tags: ", foundTags, @" wasExisting? ", wasExisting)];
      [keyManager tagsReceivedWithNetI2pDataSessionKey:usedKey withJavaUtilSet:foundTags];
    }
  }
  return decrypted;
}

- (IOSByteArray *)decryptNewSessionWithByteArray:(IOSByteArray *)data
                        withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey
                                 withJavaUtilSet:(id<JavaUtilSet>)foundTags
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)usedKey
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)foundKey {
  return NetI2pCryptoElGamalAESEngine_decryptNewSessionWithByteArray_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(self, data, targetPrivateKey, foundTags, usedKey, foundKey);
}

- (IOSByteArray *)decryptExistingSessionWithByteArray:(IOSByteArray *)data
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                             withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)targetPrivateKey
                                      withJavaUtilSet:(id<JavaUtilSet>)foundTags
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)usedKey
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)foundKey {
  return NetI2pCryptoElGamalAESEngine_decryptExistingSessionWithByteArray_withNetI2pDataSessionKey_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(self, data, key, targetPrivateKey, foundTags, usedKey, foundKey);
}

- (IOSByteArray *)decryptAESBlockWithByteArray:(IOSByteArray *)encrypted
                                       withInt:(jint)offset
                                       withInt:(jint)encryptedLen
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withByteArray:(IOSByteArray *)iv
                                 withByteArray:(IOSByteArray *)sentTag
                               withJavaUtilSet:(id<JavaUtilSet>)foundTags
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)foundKey {
  IOSByteArray *decrypted = [IOSByteArray arrayWithLength:encryptedLen];
  [((NetI2pCryptoAESEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) aes])) decryptWithByteArray:encrypted withInt:offset withByteArray:decrypted withInt:0 withNetI2pDataSessionKey:key withByteArray:iv withInt:encryptedLen];
  @try {
    NetI2pDataSessionKey *newKey = nil;
    id<JavaUtilList> tags = nil;
    jint cur = 0;
    jlong numTags = NetI2pDataDataHelper_fromLongWithByteArray_withInt_withInt_(decrypted, cur, 2);
    if ((numTags < 0) || (numTags > NetI2pCryptoElGamalAESEngine_MAX_TAGS_RECEIVED)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid number of session tags");
    if (numTags > 0) tags = create_JavaUtilArrayList_initWithInt_((jint) numTags);
    cur += 2;
    if (numTags * NetI2pDataSessionTag_BYTE_LENGTH > decrypted->size_ - 2) {
      @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J$I", @"# tags: ", numTags, @" is too many for ", (decrypted->size_ - 2)));
    }
    for (jint i = 0; i < numTags; i++) {
      IOSByteArray *tag = [IOSByteArray arrayWithLength:NetI2pDataSessionTag_BYTE_LENGTH];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(decrypted, cur, tag, 0, NetI2pDataSessionTag_BYTE_LENGTH);
      cur += NetI2pDataSessionTag_BYTE_LENGTH;
      [((id<JavaUtilList>) nil_chk(tags)) addWithId:create_NetI2pDataSessionTag_initWithByteArray_(tag)];
    }
    jlong len = NetI2pDataDataHelper_fromLongWithByteArray_withInt_withInt_(decrypted, cur, 4);
    cur += 4;
    if ((len < 0) || (len > decrypted->size_ - cur - NetI2pDataHash_HASH_LENGTH - 1)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J$IC", @"Invalid size of payload (", len, @", remaining ", (decrypted->size_ - cur), ')'));
    jint hashIndex = cur;
    cur += NetI2pDataHash_HASH_LENGTH;
    jbyte flag = IOSByteArray_Get(decrypted, cur++);
    if (flag == (jint) 0x01) {
      IOSByteArray *rekeyVal = [IOSByteArray arrayWithLength:NetI2pDataSessionKey_KEYSIZE_BYTES];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(decrypted, cur, rekeyVal, 0, NetI2pDataSessionKey_KEYSIZE_BYTES);
      cur += NetI2pDataSessionKey_KEYSIZE_BYTES;
      newKey = create_NetI2pDataSessionKey_init();
      [newKey setDataWithByteArray:rekeyVal];
    }
    IOSByteArray *unencrData = [IOSByteArray arrayWithLength:(jint) len];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(decrypted, cur, unencrData, 0, (jint) len);
    cur += (jint) len;
    IOSByteArray *calcHash = NetI2pUtilSimpleByteCache_acquireWithInt_(32);
    [((NetI2pCryptoSHA256Generator *) nil_chk([_context_ sha])) calculateHashWithByteArray:unencrData withInt:0 withInt:(jint) len withByteArray:calcHash withInt:0];
    jboolean eq = NetI2pDataDataHelper_eqWithByteArray_withInt_withByteArray_withInt_withInt_(decrypted, hashIndex, calcHash, 0, 32);
    NetI2pUtilSimpleByteCache_release__WithByteArray_(calcHash);
    if (eq) {
      if (tags != nil) [((id<JavaUtilSet>) nil_chk(foundTags)) addAllWithJavaUtilCollection:tags];
      if (newKey != nil) [((NetI2pDataSessionKey *) nil_chk(foundKey)) setDataWithByteArray:[newKey getData]];
      return unencrData;
    }
    @throw create_JavaLangRuntimeException_initWithNSString_(@"Hash does not match");
  }
  @catch (JavaLangRuntimeException *e) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to decrypt AES block" withJavaLangThrowable:e];
    return nil;
  }
}

- (IOSByteArray *)encryptWithByteArray:(IOSByteArray *)data
               withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
              withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                       withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
              withNetI2pDataSessionTag:(NetI2pDataSessionTag *)currentTag
              withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                              withLong:(jlong)paddedSize {
  if (currentTag == nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:@"Current tag is null, encrypting as new session"];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.encryptNewSession"];
    return NetI2pCryptoElGamalAESEngine_encryptNewSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(self, data, target, key, tagsForDelivery, newKey, paddedSize);
  }
  [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) statManager])) updateFrequencyWithNSString:@"crypto.elGamalAES.encryptExistingSession"];
  IOSByteArray *rv = NetI2pCryptoElGamalAESEngine_encryptExistingSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionTag_withNetI2pDataSessionKey_withLong_(self, data, target, key, tagsForDelivery, currentTag, newKey, paddedSize);
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$$I$$", @"Existing session encrypted with tag: ", [currentTag description], @": ", ((IOSByteArray *) nil_chk(rv))->size_, @" bytes and key: ", [((NetI2pDataSessionKey *) nil_chk(key)) toBase64])];
  return rv;
}

- (IOSByteArray *)encryptWithByteArray:(IOSByteArray *)data
               withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
              withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                       withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
              withNetI2pDataSessionTag:(NetI2pDataSessionTag *)currentTag
                              withLong:(jlong)paddedSize {
  return [self encryptWithByteArray:data withNetI2pDataPublicKey:target withNetI2pDataSessionKey:key withJavaUtilSet:tagsForDelivery withNetI2pDataSessionTag:currentTag withNetI2pDataSessionKey:nil withLong:paddedSize];
}

- (IOSByteArray *)encryptWithByteArray:(IOSByteArray *)data
               withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
              withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                       withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                              withLong:(jlong)paddedSize {
  return [self encryptWithByteArray:data withNetI2pDataPublicKey:target withNetI2pDataSessionKey:key withJavaUtilSet:tagsForDelivery withNetI2pDataSessionTag:nil withNetI2pDataSessionKey:nil withLong:paddedSize];
}

- (IOSByteArray *)encryptWithByteArray:(IOSByteArray *)data
               withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
              withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                              withLong:(jlong)paddedSize {
  return [self encryptWithByteArray:data withNetI2pDataPublicKey:target withNetI2pDataSessionKey:key withJavaUtilSet:nil withNetI2pDataSessionTag:nil withNetI2pDataSessionKey:nil withLong:paddedSize];
}

- (IOSByteArray *)encryptNewSessionWithByteArray:(IOSByteArray *)data
                         withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                        withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                        withLong:(jlong)paddedSize {
  return NetI2pCryptoElGamalAESEngine_encryptNewSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(self, data, target, key, tagsForDelivery, newKey, paddedSize);
}

- (IOSByteArray *)encryptExistingSessionWithByteArray:(IOSByteArray *)data
                              withNetI2pDataPublicKey:(NetI2pDataPublicKey *)target
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                      withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                             withNetI2pDataSessionTag:(NetI2pDataSessionTag *)currentTag
                             withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                             withLong:(jlong)paddedSize {
  return NetI2pCryptoElGamalAESEngine_encryptExistingSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionTag_withNetI2pDataSessionKey_withLong_(self, data, target, key, tagsForDelivery, currentTag, newKey, paddedSize);
}

- (IOSByteArray *)halfHashWithByteArray:(IOSByteArray *)preIV {
  return NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(self, preIV);
}

- (IOSByteArray *)encryptAESBlockWithByteArray:(IOSByteArray *)data
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withByteArray:(IOSByteArray *)iv
                               withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                      withLong:(jlong)paddedSize {
  return NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(self, data, key, iv, tagsForDelivery, newKey, paddedSize);
}

- (IOSByteArray *)encryptAESBlockWithByteArray:(IOSByteArray *)data
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                 withByteArray:(IOSByteArray *)iv
                               withJavaUtilSet:(id<JavaUtilSet>)tagsForDelivery
                      withNetI2pDataSessionKey:(NetI2pDataSessionKey *)newKey
                                      withLong:(jlong)paddedSize
                                       withInt:(jint)prefixBytes {
  return NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_withInt_(self, data, key, iv, tagsForDelivery, newKey, paddedSize, prefixBytes);
}

+ (IOSByteArray *)getPaddingWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                                            withInt:(jint)curSize
                                           withLong:(jlong)minPaddedSize {
  return NetI2pCryptoElGamalAESEngine_getPaddingWithNetI2pI2PAppContext_withInt_withLong_(context, curSize, minPaddedSize);
}

+ (jint)getPaddingSizeWithInt:(jint)curSize
                     withLong:(jlong)minPaddedSize {
  return NetI2pCryptoElGamalAESEngine_getPaddingSizeWithInt_withLong_(curSize, minPaddedSize);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_context_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "[B", 0x1, 1, 4, 3, -1, -1, -1 },
    { NULL, "[B", 0x2, 5, 6, 3, 7, -1, -1 },
    { NULL, "[B", 0x2, 8, 9, 3, 10, -1, -1 },
    { NULL, "[B", 0x0, 11, 12, 3, 13, -1, -1 },
    { NULL, "[B", 0x1, 14, 15, -1, 16, -1, -1 },
    { NULL, "[B", 0x1, 14, 17, -1, 18, -1, -1 },
    { NULL, "[B", 0x1, 14, 19, -1, 20, -1, -1 },
    { NULL, "[B", 0x1, 14, 21, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 22, 23, -1, 24, -1, -1 },
    { NULL, "[B", 0x2, 25, 15, -1, 16, -1, -1 },
    { NULL, "[B", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "[B", 0x10, 28, 29, -1, 30, -1, -1 },
    { NULL, "[B", 0x12, 28, 31, -1, 32, -1, -1 },
    { NULL, "[B", 0x18, 33, 34, -1, -1, -1, -1 },
    { NULL, "I", 0x18, 35, 36, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(decryptWithByteArray:withNetI2pDataPrivateKey:);
  methods[2].selector = @selector(decryptWithByteArray:withNetI2pDataPrivateKey:withNetI2pCryptoSessionKeyManager:);
  methods[3].selector = @selector(decryptNewSessionWithByteArray:withNetI2pDataPrivateKey:withJavaUtilSet:withNetI2pDataSessionKey:withNetI2pDataSessionKey:);
  methods[4].selector = @selector(decryptExistingSessionWithByteArray:withNetI2pDataSessionKey:withNetI2pDataPrivateKey:withJavaUtilSet:withNetI2pDataSessionKey:withNetI2pDataSessionKey:);
  methods[5].selector = @selector(decryptAESBlockWithByteArray:withInt:withInt:withNetI2pDataSessionKey:withByteArray:withByteArray:withJavaUtilSet:withNetI2pDataSessionKey:);
  methods[6].selector = @selector(encryptWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withJavaUtilSet:withNetI2pDataSessionTag:withNetI2pDataSessionKey:withLong:);
  methods[7].selector = @selector(encryptWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withJavaUtilSet:withNetI2pDataSessionTag:withLong:);
  methods[8].selector = @selector(encryptWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withJavaUtilSet:withLong:);
  methods[9].selector = @selector(encryptWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withLong:);
  methods[10].selector = @selector(encryptNewSessionWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withJavaUtilSet:withNetI2pDataSessionKey:withLong:);
  methods[11].selector = @selector(encryptExistingSessionWithByteArray:withNetI2pDataPublicKey:withNetI2pDataSessionKey:withJavaUtilSet:withNetI2pDataSessionTag:withNetI2pDataSessionKey:withLong:);
  methods[12].selector = @selector(halfHashWithByteArray:);
  methods[13].selector = @selector(encryptAESBlockWithByteArray:withNetI2pDataSessionKey:withByteArray:withJavaUtilSet:withNetI2pDataSessionKey:withLong:);
  methods[14].selector = @selector(encryptAESBlockWithByteArray:withNetI2pDataSessionKey:withByteArray:withJavaUtilSet:withNetI2pDataSessionKey:withLong:withInt:);
  methods[15].selector = @selector(getPaddingWithNetI2pI2PAppContext:withInt:withLong:);
  methods[16].selector = @selector(getPaddingSizeWithInt:withLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "MIN_ENCRYPTED_SIZE", "I", .constantValue.asInt = NetI2pCryptoElGamalAESEngine_MIN_ENCRYPTED_SIZE, 0x1a, -1, -1, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "MAX_TAGS_RECEIVED", "I", .constantValue.asInt = NetI2pCryptoElGamalAESEngine_MAX_TAGS_RECEIVED, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "decrypt", "[BLNetI2pDataPrivateKey;", "LNetI2pDataDataFormatException;", "[BLNetI2pDataPrivateKey;LNetI2pCryptoSessionKeyManager;", "decryptNewSession", "[BLNetI2pDataPrivateKey;LJavaUtilSet;LNetI2pDataSessionKey;LNetI2pDataSessionKey;", "([BLnet/i2p/data/PrivateKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;Lnet/i2p/data/SessionKey;)[B", "decryptExistingSession", "[BLNetI2pDataSessionKey;LNetI2pDataPrivateKey;LJavaUtilSet;LNetI2pDataSessionKey;LNetI2pDataSessionKey;", "([BLnet/i2p/data/SessionKey;Lnet/i2p/data/PrivateKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;Lnet/i2p/data/SessionKey;)[B", "decryptAESBlock", "[BIILNetI2pDataSessionKey;[B[BLJavaUtilSet;LNetI2pDataSessionKey;", "([BIILnet/i2p/data/SessionKey;[B[BLjava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;)[B", "encrypt", "[BLNetI2pDataPublicKey;LNetI2pDataSessionKey;LJavaUtilSet;LNetI2pDataSessionTag;LNetI2pDataSessionKey;J", "([BLnet/i2p/data/PublicKey;Lnet/i2p/data/SessionKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionTag;Lnet/i2p/data/SessionKey;J)[B", "[BLNetI2pDataPublicKey;LNetI2pDataSessionKey;LJavaUtilSet;LNetI2pDataSessionTag;J", "([BLnet/i2p/data/PublicKey;Lnet/i2p/data/SessionKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionTag;J)[B", "[BLNetI2pDataPublicKey;LNetI2pDataSessionKey;LJavaUtilSet;J", "([BLnet/i2p/data/PublicKey;Lnet/i2p/data/SessionKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;J)[B", "[BLNetI2pDataPublicKey;LNetI2pDataSessionKey;J", "encryptNewSession", "[BLNetI2pDataPublicKey;LNetI2pDataSessionKey;LJavaUtilSet;LNetI2pDataSessionKey;J", "([BLnet/i2p/data/PublicKey;Lnet/i2p/data/SessionKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;J)[B", "encryptExistingSession", "halfHash", "[B", "encryptAESBlock", "[BLNetI2pDataSessionKey;[BLJavaUtilSet;LNetI2pDataSessionKey;J", "([BLnet/i2p/data/SessionKey;[BLjava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;J)[B", "[BLNetI2pDataSessionKey;[BLJavaUtilSet;LNetI2pDataSessionKey;JI", "([BLnet/i2p/data/SessionKey;[BLjava/util/Set<Lnet/i2p/data/SessionTag;>;Lnet/i2p/data/SessionKey;JI)[B", "getPadding", "LNetI2pI2PAppContext;IJ", "getPaddingSize", "IJ" };
  static const J2ObjcClassInfo _NetI2pCryptoElGamalAESEngine = { "ElGamalAESEngine", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x11, 17, 4, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoElGamalAESEngine;
}

@end

void NetI2pCryptoElGamalAESEngine_initWithNetI2pI2PAppContext_(NetI2pCryptoElGamalAESEngine *self, NetI2pI2PAppContext *ctx) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, ctx);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) logManager])) getLogWithIOSClass:NetI2pCryptoElGamalAESEngine_class_()]);
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createFrequencyStatWithNSString:@"crypto.elGamalAES.encryptNewSession" withNSString:@"how frequently we encrypt to a new ElGamal/AES+SessionTag session?" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000l } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createFrequencyStatWithNSString:@"crypto.elGamalAES.encryptExistingSession" withNSString:@"how frequently we encrypt to an existing ElGamal/AES+SessionTag session?" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000l } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createFrequencyStatWithNSString:@"crypto.elGamalAES.decryptNewSession" withNSString:@"how frequently we decrypt with a new ElGamal/AES+SessionTag session?" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000l } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createFrequencyStatWithNSString:@"crypto.elGamalAES.decryptExistingSession" withNSString:@"how frequently we decrypt with an existing ElGamal/AES+SessionTag session?" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000l } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createFrequencyStatWithNSString:@"crypto.elGamalAES.decryptFailed" withNSString:@"how frequently we fail to decrypt with ElGamal/AES+SessionTag?" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000l } count:1]];
}

NetI2pCryptoElGamalAESEngine *new_NetI2pCryptoElGamalAESEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *ctx) {
  J2OBJC_NEW_IMPL(NetI2pCryptoElGamalAESEngine, initWithNetI2pI2PAppContext_, ctx)
}

NetI2pCryptoElGamalAESEngine *create_NetI2pCryptoElGamalAESEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *ctx) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoElGamalAESEngine, initWithNetI2pI2PAppContext_, ctx)
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_decryptNewSessionWithByteArray_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPrivateKey *targetPrivateKey, id<JavaUtilSet> foundTags, NetI2pDataSessionKey *usedKey, NetI2pDataSessionKey *foundKey) {
  if (data == nil) {
    return nil;
  }
  else if (data->size_ < 514) {
    return nil;
  }
  IOSByteArray *elgEncr = [IOSByteArray arrayWithLength:514];
  if (data->size_ > 514) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, elgEncr, 0, 514);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, elgEncr, 514 - data->size_, data->size_);
  }
  IOSByteArray *elgDecr = [((NetI2pCryptoElGamalEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) elGamalEngine])) decryptWithByteArray:elgEncr withNetI2pDataPrivateKey:targetPrivateKey];
  if (elgDecr == nil) {
    return nil;
  }
  jint offset = 0;
  IOSByteArray *key = [IOSByteArray arrayWithLength:NetI2pDataSessionKey_KEYSIZE_BYTES];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(elgDecr, offset, key, 0, NetI2pDataSessionKey_KEYSIZE_BYTES);
  offset += NetI2pDataSessionKey_KEYSIZE_BYTES;
  [((NetI2pDataSessionKey *) nil_chk(usedKey)) setDataWithByteArray:key];
  IOSByteArray *preIV = NetI2pUtilSimpleByteCache_acquireWithInt_(32);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(elgDecr, offset, preIV, 0, 32);
  offset += 32;
  IOSByteArray *iv = NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(self, preIV);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(preIV);
  [((id<NetI2pCryptoEntropyHarvester>) nil_chk([((NetI2pUtilRandomSource *) nil_chk([self->_context_ random])) harvester])) feedEntropyWithNSString:@"ElG/AES" withByteArray:elgDecr withInt:offset withInt:elgDecr->size_ - offset];
  IOSByteArray *aesDecr = [self decryptAESBlockWithByteArray:data withInt:514 withInt:data->size_ - 514 withNetI2pDataSessionKey:usedKey withByteArray:iv withByteArray:nil withJavaUtilSet:foundTags withNetI2pDataSessionKey:foundKey];
  NetI2pUtilSimpleByteCache_release__WithByteArray_(iv);
  return aesDecr;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_decryptExistingSessionWithByteArray_withNetI2pDataSessionKey_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, NetI2pDataPrivateKey *targetPrivateKey, id<JavaUtilSet> foundTags, NetI2pDataSessionKey *usedKey, NetI2pDataSessionKey *foundKey) {
  IOSByteArray *preIV = NetI2pUtilSimpleByteCache_acquireWithInt_(32);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, preIV, 0, 32);
  IOSByteArray *iv = NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(self, preIV);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(preIV);
  IOSByteArray *decrypted = [self decryptAESBlockWithByteArray:data withInt:32 withInt:((IOSByteArray *) nil_chk(data))->size_ - 32 withNetI2pDataSessionKey:key withByteArray:iv withByteArray:preIV withJavaUtilSet:foundTags withNetI2pDataSessionKey:foundKey];
  NetI2pUtilSimpleByteCache_release__WithByteArray_(iv);
  if (decrypted == nil) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"Decrypting looks negative... existing key fails with existing tag, lets try as a new one"];
    IOSByteArray *rv = NetI2pCryptoElGamalAESEngine_decryptNewSessionWithByteArray_withNetI2pDataPrivateKey_withJavaUtilSet_withNetI2pDataSessionKey_withNetI2pDataSessionKey_(self, data, targetPrivateKey, foundTags, usedKey, foundKey);
    if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) {
      if (rv == nil) [self->_log_ warnWithNSString:@"Decrypting failed with a known existing tag as either an existing message or a new session"];
      else [self->_log_ warnWithNSString:@"Decrypting suceeded as a new session, even though it used an existing tag!"];
    }
    return rv;
  }
  [((NetI2pDataSessionKey *) nil_chk(usedKey)) setDataWithByteArray:[((NetI2pDataSessionKey *) nil_chk(key)) getData]];
  return decrypted;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptNewSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPublicKey *target, NetI2pDataSessionKey *key, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize) {
  IOSByteArray *elgSrcData = [IOSByteArray arrayWithLength:NetI2pDataSessionKey_KEYSIZE_BYTES + 32 + 158];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSessionKey *) nil_chk(key)) getData], 0, elgSrcData, 0, NetI2pDataSessionKey_KEYSIZE_BYTES);
  [((NetI2pUtilRandomSource *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) random])) nextBytesWithByteArray:elgSrcData withInt:NetI2pDataSessionKey_KEYSIZE_BYTES withInt:32 + 158];
  IOSByteArray *preIV = NetI2pUtilSimpleByteCache_acquireWithInt_(32);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(elgSrcData, NetI2pDataSessionKey_KEYSIZE_BYTES, preIV, 0, 32);
  jlong before = [((NetI2pUtilClock *) nil_chk([self->_context_ clock])) now];
  IOSByteArray *elgEncr = [((NetI2pCryptoElGamalEngine *) nil_chk([self->_context_ elGamalEngine])) encryptWithByteArray:elgSrcData withNetI2pDataPublicKey:target];
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) {
    jlong after = [((NetI2pUtilClock *) nil_chk([self->_context_ clock])) now];
    [self->_log_ infoWithNSString:JreStrcat("$J$", @"elgEngine.encrypt of the session key took ", (after - before), @"ms")];
  }
  if (((IOSByteArray *) nil_chk(elgEncr))->size_ < 514) {
    IOSByteArray *elg = [IOSByteArray arrayWithLength:514];
    jint diff = elg->size_ - elgEncr->size_;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(elgEncr, 0, elg, diff, elgEncr->size_);
    elgEncr = elg;
  }
  IOSByteArray *iv = NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(self, preIV);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(preIV);
  IOSByteArray *aesEncr = NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(self, data, key, iv, tagsForDelivery, newKey, paddedSize);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(iv);
  IOSByteArray *rv = [IOSByteArray arrayWithLength:elgEncr->size_ + ((IOSByteArray *) nil_chk(aesEncr))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(elgEncr, 0, rv, 0, elgEncr->size_);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(aesEncr, 0, rv, elgEncr->size_, aesEncr->size_);
  return rv;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptExistingSessionWithByteArray_withNetI2pDataPublicKey_withNetI2pDataSessionKey_withJavaUtilSet_withNetI2pDataSessionTag_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataPublicKey *target, NetI2pDataSessionKey *key, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionTag *currentTag, NetI2pDataSessionKey *newKey, jlong paddedSize) {
  IOSByteArray *rawTag = [((NetI2pDataSessionTag *) nil_chk(currentTag)) getData];
  IOSByteArray *iv = NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(self, rawTag);
  IOSByteArray *aesEncr = NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_withInt_(self, data, key, iv, tagsForDelivery, newKey, paddedSize, NetI2pDataSessionTag_BYTE_LENGTH);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(iv);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(rawTag, 0, aesEncr, 0, ((IOSByteArray *) nil_chk(rawTag))->size_);
  return aesEncr;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_halfHashWithByteArray_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *preIV) {
  IOSByteArray *ivHash = NetI2pUtilSimpleByteCache_acquireWithInt_(32);
  [((NetI2pCryptoSHA256Generator *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) sha])) calculateHashWithByteArray:preIV withInt:0 withInt:32 withByteArray:ivHash withInt:0];
  IOSByteArray *iv = NetI2pUtilSimpleByteCache_acquireWithInt_(16);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ivHash, 0, iv, 0, 16);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(ivHash);
  return iv;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, IOSByteArray *iv, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize) {
  return NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_withInt_(self, data, key, iv, tagsForDelivery, newKey, paddedSize, 0);
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_encryptAESBlockWithByteArray_withNetI2pDataSessionKey_withByteArray_withJavaUtilSet_withNetI2pDataSessionKey_withLong_withInt_(NetI2pCryptoElGamalAESEngine *self, IOSByteArray *data, NetI2pDataSessionKey *key, IOSByteArray *iv, id<JavaUtilSet> tagsForDelivery, NetI2pDataSessionKey *newKey, jlong paddedSize, jint prefixBytes) {
  if (tagsForDelivery == nil) tagsForDelivery = JavaUtilCollections_emptySet();
  jint size = 2 + NetI2pDataSessionTag_BYTE_LENGTH * [((id<JavaUtilSet>) nil_chk(tagsForDelivery)) size] + 4 + NetI2pDataHash_HASH_LENGTH + (newKey == nil ? 1 : 1 + NetI2pDataSessionKey_KEYSIZE_BYTES) + ((IOSByteArray *) nil_chk(data))->size_;
  jint totalSize = size + NetI2pCryptoElGamalAESEngine_getPaddingSizeWithInt_withLong_(size, paddedSize);
  IOSByteArray *aesData = [IOSByteArray arrayWithLength:totalSize + prefixBytes];
  jint cur = prefixBytes;
  NetI2pDataDataHelper_toLongWithByteArray_withInt_withInt_withLong_(aesData, cur, 2, [tagsForDelivery size]);
  cur += 2;
  for (NetI2pDataSessionTag * __strong tag in tagsForDelivery) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSessionTag *) nil_chk(tag)) getData], 0, aesData, cur, NetI2pDataSessionTag_BYTE_LENGTH);
    cur += NetI2pDataSessionTag_BYTE_LENGTH;
  }
  NetI2pDataDataHelper_toLongWithByteArray_withInt_withInt_withLong_(aesData, cur, 4, data->size_);
  cur += 4;
  [((NetI2pCryptoSHA256Generator *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) sha])) calculateHashWithByteArray:data withInt:0 withInt:data->size_ withByteArray:aesData withInt:cur];
  cur += NetI2pDataHash_HASH_LENGTH;
  if (newKey == nil) {
    *IOSByteArray_GetRef(aesData, cur++) = (jint) 0x00;
  }
  else {
    *IOSByteArray_GetRef(aesData, cur++) = (jint) 0x01;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([newKey getData], 0, aesData, cur, NetI2pDataSessionKey_KEYSIZE_BYTES);
    cur += NetI2pDataSessionKey_KEYSIZE_BYTES;
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, aesData, cur, data->size_);
  cur += data->size_;
  IOSByteArray *padding = NetI2pCryptoElGamalAESEngine_getPaddingWithNetI2pI2PAppContext_withInt_withLong_(self->_context_, size, paddedSize);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(padding, 0, aesData, cur, ((IOSByteArray *) nil_chk(padding))->size_);
  cur += padding->size_;
  [((NetI2pCryptoAESEngine *) nil_chk([self->_context_ aes])) encryptWithByteArray:aesData withInt:prefixBytes withByteArray:aesData withInt:prefixBytes withNetI2pDataSessionKey:key withByteArray:iv withInt:aesData->size_ - prefixBytes];
  return aesData;
}

IOSByteArray *NetI2pCryptoElGamalAESEngine_getPaddingWithNetI2pI2PAppContext_withInt_withLong_(NetI2pI2PAppContext *context, jint curSize, jlong minPaddedSize) {
  NetI2pCryptoElGamalAESEngine_initialize();
  jint size = NetI2pCryptoElGamalAESEngine_getPaddingSizeWithInt_withLong_(curSize, minPaddedSize);
  IOSByteArray *rv = [IOSByteArray arrayWithLength:size];
  [((NetI2pUtilRandomSource *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) random])) nextBytesWithByteArray:rv];
  return rv;
}

jint NetI2pCryptoElGamalAESEngine_getPaddingSizeWithInt_withLong_(jint curSize, jlong minPaddedSize) {
  NetI2pCryptoElGamalAESEngine_initialize();
  jint diff = 0;
  if (curSize < minPaddedSize) {
    diff = (jint) minPaddedSize - curSize;
  }
  jint numPadding = diff;
  if (((curSize + diff) % 16) != 0) numPadding += (16 - ((curSize + diff) % 16));
  return numPadding;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoElGamalAESEngine)
