//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/ElGamalEngine.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/CryptoConstants.h"
#include "net/i2p/crypto/ElGamalEngine.h"
#include "net/i2p/crypto/SHA256Generator.h"
#include "net/i2p/crypto/SigUtil.h"
#include "net/i2p/crypto/YKGenerator.h"
#include "net/i2p/data/Base64.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/PrivateKey.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/NativeBigInteger.h"
#include "net/i2p/util/RandomSource.h"
#include "net/i2p/util/SimpleByteCache.h"

@interface NetI2pCryptoElGamalEngine () {
 @public
  NetI2pUtilLog *_log_;
  NetI2pI2PAppContext *_context_;
  NetI2pCryptoYKGenerator *_ykgen_;
}

- (IOSObjectArray *)getNextYK;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoElGamalEngine, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pCryptoElGamalEngine, _context_, NetI2pI2PAppContext *)
J2OBJC_FIELD_SETTER(NetI2pCryptoElGamalEngine, _ykgen_, NetI2pCryptoYKGenerator *)

inline JavaMathBigInteger *NetI2pCryptoElGamalEngine_get_ELGPM1(void);
static JavaMathBigInteger *NetI2pCryptoElGamalEngine_ELGPM1;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoElGamalEngine, ELGPM1, JavaMathBigInteger *)

__attribute__((unused)) static IOSObjectArray *NetI2pCryptoElGamalEngine_getNextYK(NetI2pCryptoElGamalEngine *self);

J2OBJC_INITIALIZED_DEFN(NetI2pCryptoElGamalEngine)

@implementation NetI2pCryptoElGamalEngine

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context {
  NetI2pCryptoElGamalEngine_initWithNetI2pI2PAppContext_(self, context);
  return self;
}

- (void)shutdown {
  [((NetI2pCryptoYKGenerator *) nil_chk(_ykgen_)) shutdown];
  NetI2pCryptoSigUtil_clearCaches();
}

- (void)restart {
}

- (IOSObjectArray *)getNextYK {
  return NetI2pCryptoElGamalEngine_getNextYK(self);
}

- (IOSByteArray *)encryptWithByteArray:(IOSByteArray *)data
               withNetI2pDataPublicKey:(NetI2pDataPublicKey *)publicKey {
  if ((data == nil) || (((IOSByteArray *) nil_chk(data))->size_ >= 223)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Data to encrypt must be < 223 bytes at the moment");
  if (publicKey == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Null public key specified");
  jlong start = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) clock])) now];
  IOSByteArray *d2 = [IOSByteArray arrayWithLength:1 + NetI2pDataHash_HASH_LENGTH + ((IOSByteArray *) nil_chk(data))->size_];
  do {
    [((NetI2pUtilRandomSource *) nil_chk([_context_ random])) nextBytesWithByteArray:d2 withInt:0 withInt:1];
  }
  while (IOSByteArray_Get(d2, 0) == 0);
  [((NetI2pCryptoSHA256Generator *) nil_chk([_context_ sha])) calculateHashWithByteArray:data withInt:0 withInt:data->size_ withByteArray:d2 withInt:1];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, d2, 1 + NetI2pDataHash_HASH_LENGTH, data->size_);
  JavaMathBigInteger *m = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, d2);
  if ([m compareToWithId:JreLoadStatic(NetI2pCryptoCryptoConstants, elgp)] >= 0) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"ARGH.  Data cannot be larger than the ElGamal prime.  FIXME");
  JavaMathBigInteger *aalpha = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, [publicKey getData]);
  IOSObjectArray *yk = NetI2pCryptoElGamalEngine_getNextYK(self);
  JavaMathBigInteger *k = IOSObjectArray_Get(nil_chk(yk), 1);
  JavaMathBigInteger *y = IOSObjectArray_Get(yk, 0);
  JavaMathBigInteger *d = [aalpha modPowWithJavaMathBigInteger:k withJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, elgp)];
  d = [((JavaMathBigInteger *) nil_chk(d)) multiplyWithJavaMathBigInteger:m];
  d = [((JavaMathBigInteger *) nil_chk(d)) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, elgp)];
  IOSByteArray *ybytes = [((JavaMathBigInteger *) nil_chk(y)) toByteArray];
  IOSByteArray *dbytes = [((JavaMathBigInteger *) nil_chk(d)) toByteArray];
  IOSByteArray *out = [IOSByteArray arrayWithLength:514];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ybytes, 0, out, (((IOSByteArray *) nil_chk(ybytes))->size_ < 257 ? 257 - ybytes->size_ : 0), (ybytes->size_ > 257 ? 257 : ybytes->size_));
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(dbytes, 0, out, (((IOSByteArray *) nil_chk(dbytes))->size_ < 257 ? 514 - dbytes->size_ : 257), (dbytes->size_ > 257 ? 257 : dbytes->size_));
  jlong end = [((NetI2pUtilClock *) nil_chk([_context_ clock])) now];
  jlong diff = end - start;
  if (diff > 1000) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$J$", @"Took too long to encrypt ElGamal block (", diff, @"ms)")];
  }
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"crypto.elGamal.encrypt" withLong:diff];
  return out;
}

- (IOSByteArray *)decryptWithByteArray:(IOSByteArray *)encrypted
              withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)privateKey {
  if ((encrypted == nil) || (((IOSByteArray *) nil_chk(encrypted))->size_ != 514)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Data to decrypt must be exactly 514 bytes");
  jlong start = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) clock])) now];
  JavaMathBigInteger *a = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, [((NetI2pDataPrivateKey *) nil_chk(privateKey)) getData]);
  JavaMathBigInteger *y1p = [((JavaMathBigInteger *) nil_chk(NetI2pCryptoElGamalEngine_ELGPM1)) subtractWithJavaMathBigInteger:a];
  IOSByteArray *buf = NetI2pUtilSimpleByteCache_acquireWithInt_(257);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(encrypted, 0, buf, 0, 257);
  NetI2pUtilNativeBigInteger *y = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, buf);
  JavaMathBigInteger *ya = [y modPowCTWithJavaMathBigInteger:y1p withJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, elgp)];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(encrypted, 257, buf, 0, 257);
  JavaMathBigInteger *d = create_NetI2pUtilNativeBigInteger_initWithInt_withByteArray_(1, buf);
  JavaMathBigInteger *m = [((JavaMathBigInteger *) nil_chk(ya)) multiplyWithJavaMathBigInteger:d];
  m = [((JavaMathBigInteger *) nil_chk(m)) modWithJavaMathBigInteger:JreLoadStatic(NetI2pCryptoCryptoConstants, elgp)];
  IOSByteArray *val = [((JavaMathBigInteger *) nil_chk(m)) toByteArray];
  jint i;
  for (i = 0; i < ((IOSByteArray *) nil_chk(val))->size_; i++) {
    if (IOSByteArray_Get(val, i) != (jbyte) (jint) 0x00) break;
  }
  jint payloadLen = val->size_ - i - 1 - NetI2pDataHash_HASH_LENGTH;
  if (payloadLen < 0) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$IC", @"Decrypted data is too small (", (val->size_ - i), ')')];
    return nil;
  }
  IOSByteArray *rv = [IOSByteArray arrayWithLength:payloadLen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(val, i + 1 + NetI2pDataHash_HASH_LENGTH, rv, 0, rv->size_);
  [((NetI2pCryptoSHA256Generator *) nil_chk([_context_ sha])) calculateHashWithByteArray:rv withInt:0 withInt:payloadLen withByteArray:buf withInt:0];
  jboolean ok = NetI2pDataDataHelper_eqWithByteArray_withInt_withByteArray_withInt_withInt_(buf, 0, val, i + 1, NetI2pDataHash_HASH_LENGTH);
  NetI2pUtilSimpleByteCache_release__WithByteArray_(buf);
  jlong end = [((NetI2pUtilClock *) nil_chk([_context_ clock])) now];
  jlong diff = end - start;
  if (diff > 1000) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$J$", @"Took too long to decrypt and verify ElGamal block (", diff, @"ms)")];
  }
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"crypto.elGamal.decrypt" withLong:diff];
  if (ok) {
    return rv;
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", @"Doesn't match hash data = ", NetI2pDataBase64_encodeWithByteArray_(rv)) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"Doesn't match")];
  return nil;
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_context_);
  RELEASE_(_ykgen_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[LJavaMathBigInteger;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 3, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(shutdown);
  methods[2].selector = @selector(restart);
  methods[3].selector = @selector(getNextYK);
  methods[4].selector = @selector(encryptWithByteArray:withNetI2pDataPublicKey:);
  methods[5].selector = @selector(decryptWithByteArray:withNetI2pDataPrivateKey:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_ykgen_", "LNetI2pCryptoYKGenerator;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ELGPM1", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x1a, -1, 5, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "encrypt", "[BLNetI2pDataPublicKey;", "decrypt", "[BLNetI2pDataPrivateKey;", &NetI2pCryptoElGamalEngine_ELGPM1 };
  static const J2ObjcClassInfo _NetI2pCryptoElGamalEngine = { "ElGamalEngine", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x11, 6, 4, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoElGamalEngine;
}

+ (void)initialize {
  if (self == [NetI2pCryptoElGamalEngine class]) {
    JreStrongAssign(&NetI2pCryptoElGamalEngine_ELGPM1, [((NetI2pUtilNativeBigInteger *) nil_chk(JreLoadStatic(NetI2pCryptoCryptoConstants, elgp))) subtractWithJavaMathBigInteger:JreLoadStatic(JavaMathBigInteger, ONE)]);
    J2OBJC_SET_INITIALIZED(NetI2pCryptoElGamalEngine)
  }
}

@end

void NetI2pCryptoElGamalEngine_initWithNetI2pI2PAppContext_(NetI2pCryptoElGamalEngine *self, NetI2pI2PAppContext *context) {
  NSObject_init(self);
  [((NetI2pStatStatManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) statManager])) createRequiredRateStatWithNSString:@"crypto.elGamal.encrypt" withNSString:@"Time for ElGamal encryption (ms)" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([context statManager])) createRequiredRateStatWithNSString:@"crypto.elGamal.decrypt" withNSString:@"Time for ElGamal decryption (ms)" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([context logManager])) getLogWithIOSClass:NetI2pCryptoElGamalEngine_class_()]);
  JreStrongAssignAndConsume(&self->_ykgen_, new_NetI2pCryptoYKGenerator_initWithNetI2pI2PAppContext_(context));
  [self->_ykgen_ start];
}

NetI2pCryptoElGamalEngine *new_NetI2pCryptoElGamalEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_NEW_IMPL(NetI2pCryptoElGamalEngine, initWithNetI2pI2PAppContext_, context)
}

NetI2pCryptoElGamalEngine *create_NetI2pCryptoElGamalEngine_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoElGamalEngine, initWithNetI2pI2PAppContext_, context)
}

IOSObjectArray *NetI2pCryptoElGamalEngine_getNextYK(NetI2pCryptoElGamalEngine *self) {
  return [((NetI2pCryptoYKGenerator *) nil_chk(self->_ykgen_)) getNextYK];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoElGamalEngine)
