//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/crypto/TrustedUpdate.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/PrintStream.h"
#include "java/io/SequenceInputStream.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/StringTokenizer.h"
#include "net/i2p/CoreVersion.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/DSAEngine.h"
#include "net/i2p/crypto/KeyGenerator.h"
#include "net/i2p/crypto/TrustedUpdate.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/SecureFileOutputStream.h"
#include "net/i2p/util/VersionComparator.h"
#include "net/i2p/util/ZipFileComment.h"

@interface NetI2pCryptoTrustedUpdate () {
 @public
  NetI2pI2PAppContext *_context_;
  NetI2pUtilLog *_log_;
  id<JavaUtilMap> _trustedKeys_;
  NSString *_newVersion_;
}

+ (jboolean)genKeysCLIWithNSString:(NSString *)publicKeyFile
                      withNSString:(NSString *)privateKeyFile;

+ (void)showUsageCLI;

+ (jboolean)showVersionCLIWithNSString:(NSString *)signedFile;

+ (jboolean)signCLIWithNSString:(NSString *)inputFile
                   withNSString:(NSString *)signedFile
                   withNSString:(NSString *)privateKeyFile
                   withNSString:(NSString *)version_;

+ (jboolean)verifySigCLIWithNSString:(NSString *)signedFile;

+ (jboolean)verifyUpdateCLIWithNSString:(NSString *)signedFile;

+ (jboolean)verifyVersionCLIWithNSString:(NSString *)signedFile;

- (jboolean)verifyVersionMatchWithJavaIoFile:(JavaIoFile *)signedFile;

@end

J2OBJC_FIELD_SETTER(NetI2pCryptoTrustedUpdate, _context_, NetI2pI2PAppContext *)
J2OBJC_FIELD_SETTER(NetI2pCryptoTrustedUpdate, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pCryptoTrustedUpdate, _trustedKeys_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(NetI2pCryptoTrustedUpdate, _newVersion_, NSString *)

inline NSString *NetI2pCryptoTrustedUpdate_get_DEFAULT_TRUSTED_KEY(void);
static NSString *NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY = @"W4kJbnv9KSVwbnapV7SaNW2kMIZKs~hwL0ro9pZXFo1xTwqz45nykCp1HM7sAKYDZay5z1HvYYOl9CNVz00xF03KPU9RUCVxhDZ1YXhZIskPKjUPUsCIpE~Z1C~N9KSEV6~2stDlBNH10VZ4T0X1TrcXwb3IBXliWo2y2GAx~Ow=";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_TRUSTED_KEY, NSString *)

inline NSString *NetI2pCryptoTrustedUpdate_get_DEFAULT_TRUSTED_KEY2(void);
static NSString *NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY2 = @"lT54eq3SH0TWWwQ1wgH6XPelIno7wH7UfiZOpQg-ZuxdNhc4UjjrohKdKZqfswt1ANPnmOlMewLGBESl7kJB9c5sByz~IOlNyz5BMLRC~R~ZC9QI4WXwUBYW8BhYO2mkvtdOrcy690lDkwzdf5xLxlCBpQlTaLYzQVjVWBcvbCA=";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_TRUSTED_KEY2, NSString *)

inline NSString *NetI2pCryptoTrustedUpdate_get_DEFAULT_TRUSTED_KEY3(void);
static NSString *NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY3 = @"JHFA0yXUgKtmhajXFZH9Nk62OPRHbvvQHTi8EANV-D~3tjLjaz9p9cs6Fs8W3FSLfUwsQeFg7dfVSQQZga~1jMjboo94vIcm3j6XbW4mbcorVQ74uPjd8EA1AQhJ6bBTxDAFk~6fVDOdhHT0Wo5CcUn7v8bAYY3x3UWiL8Remx0=";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_TRUSTED_KEY3, NSString *)

inline NSString *NetI2pCryptoTrustedUpdate_get_DEFAULT_TRUSTED_KEY4(void);
static NSString *NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY4 = @"l3G6um9nB9EDLkT9cUusz5fX-GxXSWE5zaj2~V8lUL~XsGuFf8gKqzJLKNkAw0CgDIDsLRHHuUaF7ZHo5Z7HG~9JJU9Il4G2jyNYtg5S8AzG0UxkEt-JeBEqIxv5GDn6OFKr~wTI0UafJbegEWokl-8m-GPWf0vW-yPMjL7y5MI=";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_TRUSTED_KEY4, NSString *)

inline NSString *NetI2pCryptoTrustedUpdate_get_DEFAULT_TRUSTED_KEY5(void);
static NSString *NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY5 = @"DAVvT6zMcRuzJi3V8DKKV6o0GjXoQsEwnJsFMaVG1Se-KPQjfP8PbgKJDcrFe0zNJfh3yPdsocA~A~s9U6pvimlCXH2pnJGlNNojtFCZC3DleROl5-4EkYw~UKAg940o5yg1OCBVlRZBSrRAQIIjFGkxxPQc12dA~cfpryNk7Dc=";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_TRUSTED_KEY5, NSString *)

inline jint NetI2pCryptoTrustedUpdate_get_VERSION_BYTES(void);
#define NetI2pCryptoTrustedUpdate_VERSION_BYTES 16
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pCryptoTrustedUpdate, VERSION_BYTES, jint)

inline NSString *NetI2pCryptoTrustedUpdate_get_PROP_TRUSTED_KEYS(void);
static NSString *NetI2pCryptoTrustedUpdate_PROP_TRUSTED_KEYS = @"router.trustedUpdateKeys";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, PROP_TRUSTED_KEYS, NSString *)

inline jint NetI2pCryptoTrustedUpdate_get_KEYSIZE_B64_BYTES(void);
static jint NetI2pCryptoTrustedUpdate_KEYSIZE_B64_BYTES;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(NetI2pCryptoTrustedUpdate, KEYSIZE_B64_BYTES, jint)

inline id<JavaUtilMap> NetI2pCryptoTrustedUpdate_get_DEFAULT_KEYS(void);
static id<JavaUtilMap> NetI2pCryptoTrustedUpdate_DEFAULT_KEYS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pCryptoTrustedUpdate, DEFAULT_KEYS, id<JavaUtilMap>)

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_genKeysCLIWithNSString_withNSString_(NSString *publicKeyFile, NSString *privateKeyFile);

__attribute__((unused)) static void NetI2pCryptoTrustedUpdate_showUsageCLI(void);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_showVersionCLIWithNSString_(NSString *signedFile);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_signCLIWithNSString_withNSString_withNSString_withNSString_(NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_verifySigCLIWithNSString_(NSString *signedFile);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_verifyUpdateCLIWithNSString_(NSString *signedFile);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_verifyVersionCLIWithNSString_(NSString *signedFile);

__attribute__((unused)) static jboolean NetI2pCryptoTrustedUpdate_verifyVersionMatchWithJavaIoFile_(NetI2pCryptoTrustedUpdate *self, JavaIoFile *signedFile);

J2OBJC_INITIALIZED_DEFN(NetI2pCryptoTrustedUpdate)

jint NetI2pCryptoTrustedUpdate_HEADER_BYTES;

@implementation NetI2pCryptoTrustedUpdate

+ (jint)HEADER_BYTES {
  return NetI2pCryptoTrustedUpdate_HEADER_BYTES;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pCryptoTrustedUpdate_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context {
  NetI2pCryptoTrustedUpdate_initWithNetI2pI2PAppContext_(self, context);
  return self;
}

- (id<JavaUtilMap>)getKeys {
  return JavaUtilCollections_unmodifiableMapWithJavaUtilMap_(_trustedKeys_);
}

- (jboolean)addKeyWithNSString:(NSString *)key
                  withNSString:(NSString *)name {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$$$", @"Adding ", name, @": ", key)];
  NetI2pDataSigningPublicKey *signingPublicKey = create_NetI2pDataSigningPublicKey_init();
  @try {
    [signingPublicKey fromBase64WithNSString:key];
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    [_log_ errorWithNSString:JreStrcat("$$$$", @"Invalid signing key for ", name, @" : ", key) withJavaLangThrowable:dfe];
    return false;
  }
  NSString *oldName = [((id<JavaUtilMap>) nil_chk(_trustedKeys_)) getWithId:signingPublicKey];
  if ([((NSString *) nil_chk(name)) isEqual:oldName]) return true;
  if (oldName != nil && ![oldName isEqual:@""]) {
    [_log_ errorWithNSString:JreStrcat("$$$$$$", @"Key for ", name, @" already stored for different name ", oldName, @" : ", key)];
    return false;
  }
  if ((![name isEqual:@""]) && [_trustedKeys_ containsValueWithId:name]) {
    [_log_ errorWithNSString:JreStrcat("$$$$", @"Key mismatch for ", name, @", spoof attempt? : ", key)];
    return false;
  }
  [_trustedKeys_ putWithId:signingPublicKey withId:name];
  return true;
}

- (jboolean)haveKeyWithNSString:(NSString *)key {
  if ([((NSString *) nil_chk(key)) java_length] != NetI2pCryptoTrustedUpdate_KEYSIZE_B64_BYTES) return false;
  NetI2pDataSigningPublicKey *signingPublicKey = create_NetI2pDataSigningPublicKey_init();
  @try {
    [signingPublicKey fromBase64WithNSString:key];
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    return false;
  }
  return [((id<JavaUtilMap>) nil_chk(_trustedKeys_)) containsKeyWithId:signingPublicKey];
}

+ (void)mainWithNSStringArray:(IOSObjectArray *)args {
  NetI2pCryptoTrustedUpdate_mainWithNSStringArray_(args);
}

+ (jboolean)needsUpdateWithNSString:(NSString *)currentVersion
                       withNSString:(NSString *)newVersion {
  return NetI2pCryptoTrustedUpdate_needsUpdateWithNSString_withNSString_(currentVersion, newVersion);
}

+ (jboolean)genKeysCLIWithNSString:(NSString *)publicKeyFile
                      withNSString:(NSString *)privateKeyFile {
  return NetI2pCryptoTrustedUpdate_genKeysCLIWithNSString_withNSString_(publicKeyFile, privateKeyFile);
}

+ (void)showUsageCLI {
  NetI2pCryptoTrustedUpdate_showUsageCLI();
}

+ (jboolean)showVersionCLIWithNSString:(NSString *)signedFile {
  return NetI2pCryptoTrustedUpdate_showVersionCLIWithNSString_(signedFile);
}

+ (jboolean)signCLIWithNSString:(NSString *)inputFile
                   withNSString:(NSString *)signedFile
                   withNSString:(NSString *)privateKeyFile
                   withNSString:(NSString *)version_ {
  return NetI2pCryptoTrustedUpdate_signCLIWithNSString_withNSString_withNSString_withNSString_(inputFile, signedFile, privateKeyFile, version_);
}

+ (jboolean)verifySigCLIWithNSString:(NSString *)signedFile {
  return NetI2pCryptoTrustedUpdate_verifySigCLIWithNSString_(signedFile);
}

+ (jboolean)verifyUpdateCLIWithNSString:(NSString *)signedFile {
  return NetI2pCryptoTrustedUpdate_verifyUpdateCLIWithNSString_(signedFile);
}

+ (jboolean)verifyVersionCLIWithNSString:(NSString *)signedFile {
  return NetI2pCryptoTrustedUpdate_verifyVersionCLIWithNSString_(signedFile);
}

- (NSString *)getTrustedKeysString {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(1024);
  for (NetI2pDataSigningPublicKey * __strong spk in nil_chk([((id<JavaUtilMap>) nil_chk(_trustedKeys_)) keySet])) {
    if ([buf java_length] > 0) [buf appendWithNSString:@"\x0d\n"];
    [buf appendWithNSString:[((NetI2pDataSigningPublicKey *) nil_chk(spk)) toBase64]];
  }
  return [buf description];
}

+ (NSString *)getVersionStringWithJavaIoFile:(JavaIoFile *)signedFile {
  return NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoFile_(signedFile);
}

+ (NSString *)getVersionStringWithJavaIoInputStream:(JavaIoInputStream *)inputStream {
  return NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoInputStream_(inputStream);
}

- (NSString *)newVersion {
  return _newVersion_;
}

- (jboolean)isUpdatedVersionWithNSString:(NSString *)currentVersion
                          withJavaIoFile:(JavaIoFile *)signedFile {
  JreStrongAssign(&_newVersion_, NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoFile_(signedFile));
  return NetI2pCryptoTrustedUpdate_needsUpdateWithNSString_withNSString_(currentVersion, _newVersion_);
}

- (NSString *)migrateVerifiedWithNSString:(NSString *)currentVersion
                           withJavaIoFile:(JavaIoFile *)signedFile
                           withJavaIoFile:(JavaIoFile *)outputFile {
  if (![((JavaIoFile *) nil_chk(signedFile)) exists]) return JreStrcat("$$", @"File not found: ", [signedFile getAbsolutePath]);
  if (![self isUpdatedVersionWithNSString:currentVersion withJavaIoFile:signedFile]) {
    if ([@"" isEqual:_newVersion_]) return JreStrcat("$$", @"Truncated or corrupt file: ", [signedFile getAbsolutePath]);
    else return @"Downloaded version is not greater than current version";
  }
  if (!NetI2pCryptoTrustedUpdate_verifyVersionMatchWithJavaIoFile_(self, signedFile)) return @"Update file invalid - signed version mismatch";
  if (![self verifyWithJavaIoFile:signedFile]) return @"Unknown signing key or corrupt file";
  return [self migrateFileWithJavaIoFile:signedFile withJavaIoFile:outputFile];
}

- (jboolean)verifyVersionMatchWithJavaIoFile:(JavaIoFile *)signedFile {
  return NetI2pCryptoTrustedUpdate_verifyVersionMatchWithJavaIoFile_(self, signedFile);
}

- (NSString *)migrateFileWithJavaIoFile:(JavaIoFile *)signedFile
                         withJavaIoFile:(JavaIoFile *)outputFile {
  if (![((JavaIoFile *) nil_chk(signedFile)) exists]) return JreStrcat("$$", @"File not found: ", [signedFile getAbsolutePath]);
  JavaIoFileInputStream *fileInputStream = nil;
  JavaIoFileOutputStream *fileOutputStream = nil;
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithJavaIoFile_(signedFile);
    fileOutputStream = create_JavaIoFileOutputStream_initWithJavaIoFile_(outputFile);
    NetI2pDataDataHelper_skipWithJavaIoInputStream_withLong_(fileInputStream, NetI2pCryptoTrustedUpdate_HEADER_BYTES);
    NetI2pDataDataHelper_copy__WithJavaIoInputStream_withJavaIoOutputStream_(fileInputStream, fileOutputStream);
  }
  @catch (JavaIoIOException *ioe) {
    return JreStrcat("$@", @"Error copying update: ", ioe);
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (fileOutputStream != nil) @try {
      [fileOutputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return nil;
}

- (NetI2pDataSignature *)signWithNSString:(NSString *)inputFile
                             withNSString:(NSString *)signedFile
                             withNSString:(NSString *)privateKeyFile
                             withNSString:(NSString *)version_ {
  JavaIoFileInputStream *fileInputStream = nil;
  NetI2pDataSigningPrivateKey *signingPrivateKey = create_NetI2pDataSigningPrivateKey_init();
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithNSString_(privateKeyFile);
    [signingPrivateKey readBytesWithJavaIoInputStream:fileInputStream];
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to load the signing key" withJavaLangThrowable:ioe];
    return nil;
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to load the signing key" withJavaLangThrowable:dfe];
    return nil;
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return [self signWithNSString:inputFile withNSString:signedFile withNetI2pDataSigningPrivateKey:signingPrivateKey withNSString:version_];
}

- (NetI2pDataSignature *)signWithNSString:(NSString *)inputFile
                             withNSString:(NSString *)signedFile
          withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)signingPrivateKey
                             withNSString:(NSString *)version_ {
  IOSByteArray *versionHeader = [IOSByteArray arrayWithBytes:(jbyte[]){ (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00, (jint) 0x00 } count:16];
  IOSByteArray *versionRawBytes = nil;
  if ([((NSString *) nil_chk(version_)) java_length] > NetI2pCryptoTrustedUpdate_VERSION_BYTES) version_ = [version_ java_substring:0 endIndex:NetI2pCryptoTrustedUpdate_VERSION_BYTES];
  @try {
    versionRawBytes = [((NSString *) nil_chk(version_)) java_getBytesWithCharsetName:@"UTF-8"];
  }
  @catch (JavaIoUnsupportedEncodingException *e) {
    @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$$", @"your JVM doesnt support utf-8? ", [e getMessage]));
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(versionRawBytes, 0, versionHeader, 0, ((IOSByteArray *) nil_chk(versionRawBytes))->size_);
  JavaIoFileInputStream *fileInputStream = nil;
  NetI2pDataSignature *signature = nil;
  JavaIoSequenceInputStream *bytesToSignInputStream = nil;
  JavaIoByteArrayInputStream *versionHeaderInputStream = nil;
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithNSString_(inputFile);
    versionHeaderInputStream = create_JavaIoByteArrayInputStream_initWithByteArray_(versionHeader);
    bytesToSignInputStream = create_JavaIoSequenceInputStream_initWithJavaIoInputStream_withJavaIoInputStream_(versionHeaderInputStream, fileInputStream);
    signature = [((NetI2pCryptoDSAEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) dsa])) signWithJavaIoInputStream:bytesToSignInputStream withNetI2pDataSigningPrivateKey:signingPrivateKey];
  }
  @catch (JavaIoIOException *e) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Error signing" withJavaLangThrowable:e];
    return nil;
  }
  @finally {
    if (bytesToSignInputStream != nil) @try {
      [bytesToSignInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  JavaIoFileOutputStream *fileOutputStream = nil;
  @try {
    fileOutputStream = create_JavaIoFileOutputStream_initWithNSString_(signedFile);
    [fileOutputStream writeWithByteArray:[((NetI2pDataSignature *) nil_chk(signature)) getData]];
    [fileOutputStream writeWithByteArray:versionHeader];
    fileInputStream = create_JavaIoFileInputStream_initWithNSString_(inputFile);
    NetI2pDataDataHelper_copy__WithJavaIoInputStream_withJavaIoOutputStream_(fileInputStream, fileOutputStream);
    [fileOutputStream close];
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ logWithInt:NetI2pUtilLog_WARN withNSString:JreStrcat("$$", @"Error writing signed file ", signedFile) withJavaLangThrowable:ioe];
    return nil;
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
    if (fileOutputStream != nil) @try {
      [fileOutputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return signature;
}

- (jboolean)verifyWithJavaIoFile:(JavaIoFile *)signedFile {
  for (NetI2pDataSigningPublicKey * __strong signingPublicKey in nil_chk([((id<JavaUtilMap>) nil_chk(_trustedKeys_)) keySet])) {
    jboolean isValidSignature = [self verifyWithJavaIoFile:signedFile withNetI2pDataSigningPublicKey:signingPublicKey];
    if (isValidSignature) return true;
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"None of the keys match"];
  return false;
}

- (NSString *)verifyAndGetSignerWithJavaIoFile:(JavaIoFile *)signedFile {
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(_trustedKeys_)) entrySet])) {
    NetI2pDataSigningPublicKey *signingPublicKey = [((id<JavaUtilMap_Entry>) nil_chk(e)) getKey];
    jboolean isValidSignature = [self verifyWithJavaIoFile:signedFile withNetI2pDataSigningPublicKey:signingPublicKey];
    if (isValidSignature) return [e getValue];
  }
  return nil;
}

- (jboolean)verifyWithNSString:(NSString *)signedFile
                  withNSString:(NSString *)publicKeyFile {
  NetI2pDataSigningPublicKey *signingPublicKey = create_NetI2pDataSigningPublicKey_init();
  JavaIoFileInputStream *fileInputStream = nil;
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithNSString_(signedFile);
    [signingPublicKey readBytesWithJavaIoInputStream:fileInputStream];
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to load the signature" withJavaLangThrowable:ioe];
    return false;
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Unable to load the signature" withJavaLangThrowable:dfe];
    return false;
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return [self verifyWithJavaIoFile:create_JavaIoFile_initWithNSString_(signedFile) withNetI2pDataSigningPublicKey:signingPublicKey];
}

- (jboolean)verifyWithJavaIoFile:(JavaIoFile *)signedFile
  withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)signingPublicKey {
  JavaIoFileInputStream *fileInputStream = nil;
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithJavaIoFile_(signedFile);
    NetI2pDataSignature *signature = create_NetI2pDataSignature_init();
    [signature readBytesWithJavaIoInputStream:fileInputStream];
    return [((NetI2pCryptoDSAEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) dsa])) verifySignatureWithNetI2pDataSignature:signature withJavaIoInputStream:fileInputStream withNetI2pDataSigningPublicKey:signingPublicKey];
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@$", @"Error reading ", signedFile, @" to verify") withJavaLangThrowable:ioe];
    return false;
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Error reading the signature" withJavaLangThrowable:dfe];
    return false;
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_log_);
  RELEASE_(_trustedKeys_);
  RELEASE_(_newVersion_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LJavaUtilMap;", 0x1, -1, -1, -1, 1, -1, -1 },
    { NULL, "Z", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x19, 8, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 9, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1a, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 10, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 11, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 13, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 14, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1a, 15, 5, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 16, 17, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 16, 18, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 19, 20, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 21, 22, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 23, 17, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 24, 25, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 26, 12, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSignature;", 0x1, 26, 27, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 28, 17, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 29, 17, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 28, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 28, 30, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[2].selector = @selector(getKeys);
  methods[3].selector = @selector(addKeyWithNSString:withNSString:);
  methods[4].selector = @selector(haveKeyWithNSString:);
  methods[5].selector = @selector(mainWithNSStringArray:);
  methods[6].selector = @selector(needsUpdateWithNSString:withNSString:);
  methods[7].selector = @selector(genKeysCLIWithNSString:withNSString:);
  methods[8].selector = @selector(showUsageCLI);
  methods[9].selector = @selector(showVersionCLIWithNSString:);
  methods[10].selector = @selector(signCLIWithNSString:withNSString:withNSString:withNSString:);
  methods[11].selector = @selector(verifySigCLIWithNSString:);
  methods[12].selector = @selector(verifyUpdateCLIWithNSString:);
  methods[13].selector = @selector(verifyVersionCLIWithNSString:);
  methods[14].selector = @selector(getTrustedKeysString);
  methods[15].selector = @selector(getVersionStringWithJavaIoFile:);
  methods[16].selector = @selector(getVersionStringWithJavaIoInputStream:);
  methods[17].selector = @selector(newVersion);
  methods[18].selector = @selector(isUpdatedVersionWithNSString:withJavaIoFile:);
  methods[19].selector = @selector(migrateVerifiedWithNSString:withJavaIoFile:withJavaIoFile:);
  methods[20].selector = @selector(verifyVersionMatchWithJavaIoFile:);
  methods[21].selector = @selector(migrateFileWithJavaIoFile:withJavaIoFile:);
  methods[22].selector = @selector(signWithNSString:withNSString:withNSString:withNSString:);
  methods[23].selector = @selector(signWithNSString:withNSString:withNetI2pDataSigningPrivateKey:withNSString:);
  methods[24].selector = @selector(verifyWithJavaIoFile:);
  methods[25].selector = @selector(verifyAndGetSignerWithJavaIoFile:);
  methods[26].selector = @selector(verifyWithNSString:withNSString:);
  methods[27].selector = @selector(verifyWithJavaIoFile:withNetI2pDataSigningPublicKey:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_TRUSTED_KEY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 31, -1, -1 },
    { "DEFAULT_TRUSTED_KEY2", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 32, -1, -1 },
    { "DEFAULT_TRUSTED_KEY3", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 33, -1, -1 },
    { "DEFAULT_TRUSTED_KEY4", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 34, -1, -1 },
    { "DEFAULT_TRUSTED_KEY5", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 35, -1, -1 },
    { "VERSION_BYTES", "I", .constantValue.asInt = NetI2pCryptoTrustedUpdate_VERSION_BYTES, 0x1a, -1, -1, -1, -1 },
    { "HEADER_BYTES", "I", .constantValue.asLong = 0, 0x19, -1, 36, -1, -1 },
    { "PROP_TRUSTED_KEYS", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 37, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_trustedKeys_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 38, -1 },
    { "_newVersion_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "KEYSIZE_B64_BYTES", "I", .constantValue.asLong = 0, 0x1a, -1, 39, -1, -1 },
    { "DEFAULT_KEYS", "LJavaUtilMap;", .constantValue.asLong = 0, 0x1a, -1, 40, 41, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "()Ljava/util/Map<Lnet/i2p/data/SigningPublicKey;Ljava/lang/String;>;", "addKey", "LNSString;LNSString;", "haveKey", "LNSString;", "main", "[LNSString;", "needsUpdate", "genKeysCLI", "showVersionCLI", "signCLI", "LNSString;LNSString;LNSString;LNSString;", "verifySigCLI", "verifyUpdateCLI", "verifyVersionCLI", "getVersionString", "LJavaIoFile;", "LJavaIoInputStream;", "isUpdatedVersion", "LNSString;LJavaIoFile;", "migrateVerified", "LNSString;LJavaIoFile;LJavaIoFile;", "verifyVersionMatch", "migrateFile", "LJavaIoFile;LJavaIoFile;", "sign", "LNSString;LNSString;LNetI2pDataSigningPrivateKey;LNSString;", "verify", "verifyAndGetSigner", "LJavaIoFile;LNetI2pDataSigningPublicKey;", &NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY, &NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY2, &NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY3, &NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY4, &NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY5, &NetI2pCryptoTrustedUpdate_HEADER_BYTES, &NetI2pCryptoTrustedUpdate_PROP_TRUSTED_KEYS, "Ljava/util/Map<Lnet/i2p/data/SigningPublicKey;Ljava/lang/String;>;", &NetI2pCryptoTrustedUpdate_KEYSIZE_B64_BYTES, &NetI2pCryptoTrustedUpdate_DEFAULT_KEYS, "Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;" };
  static const J2ObjcClassInfo _NetI2pCryptoTrustedUpdate = { "TrustedUpdate", "net.i2p.crypto", ptrTable, methods, fields, 7, 0x1, 28, 14, -1, -1, -1, -1, -1 };
  return &_NetI2pCryptoTrustedUpdate;
}

+ (void)initialize {
  if (self == [NetI2pCryptoTrustedUpdate class]) {
    NetI2pCryptoTrustedUpdate_HEADER_BYTES = JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES) + NetI2pCryptoTrustedUpdate_VERSION_BYTES;
    NetI2pCryptoTrustedUpdate_KEYSIZE_B64_BYTES = 2 + (JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES) * 4 / 3);
    JreStrongAssignAndConsume(&NetI2pCryptoTrustedUpdate_DEFAULT_KEYS, new_JavaUtilHashMap_initWithInt_(4));
    {
      [NetI2pCryptoTrustedUpdate_DEFAULT_KEYS putWithId:NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY2 withId:@"zzz@mail.i2p"];
      [NetI2pCryptoTrustedUpdate_DEFAULT_KEYS putWithId:NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY4 withId:@"HungryHobo@mail.i2p"];
      [NetI2pCryptoTrustedUpdate_DEFAULT_KEYS putWithId:NetI2pCryptoTrustedUpdate_DEFAULT_TRUSTED_KEY5 withId:@"killyourtv@mail.i2p"];
    }
    J2OBJC_SET_INITIALIZED(NetI2pCryptoTrustedUpdate)
  }
}

@end

void NetI2pCryptoTrustedUpdate_init(NetI2pCryptoTrustedUpdate *self) {
  NetI2pCryptoTrustedUpdate_initWithNetI2pI2PAppContext_(self, NetI2pI2PAppContext_getGlobalContext());
}

NetI2pCryptoTrustedUpdate *new_NetI2pCryptoTrustedUpdate_init() {
  J2OBJC_NEW_IMPL(NetI2pCryptoTrustedUpdate, init)
}

NetI2pCryptoTrustedUpdate *create_NetI2pCryptoTrustedUpdate_init() {
  J2OBJC_CREATE_IMPL(NetI2pCryptoTrustedUpdate, init)
}

void NetI2pCryptoTrustedUpdate_initWithNetI2pI2PAppContext_(NetI2pCryptoTrustedUpdate *self, NetI2pI2PAppContext *context) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) logManager])) getLogWithIOSClass:NetI2pCryptoTrustedUpdate_class_()]);
  JreStrongAssignAndConsume(&self->_trustedKeys_, new_JavaUtilHashMap_initWithInt_(4));
  NSString *propertyTrustedKeys = [((NetI2pI2PAppContext *) nil_chk(context)) getPropertyWithNSString:NetI2pCryptoTrustedUpdate_PROP_TRUSTED_KEYS];
  if ((propertyTrustedKeys != nil) && ([((NSString *) nil_chk(propertyTrustedKeys)) java_length] > 0)) {
    JavaUtilStringTokenizer *propertyTrustedKeysTokens = create_JavaUtilStringTokenizer_initWithNSString_withNSString_(propertyTrustedKeys, @" ,\x0d\n");
    while ([propertyTrustedKeysTokens hasMoreTokens]) {
      NSString *key = [((NSString *) nil_chk([propertyTrustedKeysTokens nextToken])) java_trim];
      NSString *name = [((id<JavaUtilMap>) nil_chk(NetI2pCryptoTrustedUpdate_DEFAULT_KEYS)) getWithId:key];
      if (name == nil) name = @"";
      [self addKeyWithNSString:key withNSString:name];
    }
  }
  else {
    for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(NetI2pCryptoTrustedUpdate_DEFAULT_KEYS)) entrySet])) {
      [self addKeyWithNSString:[((id<JavaUtilMap_Entry>) nil_chk(e)) getKey] withNSString:[e getValue]];
    }
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$I$", @"TrustedUpdate created, trusting ", [self->_trustedKeys_ size], @" keys.")];
}

NetI2pCryptoTrustedUpdate *new_NetI2pCryptoTrustedUpdate_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_NEW_IMPL(NetI2pCryptoTrustedUpdate, initWithNetI2pI2PAppContext_, context)
}

NetI2pCryptoTrustedUpdate *create_NetI2pCryptoTrustedUpdate_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pCryptoTrustedUpdate, initWithNetI2pI2PAppContext_, context)
}

void NetI2pCryptoTrustedUpdate_mainWithNSStringArray_(IOSObjectArray *args) {
  NetI2pCryptoTrustedUpdate_initialize();
  jboolean ok = false;
  @try {
    if ([@"keygen" isEqual:IOSObjectArray_Get(nil_chk(args), 0)]) {
      ok = NetI2pCryptoTrustedUpdate_genKeysCLIWithNSString_withNSString_(IOSObjectArray_Get(args, 1), IOSObjectArray_Get(args, 2));
    }
    else if ([@"showversion" isEqual:IOSObjectArray_Get(args, 0)]) {
      ok = NetI2pCryptoTrustedUpdate_showVersionCLIWithNSString_(IOSObjectArray_Get(args, 1));
    }
    else if ([@"sign" isEqual:IOSObjectArray_Get(args, 0)]) {
      ok = NetI2pCryptoTrustedUpdate_signCLIWithNSString_withNSString_withNSString_withNSString_(IOSObjectArray_Get(args, 1), IOSObjectArray_Get(args, 2), IOSObjectArray_Get(args, 3), IOSObjectArray_Get(args, 4));
    }
    else if ([@"verifysig" isEqual:IOSObjectArray_Get(args, 0)]) {
      ok = NetI2pCryptoTrustedUpdate_verifySigCLIWithNSString_(IOSObjectArray_Get(args, 1));
    }
    else if ([@"verifyupdate" isEqual:IOSObjectArray_Get(args, 0)]) {
      ok = NetI2pCryptoTrustedUpdate_verifyUpdateCLIWithNSString_(IOSObjectArray_Get(args, 1));
    }
    else if ([@"verifyversion" isEqual:IOSObjectArray_Get(args, 0)]) {
      ok = NetI2pCryptoTrustedUpdate_verifyVersionCLIWithNSString_(IOSObjectArray_Get(args, 1));
    }
    else {
      NetI2pCryptoTrustedUpdate_showUsageCLI();
    }
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *aioobe) {
    NetI2pCryptoTrustedUpdate_showUsageCLI();
  }
  if (!ok) JavaLangSystem_exitWithInt_(1);
}

jboolean NetI2pCryptoTrustedUpdate_needsUpdateWithNSString_withNSString_(NSString *currentVersion, NSString *newVersion) {
  NetI2pCryptoTrustedUpdate_initialize();
  return NetI2pUtilVersionComparator_compWithNSString_withNSString_(currentVersion, newVersion) < 0;
}

jboolean NetI2pCryptoTrustedUpdate_genKeysCLIWithNSString_withNSString_(NSString *publicKeyFile, NSString *privateKeyFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  JavaIoFile *pubFile = create_JavaIoFile_initWithNSString_(publicKeyFile);
  JavaIoFile *privFile = create_JavaIoFile_initWithNSString_(privateKeyFile);
  if ([pubFile exists]) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Error: Not overwriting file ", publicKeyFile)];
    return false;
  }
  if ([privFile exists]) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Error: Not overwriting file ", privateKeyFile)];
    return false;
  }
  JavaIoFileOutputStream *fileOutputStream = nil;
  NetI2pI2PAppContext *context = NetI2pI2PAppContext_getGlobalContext();
  @try {
    IOSObjectArray *signingKeypair = [((NetI2pCryptoKeyGenerator *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) keyGenerator])) generateSigningKeypair];
    NetI2pDataSigningPublicKey *signingPublicKey = (NetI2pDataSigningPublicKey *) cast_chk(IOSObjectArray_Get(nil_chk(signingKeypair), 0), [NetI2pDataSigningPublicKey class]);
    NetI2pDataSigningPrivateKey *signingPrivateKey = (NetI2pDataSigningPrivateKey *) cast_chk(IOSObjectArray_Get(signingKeypair, 1), [NetI2pDataSigningPrivateKey class]);
    fileOutputStream = create_NetI2pUtilSecureFileOutputStream_initWithJavaIoFile_(pubFile);
    [((NetI2pDataSigningPublicKey *) nil_chk(signingPublicKey)) writeBytesWithJavaIoOutputStream:fileOutputStream];
    [fileOutputStream close];
    fileOutputStream = nil;
    fileOutputStream = create_NetI2pUtilSecureFileOutputStream_initWithJavaIoFile_(privFile);
    [((NetI2pDataSigningPrivateKey *) nil_chk(signingPrivateKey)) writeBytesWithJavaIoOutputStream:fileOutputStream];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"\x0d\nPrivate key written to: ", privateKeyFile)];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Public key written to: ", publicKeyFile)];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"\x0d\nPublic key: ", [signingPublicKey toBase64], @"\x0d\n")];
  }
  @catch (JavaIoIOException *e) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"Error writing keys:"];
    [e printStackTrace];
    return false;
  }
  @catch (NetI2pDataDataFormatException *e) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"Error writing keys:"];
    [e printStackTrace];
    return false;
  }
  @finally {
    if (fileOutputStream != nil) @try {
      [fileOutputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  return true;
}

void NetI2pCryptoTrustedUpdate_showUsageCLI() {
  NetI2pCryptoTrustedUpdate_initialize();
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"Usage: TrustedUpdate keygen        publicKeyFile privateKeyFile"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"       TrustedUpdate showversion   signedFile"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"       TrustedUpdate sign          inputFile signedFile privateKeyFile version"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"       TrustedUpdate verifysig     signedFile"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"       TrustedUpdate verifyupdate  signedFile"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:@"       TrustedUpdate verifyversion signedFile"];
}

jboolean NetI2pCryptoTrustedUpdate_showVersionCLIWithNSString_(NSString *signedFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  NSString *versionString = NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoFile_(create_JavaIoFile_initWithNSString_(signedFile));
  if ([((NSString *) nil_chk(versionString)) isEqual:@""]) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"No version string found in file '", signedFile, '\'')];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Version: ", versionString)];
  return ![versionString isEqual:@""];
}

jboolean NetI2pCryptoTrustedUpdate_signCLIWithNSString_withNSString_withNSString_withNSString_(NSString *inputFile, NSString *signedFile, NSString *privateKeyFile, NSString *version_) {
  NetI2pCryptoTrustedUpdate_initialize();
  NetI2pDataSignature *signature = [create_NetI2pCryptoTrustedUpdate_init() signWithNSString:inputFile withNSString:signedFile withNSString:privateKeyFile withNSString:version_];
  if (signature != nil) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$$C", @"Input file '", inputFile, @"' signed and written to '", signedFile, '\'')];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$C", @"Error signing input file '", inputFile, '\'')];
  return signature != nil;
}

jboolean NetI2pCryptoTrustedUpdate_verifySigCLIWithNSString_(NSString *signedFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  jboolean isValidSignature = [create_NetI2pCryptoTrustedUpdate_init() verifyWithJavaIoFile:create_JavaIoFile_initWithNSString_(signedFile)];
  if (isValidSignature) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Signature VALID"];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Signature INVALID"];
  return isValidSignature;
}

jboolean NetI2pCryptoTrustedUpdate_verifyUpdateCLIWithNSString_(NSString *signedFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  jboolean isUpdate = [create_NetI2pCryptoTrustedUpdate_init() isUpdatedVersionWithNSString:NetI2pCoreVersion_VERSION withJavaIoFile:create_JavaIoFile_initWithNSString_(signedFile)];
  if (isUpdate) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"File version is newer than current version."];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"File version is older than or equal to current version."];
  return isUpdate;
}

jboolean NetI2pCryptoTrustedUpdate_verifyVersionCLIWithNSString_(NSString *signedFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  NetI2pCryptoTrustedUpdate *tu = create_NetI2pCryptoTrustedUpdate_init();
  JavaIoFile *file = create_JavaIoFile_initWithNSString_(signedFile);
  [tu isUpdatedVersionWithNSString:@"0" withJavaIoFile:file];
  jboolean isMatch = NetI2pCryptoTrustedUpdate_verifyVersionMatchWithJavaIoFile_(tu, file);
  if (isMatch) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Version verified"];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Version mismatch, header version does not match zip comment version"];
  return isMatch;
}

NSString *NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoFile_(JavaIoFile *signedFile) {
  NetI2pCryptoTrustedUpdate_initialize();
  JavaIoFileInputStream *fileInputStream = nil;
  @try {
    fileInputStream = create_JavaIoFileInputStream_initWithJavaIoFile_(signedFile);
    NetI2pDataDataHelper_skipWithJavaIoInputStream_withLong_(fileInputStream, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES));
    IOSByteArray *data = [IOSByteArray arrayWithLength:NetI2pCryptoTrustedUpdate_VERSION_BYTES];
    jint bytesRead = NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(fileInputStream, data);
    if (bytesRead != NetI2pCryptoTrustedUpdate_VERSION_BYTES) {
      return @"";
    }
    for (jint i = 0; i < NetI2pCryptoTrustedUpdate_VERSION_BYTES; i++) if (IOSByteArray_Get(data, i) == (jint) 0x00) {
      return [NSString java_stringWithBytes:data offset:0 length:i charsetName:@"UTF-8"];
    }
    return [NSString java_stringWithBytes:data charsetName:@"UTF-8"];
  }
  @catch (JavaIoUnsupportedEncodingException *uee) {
    @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$$", @"your JVM doesnt support utf-8? ", [uee getMessage]));
  }
  @catch (JavaIoIOException *ioe) {
    return @"";
  }
  @finally {
    if (fileInputStream != nil) @try {
      [fileInputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
}

NSString *NetI2pCryptoTrustedUpdate_getVersionStringWithJavaIoInputStream_(JavaIoInputStream *inputStream) {
  NetI2pCryptoTrustedUpdate_initialize();
  @try {
    NetI2pDataDataHelper_skipWithJavaIoInputStream_withLong_(inputStream, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES));
    IOSByteArray *data = [IOSByteArray arrayWithLength:NetI2pCryptoTrustedUpdate_VERSION_BYTES];
    jint bytesRead = NetI2pDataDataHelper_readWithJavaIoInputStream_withByteArray_(inputStream, data);
    if (bytesRead != NetI2pCryptoTrustedUpdate_VERSION_BYTES) {
      return @"";
    }
    for (jint i = 0; i < NetI2pCryptoTrustedUpdate_VERSION_BYTES; i++) if (IOSByteArray_Get(data, i) == (jint) 0x00) {
      return [NSString java_stringWithBytes:data offset:0 length:i charsetName:@"UTF-8"];
    }
    return [NSString java_stringWithBytes:data charsetName:@"UTF-8"];
  }
  @catch (JavaIoUnsupportedEncodingException *uee) {
    @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$$", @"your JVM doesnt support utf-8? ", [uee getMessage]));
  }
  @catch (JavaIoIOException *ioe) {
    return @"";
  }
  @finally {
    if (inputStream != nil) @try {
      [inputStream close];
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
}

jboolean NetI2pCryptoTrustedUpdate_verifyVersionMatchWithJavaIoFile_(NetI2pCryptoTrustedUpdate *self, JavaIoFile *signedFile) {
  @try {
    NSString *zipComment = NetI2pUtilZipFileComment_getCommentWithJavaIoFile_withInt_withInt_(signedFile, NetI2pCryptoTrustedUpdate_VERSION_BYTES, NetI2pCryptoTrustedUpdate_HEADER_BYTES);
    return [((NSString *) nil_chk(zipComment)) isEqual:self->_newVersion_];
  }
  @catch (JavaIoIOException *ioe) {
  }
  return false;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pCryptoTrustedUpdate)
