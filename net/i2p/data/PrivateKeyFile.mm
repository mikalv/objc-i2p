//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/PrivateKeyFile.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/nettgryppa/security/HashCash.h"
#include "gnu/getopt/Getopt.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/OutputStreamWriter.h"
#include "java/io/PrintStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/security/GeneralSecurityException.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/util/Map.h"
#include "java/util/Properties.h"
#include "java/util/Set.h"
#include "net/i2p/I2PException.h"
#include "net/i2p/client/I2PClient.h"
#include "net/i2p/client/I2PClientFactory.h"
#include "net/i2p/client/I2PSession.h"
#include "net/i2p/client/naming/HostTxtEntry.h"
#include "net/i2p/crypto/DSAEngine.h"
#include "net/i2p/crypto/KeyGenerator.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/Base32.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/KeyCertificate.h"
#include "net/i2p/data/PrivateKey.h"
#include "net/i2p/data/PrivateKeyFile.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/SimpleDataStructure.h"
#include "net/i2p/data/VerifiedDestination.h"
#include "net/i2p/util/OrderedProperties.h"
#include "net/i2p/util/RandomSource.h"
#include "net/i2p/util/SecureFileOutputStream.h"

@interface NetI2pDataPrivateKeyFile () {
 @public
  id<NetI2pClientI2PClient> client_;
}

+ (void)usage;

@end

J2OBJC_FIELD_SETTER(NetI2pDataPrivateKeyFile, client_, id<NetI2pClientI2PClient>)

inline jint NetI2pDataPrivateKeyFile_get_HASH_EFFORT(void);
#define NetI2pDataPrivateKeyFile_HASH_EFFORT 20
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataPrivateKeyFile, HASH_EFFORT, jint)

__attribute__((unused)) static void NetI2pDataPrivateKeyFile_usage(void);

@implementation NetI2pDataPrivateKeyFile

+ (void)mainWithNSStringArray:(IOSObjectArray *)args {
  NetI2pDataPrivateKeyFile_mainWithNSStringArray_(args);
}

+ (void)usage {
  NetI2pDataPrivateKeyFile_usage();
}

- (instancetype)initWithNSString:(NSString *)file {
  NetI2pDataPrivateKeyFile_initWithNSString_(self, file);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_(self, file);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
         withNetI2pClientI2PClient:(id<NetI2pClientI2PClient>)client {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(self, file, client);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
        withNetI2pClientI2PSession:(id<NetI2pClientI2PSession>)session {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PSession_(self, file, session);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
         withNetI2pDataDestination:(NetI2pDataDestination *)dest
          withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)pk
   withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)spk {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(self, file, dest, pk, spk);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
           withNetI2pDataPublicKey:(NetI2pDataPublicKey *)pubkey
    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)spubkey
         withNetI2pDataCertificate:(NetI2pDataCertificate *)cert
          withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)pk
   withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)spk {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(self, file, pubkey, spubkey, cert, pk, spk);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
           withNetI2pDataPublicKey:(NetI2pDataPublicKey *)pubkey
    withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)spubkey
         withNetI2pDataCertificate:(NetI2pDataCertificate *)cert
          withNetI2pDataPrivateKey:(NetI2pDataPrivateKey *)pk
   withNetI2pDataSigningPrivateKey:(NetI2pDataSigningPrivateKey *)spk
                     withByteArray:(IOSByteArray *)padding {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_(self, file, pubkey, spubkey, cert, pk, spk, padding);
  return self;
}

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  NetI2pDataPrivateKeyFile_initWithJavaIoInputStream_(self, inArg);
  return self;
}

- (NetI2pDataDestination *)createIfAbsent {
  return [self createIfAbsentWithNetI2pCryptoSigType:JreLoadStatic(NetI2pClientI2PClient, DEFAULT_SIGTYPE)];
}

- (NetI2pDataDestination *)createIfAbsentWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  if (![((JavaIoFile *) nil_chk(self->file_)) exists]) {
    JavaIoOutputStream *out = nil;
    @try {
      out = create_NetI2pUtilSecureFileOutputStream_initWithJavaIoFile_(self->file_);
      if (self->client_ != nil) [self->client_ createDestinationWithJavaIoOutputStream:out withNetI2pCryptoSigType:type];
      else [self write];
    }
    @finally {
      if (out != nil) {
        @try {
          [out close];
        }
        @catch (JavaIoIOException *ioe) {
        }
      }
    }
  }
  return [self getDestination];
}

- (NetI2pDataDestination *)getDestination {
  if (dest_ == nil) {
    id<NetI2pClientI2PSession> s = [self open];
    if (s != nil) {
      JreStrongAssignAndConsume(&self->dest_, new_NetI2pDataVerifiedDestination_initWithNetI2pDataDestination_([s getMyDestination]));
      JreStrongAssign(&self->privKey_, [s getDecryptionKey]);
      JreStrongAssign(&self->signingPrivKey_, [s getPrivateKey]);
    }
  }
  return self->dest_;
}

- (void)setDestinationWithNetI2pDataDestination:(NetI2pDataDestination *)d {
  JreStrongAssign(&self->dest_, d);
}

- (NetI2pDataCertificate *)setCertTypeWithInt:(jint)t {
  if (self->dest_ == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Dest is null");
  NetI2pDataCertificate *c = create_NetI2pDataCertificate_init();
  [c setCertificateTypeWithInt:t];
  NetI2pDataDestination *newdest = create_NetI2pDataDestination_init();
  [newdest setPublicKeyWithNetI2pDataPublicKey:[((NetI2pDataDestination *) nil_chk(dest_)) getPublicKey]];
  [newdest setSigningPublicKeyWithNetI2pDataSigningPublicKey:[((NetI2pDataDestination *) nil_chk(dest_)) getSigningPublicKey]];
  [newdest setCertificateWithNetI2pDataCertificate:c];
  JreStrongAssign(&dest_, newdest);
  return c;
}

- (NetI2pDataCertificate *)setKeyCertWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  if (type == JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) return [self setCertTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_NULL];
  if (dest_ == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Dest is null");
  NetI2pDataKeyCertificate *c = create_NetI2pDataKeyCertificate_initWithNetI2pCryptoSigType_(type);
  IOSObjectArray *signingKeys;
  @try {
    signingKeys = [((NetI2pCryptoKeyGenerator *) nil_chk(NetI2pCryptoKeyGenerator_getInstance())) generateSigningKeysWithNetI2pCryptoSigType:type];
  }
  @catch (JavaSecurityGeneralSecurityException *gse) {
    @throw create_JavaLangRuntimeException_initWithNSString_withJavaLangThrowable_(@"keygen fail", gse);
  }
  NetI2pDataSigningPublicKey *signingPubKey = (NetI2pDataSigningPublicKey *) cast_chk(IOSObjectArray_Get(nil_chk(signingKeys), 0), [NetI2pDataSigningPublicKey class]);
  JreStrongAssign(&signingPrivKey_, (NetI2pDataSigningPrivateKey *) cast_chk(IOSObjectArray_Get(signingKeys, 1), [NetI2pDataSigningPrivateKey class]));
  NetI2pDataDestination *newdest = create_NetI2pDataDestination_init();
  [newdest setPublicKeyWithNetI2pDataPublicKey:[((NetI2pDataDestination *) nil_chk(dest_)) getPublicKey]];
  [newdest setSigningPublicKeyWithNetI2pDataSigningPublicKey:signingPubKey];
  jint len = [((NetI2pCryptoSigType *) nil_chk(type)) getPubkeyLen];
  if (len < 128) {
    IOSByteArray *pad = [IOSByteArray arrayWithLength:128 - len];
    [((NetI2pUtilRandomSource *) nil_chk(NetI2pUtilRandomSource_getInstance())) nextBytesWithByteArray:pad];
    [newdest setPaddingWithByteArray:pad];
  }
  else if (len > 128) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSigningPublicKey *) nil_chk(signingPubKey)) getData], 128, [c getPayload], NetI2pDataKeyCertificate_HEADER_LENGTH, len - 128);
  }
  [newdest setCertificateWithNetI2pDataCertificate:c];
  JreStrongAssign(&dest_, newdest);
  return c;
}

- (NetI2pDataCertificate *)setHashCashCertWithInt:(jint)effort {
  NetI2pDataCertificate *c = [self setCertTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_HASHCASH];
  jlong begin = JavaLangSystem_currentTimeMillis();
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Starting hashcash generation now..."];
  NSString *resource = JreStrcat("$$", [((NetI2pDataPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->dest_)) getPublicKey])) toBase64], [((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->dest_)) getSigningPublicKey])) toBase64]);
  ComNettgryppaSecurityHashCash *hc;
  @try {
    hc = ComNettgryppaSecurityHashCash_mintCashWithNSString_withInt_(resource, effort);
  }
  @catch (JavaSecurityNoSuchAlgorithmException *e) {
    return nil;
  }
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Generation took: ", NetI2pDataDataHelper_formatDurationWithLong_(JavaLangSystem_currentTimeMillis() - begin))];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Full Hashcash is: ", hc)];
  NSString *hcs = [((ComNettgryppaSecurityHashCash *) nil_chk(hc)) description];
  jint end1 = 0;
  for (jint i = 0; i < 3; i++) {
    end1 = 1 + [((NSString *) nil_chk(hcs)) java_indexOf:':' fromIndex:end1];
    if (end1 < 0) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Bad hashcash"];
      return nil;
    }
  }
  jint start2 = [((NSString *) nil_chk(hcs)) java_indexOf:':' fromIndex:end1];
  if (start2 < 0) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Bad hashcash"];
    return nil;
  }
  hcs = JreStrcat("$$", [hcs java_substring:0 endIndex:end1], [hcs java_substring:start2]);
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$", @"Short Hashcash is: ", hcs)];
  [((NetI2pDataCertificate *) nil_chk(c)) setPayloadWithByteArray:NetI2pDataDataHelper_getUTF8WithNSString_(hcs)];
  return c;
}

- (NetI2pDataCertificate *)setSignedCertWithNetI2pDataPrivateKeyFile:(NetI2pDataPrivateKeyFile *)pkf2 {
  NetI2pDataCertificate *c = [self setCertTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_SIGNED];
  NetI2pDataDestination *d2;
  @try {
    d2 = [((NetI2pDataPrivateKeyFile *) nil_chk(pkf2)) getDestination];
  }
  @catch (NetI2pI2PException *e) {
    return nil;
  }
  @catch (JavaIoIOException *e) {
    return nil;
  }
  if (d2 == nil) return nil;
  NetI2pDataSigningPrivateKey *spk2 = [pkf2 getSigningPrivKey];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Signing With Dest:"];
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:[pkf2 description]];
  jint len = NetI2pDataPublicKey_KEYSIZE_BYTES + JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES);
  IOSByteArray *data = [IOSByteArray arrayWithLength:len];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->dest_)) getPublicKey])) getData], 0, data, 0, NetI2pDataPublicKey_KEYSIZE_BYTES);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->dest_)) getSigningPublicKey])) getData], 0, data, NetI2pDataPublicKey_KEYSIZE_BYTES, JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES));
  IOSByteArray *payload = [IOSByteArray arrayWithLength:NetI2pDataHash_HASH_LENGTH + JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES)];
  NetI2pDataSignature *sign = [((NetI2pCryptoDSAEngine *) nil_chk(NetI2pCryptoDSAEngine_getInstance())) signWithJavaIoInputStream:create_JavaIoByteArrayInputStream_initWithByteArray_(data) withNetI2pDataSigningPrivateKey:spk2];
  if (sign == nil) return nil;
  IOSByteArray *sig = [sign getData];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(sig, 0, payload, 0, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES));
  IOSByteArray *h2 = [((NetI2pDataHash *) nil_chk([d2 calculateHash])) getData];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(h2, 0, payload, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES), NetI2pDataHash_HASH_LENGTH);
  [((NetI2pDataCertificate *) nil_chk(c)) setCertificateTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_SIGNED];
  [c setPayloadWithByteArray:payload];
  return c;
}

- (NetI2pDataPrivateKey *)getPrivKey {
  @try {
    [self getDestination];
  }
  @catch (JavaLangException *e) {
    return nil;
  }
  return self->privKey_;
}

- (NetI2pDataSigningPrivateKey *)getSigningPrivKey {
  @try {
    [self getDestination];
  }
  @catch (JavaLangException *e) {
    return nil;
  }
  return self->signingPrivKey_;
}

- (id<NetI2pClientI2PSession>)open {
  return [self openWithJavaUtilProperties:create_JavaUtilProperties_init()];
}

- (id<NetI2pClientI2PSession>)openWithJavaUtilProperties:(JavaUtilProperties *)opts {
  JavaIoInputStream *in = nil;
  @try {
    in = create_JavaIoBufferedInputStream_initWithJavaIoInputStream_(create_JavaIoFileInputStream_initWithJavaIoFile_(self->file_));
    id<NetI2pClientI2PSession> s = [((id<NetI2pClientI2PClient>) nil_chk(self->client_)) createSessionWithJavaIoInputStream:in withJavaUtilProperties:opts];
    return s;
  }
  @finally {
    if (in != nil) {
      @try {
        [in close];
      }
      @catch (JavaIoIOException *ioe) {
      }
    }
  }
}

- (void)write {
  JavaIoOutputStream *out = nil;
  @try {
    out = create_NetI2pUtilSecureFileOutputStream_initWithJavaIoFile_(self->file_);
    [((NetI2pDataDestination *) nil_chk(self->dest_)) writeBytesWithJavaIoOutputStream:out];
    [((NetI2pDataPrivateKey *) nil_chk(self->privKey_)) writeBytesWithJavaIoOutputStream:out];
    [((NetI2pDataSigningPrivateKey *) nil_chk(self->signingPrivKey_)) writeBytesWithJavaIoOutputStream:out];
  }
  @finally {
    if (out != nil) {
      @try {
        [out close];
      }
      @catch (JavaIoIOException *ioe) {
      }
    }
  }
}

- (jboolean)validateKeyPairs {
  @try {
    if (![((NetI2pDataPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(dest_)) getPublicKey])) isEqual:NetI2pCryptoKeyGenerator_getPublicKeyWithNetI2pDataPrivateKey_(privKey_)]) return false;
    return [((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(dest_)) getSigningPublicKey])) isEqual:NetI2pCryptoKeyGenerator_getSigningPublicKeyWithNetI2pDataSigningPrivateKey_(signingPrivKey_)];
  }
  @catch (JavaLangIllegalArgumentException *iae) {
    return false;
  }
}

- (NSString *)description {
  JavaLangStringBuilder *s = create_JavaLangStringBuilder_initWithInt_(128);
  [s appendWithNSString:@"Dest: "];
  [s appendWithNSString:self->dest_ != nil ? [self->dest_ toBase64] : @"null"];
  [s appendWithNSString:@"\nB32: "];
  [s appendWithNSString:self->dest_ != nil ? [self->dest_ toBase32] : @"null"];
  [s appendWithNSString:@"\nContains: "];
  [s appendWithId:self->dest_];
  [s appendWithNSString:@"\nPrivate Key: "];
  [s appendWithId:self->privKey_];
  [s appendWithNSString:@"\nSigining Private Key: "];
  [s appendWithId:self->signingPrivKey_];
  [s appendWithNSString:@"\n"];
  return [s description];
}

+ (NSString *)estimateHashCashTimeWithInt:(jint)hashEffort {
  return NetI2pDataPrivateKeyFile_estimateHashCashTimeWithInt_(hashEffort);
}

+ (jboolean)verifySignatureWithNetI2pDataDestination:(NetI2pDataDestination *)d {
  return NetI2pDataPrivateKeyFile_verifySignatureWithNetI2pDataDestination_(d);
}

+ (jboolean)checkSignatureWithNetI2pDataSignature:(NetI2pDataSignature *)s
                                    withByteArray:(IOSByteArray *)data
                   withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)spk {
  return NetI2pDataPrivateKeyFile_checkSignatureWithNetI2pDataSignature_withByteArray_withNetI2pDataSigningPublicKey_(s, data, spk);
}

- (void)dealloc {
  RELEASE_(file_);
  RELEASE_(client_);
  RELEASE_(dest_);
  RELEASE_(privKey_);
  RELEASE_(signingPrivKey_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0xa, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 4, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 6, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 7, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 8, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 9, 10, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, -1, -1, 11, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, 12, 13, 11, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, -1, -1, 14, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataCertificate;", 0x1, 17, 18, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataCertificate;", 0x1, 19, 13, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataCertificate;", 0x1, 20, 18, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataCertificate;", 0x1, 21, 22, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataPrivateKey;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSigningPrivateKey;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pClientI2PSession;", 0x1, -1, -1, 23, -1, -1, -1 },
    { NULL, "LNetI2pClientI2PSession;", 0x1, 24, 25, 23, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 26, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 27, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 28, 18, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 29, 16, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 30, 31, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(mainWithNSStringArray:);
  methods[1].selector = @selector(usage);
  methods[2].selector = @selector(initWithNSString:);
  methods[3].selector = @selector(initWithJavaIoFile:);
  methods[4].selector = @selector(initWithJavaIoFile:withNetI2pClientI2PClient:);
  methods[5].selector = @selector(initWithJavaIoFile:withNetI2pClientI2PSession:);
  methods[6].selector = @selector(initWithJavaIoFile:withNetI2pDataDestination:withNetI2pDataPrivateKey:withNetI2pDataSigningPrivateKey:);
  methods[7].selector = @selector(initWithJavaIoFile:withNetI2pDataPublicKey:withNetI2pDataSigningPublicKey:withNetI2pDataCertificate:withNetI2pDataPrivateKey:withNetI2pDataSigningPrivateKey:);
  methods[8].selector = @selector(initWithJavaIoFile:withNetI2pDataPublicKey:withNetI2pDataSigningPublicKey:withNetI2pDataCertificate:withNetI2pDataPrivateKey:withNetI2pDataSigningPrivateKey:withByteArray:);
  methods[9].selector = @selector(initWithJavaIoInputStream:);
  methods[10].selector = @selector(createIfAbsent);
  methods[11].selector = @selector(createIfAbsentWithNetI2pCryptoSigType:);
  methods[12].selector = @selector(getDestination);
  methods[13].selector = @selector(setDestinationWithNetI2pDataDestination:);
  methods[14].selector = @selector(setCertTypeWithInt:);
  methods[15].selector = @selector(setKeyCertWithNetI2pCryptoSigType:);
  methods[16].selector = @selector(setHashCashCertWithInt:);
  methods[17].selector = @selector(setSignedCertWithNetI2pDataPrivateKeyFile:);
  methods[18].selector = @selector(getPrivKey);
  methods[19].selector = @selector(getSigningPrivKey);
  methods[20].selector = @selector(open);
  methods[21].selector = @selector(openWithJavaUtilProperties:);
  methods[22].selector = @selector(write);
  methods[23].selector = @selector(validateKeyPairs);
  methods[24].selector = @selector(description);
  methods[25].selector = @selector(estimateHashCashTimeWithInt:);
  methods[26].selector = @selector(verifySignatureWithNetI2pDataDestination:);
  methods[27].selector = @selector(checkSignatureWithNetI2pDataSignature:withByteArray:withNetI2pDataSigningPublicKey:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "HASH_EFFORT", "I", .constantValue.asInt = NetI2pDataPrivateKeyFile_HASH_EFFORT, 0x1a, -1, -1, -1, -1 },
    { "file_", "LJavaIoFile;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "client_", "LNetI2pClientI2PClient;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "dest_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "privKey_", "LNetI2pDataPrivateKey;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "signingPrivKey_", "LNetI2pDataSigningPrivateKey;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "main", "[LNSString;", "LNSString;", "LJavaIoFile;", "LJavaIoFile;LNetI2pClientI2PClient;", "LJavaIoFile;LNetI2pClientI2PSession;", "LJavaIoFile;LNetI2pDataDestination;LNetI2pDataPrivateKey;LNetI2pDataSigningPrivateKey;", "LJavaIoFile;LNetI2pDataPublicKey;LNetI2pDataSigningPublicKey;LNetI2pDataCertificate;LNetI2pDataPrivateKey;LNetI2pDataSigningPrivateKey;", "LJavaIoFile;LNetI2pDataPublicKey;LNetI2pDataSigningPublicKey;LNetI2pDataCertificate;LNetI2pDataPrivateKey;LNetI2pDataSigningPrivateKey;[B", "LJavaIoInputStream;", "LNetI2pClientI2PSessionException;", "LNetI2pI2PException;LJavaIoIOException;LNetI2pDataDataFormatException;", "createIfAbsent", "LNetI2pCryptoSigType;", "LNetI2pClientI2PSessionException;LJavaIoIOException;LNetI2pDataDataFormatException;", "setDestination", "LNetI2pDataDestination;", "setCertType", "I", "setKeyCert", "setHashCashCert", "setSignedCert", "LNetI2pDataPrivateKeyFile;", "LNetI2pClientI2PSessionException;LJavaIoIOException;", "open", "LJavaUtilProperties;", "LJavaIoIOException;LNetI2pDataDataFormatException;", "toString", "estimateHashCashTime", "verifySignature", "checkSignature", "LNetI2pDataSignature;[BLNetI2pDataSigningPublicKey;" };
  static const J2ObjcClassInfo _NetI2pDataPrivateKeyFile = { "PrivateKeyFile", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 28, 6, -1, -1, -1, -1, -1 };
  return &_NetI2pDataPrivateKeyFile;
}

@end

void NetI2pDataPrivateKeyFile_mainWithNSStringArray_(IOSObjectArray *args) {
  NetI2pDataPrivateKeyFile_initialize();
  jint hashEffort = NetI2pDataPrivateKeyFile_HASH_EFFORT;
  NSString *stype = nil;
  NSString *hostname = nil;
  jint mode = 0;
  jboolean error = false;
  GnuGetoptGetopt *g = create_GnuGetoptGetopt_initWithNSString_withNSStringArray_withNSString_(@"pkf", args, @"t:nuxhse:c:a:");
  jint c;
  while ((c = [g getopt]) != -1) {
    switch (c) {
      case 'c':
      stype = [g getOptarg];
      break;
      case 't':
      stype = [g getOptarg];
      case 'n':
      case 'u':
      case 'x':
      case 'h':
      case 's':
      if (mode == 0) mode = c;
      else error = true;
      break;
      case 'a':
      hostname = [g getOptarg];
      if (mode == 0) mode = c;
      else error = true;
      break;
      case 'e':
      hashEffort = JavaLangInteger_parseIntWithNSString_([g getOptarg]);
      break;
      case '?':
      case ':':
      default:
      error = true;
      break;
    }
  }
  jint remaining = ((IOSObjectArray *) nil_chk(args))->size_ - [g getOptind];
  jint reqd = mode == 's' ? 2 : 1;
  if (error || remaining != reqd) {
    NetI2pDataPrivateKeyFile_usage();
    JavaLangSystem_exitWithInt_(1);
  }
  NSString *filearg = IOSObjectArray_Get(args, [g getOptind]);
  id<NetI2pClientI2PClient> client = NetI2pClientI2PClientFactory_createClient();
  @try {
    JavaIoFile *f = create_JavaIoFile_initWithNSString_(filearg);
    jboolean exists = [f exists];
    NetI2pDataPrivateKeyFile *pkf = create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(f, client);
    NetI2pDataDestination *d;
    if (stype != nil) {
      NetI2pCryptoSigType *type = NetI2pCryptoSigType_parseSigTypeWithNSString_(stype);
      if (type == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$", @"Signature type ", stype, @" is not supported"));
      d = [pkf createIfAbsentWithNetI2pCryptoSigType:type];
    }
    else {
      d = [pkf createIfAbsent];
    }
    if (exists) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Original Destination:"];
    else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Created Destination:"];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithId:pkf];
    NetI2pDataPrivateKeyFile_verifySignatureWithNetI2pDataDestination_(d);
    {
      NetI2pDataPrivateKeyFile *pkf2;
      NetI2pCryptoSigType *type;
      NetI2pUtilOrderedProperties *props;
      NetI2pClientNamingHostTxtEntry *he;
      JavaIoOutputStreamWriter *out;
      switch (mode) {
        case 0:
        break;
        case 'n':
        [pkf setCertTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_NULL];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with null cert is:"];
        break;
        case 'u':
        [pkf setCertTypeWithInt:99];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with unknown cert is:"];
        break;
        case 'x':
        [pkf setCertTypeWithInt:NetI2pDataCertificate_CERTIFICATE_TYPE_HIDDEN];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with hidden cert is:"];
        break;
        case 'h':
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Estimating hashcash generation time, stand by..."];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:NetI2pDataPrivateKeyFile_estimateHashCashTimeWithInt_(hashEffort)];
        [pkf setHashCashCertWithInt:hashEffort];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with hashcash cert is:"];
        break;
        case 's':
        pkf2 = create_NetI2pDataPrivateKeyFile_initWithNSString_(IOSObjectArray_Get(args, [g getOptind] + 1));
        [pkf setSignedCertWithNetI2pDataPrivateKeyFile:pkf2];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with signed cert is:"];
        break;
        case 't':
        type = NetI2pCryptoSigType_parseSigTypeWithNSString_(stype);
        if (type == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$", @"Signature type ", stype, @" is not supported"));
        [pkf setKeyCertWithNetI2pCryptoSigType:type];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"New destination with key cert is:"];
        break;
        case 'a':
        props = create_NetI2pUtilOrderedProperties_init();
        he = create_NetI2pClientNamingHostTxtEntry_initWithNSString_withNSString_withNetI2pUtilOrderedProperties_(hostname, [((NetI2pDataDestination *) nil_chk(d)) toBase64], props);
        [he signWithNetI2pDataSigningPrivateKey:[pkf getSigningPrivKey]];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Addressbook Authentication String:"];
        out = create_JavaIoOutputStreamWriter_initWithJavaIoOutputStream_(JreLoadStatic(JavaLangSystem, out));
        [he writeWithJavaIoWriter:out];
        [out flush];
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@""];
        return;
        default:
        NetI2pDataPrivateKeyFile_usage();
        return;
      }
    }
    if (mode != 0) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithId:pkf];
      [pkf write];
      NetI2pDataPrivateKeyFile_verifySignatureWithNetI2pDataDestination_([pkf getDestination]);
    }
  }
  @catch (NetI2pI2PException *e) {
    [e printStackTrace];
    JavaLangSystem_exitWithInt_(1);
  }
  @catch (JavaIoIOException *e) {
    [e printStackTrace];
    JavaLangSystem_exitWithInt_(1);
  }
}

void NetI2pDataPrivateKeyFile_usage() {
  NetI2pDataPrivateKeyFile_initialize();
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$I$", @"Usage: PrivateKeyFile [-c sigtype] filename (generates if nonexistent, then prints)\n       PrivateKeyFile -a example.i2p filename (generate addressbook authentication string)\n       PrivateKeyFile -h filename (generates if nonexistent, adds hashcash cert)\n       PrivateKeyFile -h -e effort filename (specify HashCash effort instead of default ", NetI2pDataPrivateKeyFile_HASH_EFFORT, @")\n       PrivateKeyFile -n filename (changes to null cert)\n       PrivateKeyFile -s filename signwithdestfile (generates if nonexistent, adds cert signed by 2nd dest)\n       PrivateKeyFile -t sigtype filename (changes to KeyCertificate of the given sig type)\n       PrivateKeyFile -u filename (changes to unknown cert)\n       PrivateKeyFile -x filename (changes to hidden cert)\n")];
}

void NetI2pDataPrivateKeyFile_initWithNSString_(NetI2pDataPrivateKeyFile *self, NSString *file) {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(self, create_JavaIoFile_initWithNSString_(file), NetI2pClientI2PClientFactory_createClient());
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithNSString_(NSString *file) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithNSString_, file)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithNSString_(NSString *file) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithNSString_, file)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file) {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(self, file, NetI2pClientI2PClientFactory_createClient());
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_(JavaIoFile *file) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_, file)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_(JavaIoFile *file) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_, file)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file, id<NetI2pClientI2PClient> client) {
  NSObject_init(self);
  JreStrongAssign(&self->file_, file);
  JreStrongAssign(&self->client_, client);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(JavaIoFile *file, id<NetI2pClientI2PClient> client) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pClientI2PClient_, file, client)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PClient_(JavaIoFile *file, id<NetI2pClientI2PClient> client) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pClientI2PClient_, file, client)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PSession_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file, id<NetI2pClientI2PSession> session) {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(self, file, [((id<NetI2pClientI2PSession>) nil_chk(session)) getMyDestination], [session getDecryptionKey], [session getPrivateKey]);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PSession_(JavaIoFile *file, id<NetI2pClientI2PSession> session) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pClientI2PSession_, file, session)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pClientI2PSession_(JavaIoFile *file, id<NetI2pClientI2PSession> session) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pClientI2PSession_, file, session)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file, NetI2pDataDestination *dest, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  NSObject_init(self);
  if ([((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(dest)) getSigningPublicKey])) getType] != [((NetI2pDataSigningPrivateKey *) nil_chk(spk)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Signing key type mismatch");
  JreStrongAssign(&self->file_, file);
  JreStrongAssign(&self->client_, nil);
  JreStrongAssign(&self->dest_, dest);
  JreStrongAssign(&self->privKey_, pk);
  JreStrongAssign(&self->signingPrivKey_, spk);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(JavaIoFile *file, NetI2pDataDestination *dest, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_, file, dest, pk, spk)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(JavaIoFile *file, NetI2pDataDestination *dest, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataDestination_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_, file, dest, pk, spk)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_(self, file, pubkey, spubkey, cert, pk, spk, nil);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_, file, pubkey, spubkey, cert, pk, spk)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_(JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_, file, pubkey, spubkey, cert, pk, spk)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_(NetI2pDataPrivateKeyFile *self, JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk, IOSByteArray *padding) {
  NSObject_init(self);
  if ([((NetI2pDataSigningPublicKey *) nil_chk(spubkey)) getType] != [((NetI2pDataSigningPrivateKey *) nil_chk(spk)) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Signing key type mismatch");
  JreStrongAssign(&self->file_, file);
  JreStrongAssign(&self->client_, nil);
  JreStrongAssignAndConsume(&self->dest_, new_NetI2pDataDestination_init());
  [self->dest_ setPublicKeyWithNetI2pDataPublicKey:pubkey];
  [((NetI2pDataDestination *) nil_chk(self->dest_)) setSigningPublicKeyWithNetI2pDataSigningPublicKey:spubkey];
  [((NetI2pDataDestination *) nil_chk(self->dest_)) setCertificateWithNetI2pDataCertificate:cert];
  if (padding != nil) [((NetI2pDataDestination *) nil_chk(self->dest_)) setPaddingWithByteArray:padding];
  JreStrongAssign(&self->privKey_, pk);
  JreStrongAssign(&self->signingPrivKey_, spk);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_(JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk, IOSByteArray *padding) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_, file, pubkey, spubkey, cert, pk, spk, padding)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_(JavaIoFile *file, NetI2pDataPublicKey *pubkey, NetI2pDataSigningPublicKey *spubkey, NetI2pDataCertificate *cert, NetI2pDataPrivateKey *pk, NetI2pDataSigningPrivateKey *spk, IOSByteArray *padding) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoFile_withNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withNetI2pDataPrivateKey_withNetI2pDataSigningPrivateKey_withByteArray_, file, pubkey, spubkey, cert, pk, spk, padding)
}

void NetI2pDataPrivateKeyFile_initWithJavaIoInputStream_(NetI2pDataPrivateKeyFile *self, JavaIoInputStream *inArg) {
  NetI2pDataPrivateKeyFile_initWithNSString_(self, @"/dev/null");
  id<NetI2pClientI2PSession> s = [((id<NetI2pClientI2PClient>) nil_chk(self->client_)) createSessionWithJavaIoInputStream:inArg withJavaUtilProperties:create_JavaUtilProperties_init()];
  JreStrongAssign(&self->dest_, [((id<NetI2pClientI2PSession>) nil_chk(s)) getMyDestination]);
  JreStrongAssign(&self->privKey_, [s getDecryptionKey]);
  JreStrongAssign(&self->signingPrivKey_, [s getPrivateKey]);
}

NetI2pDataPrivateKeyFile *new_NetI2pDataPrivateKeyFile_initWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  J2OBJC_NEW_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoInputStream_, inArg)
}

NetI2pDataPrivateKeyFile *create_NetI2pDataPrivateKeyFile_initWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  J2OBJC_CREATE_IMPL(NetI2pDataPrivateKeyFile, initWithJavaIoInputStream_, inArg)
}

NSString *NetI2pDataPrivateKeyFile_estimateHashCashTimeWithInt_(jint hashEffort) {
  NetI2pDataPrivateKeyFile_initialize();
  if (hashEffort <= 0 || hashEffort > 160) return JreStrcat("$I", @"Bad HashCash value: ", hashEffort);
  jlong low = JavaLangLong_MAX_VALUE;
  @try {
    low = ComNettgryppaSecurityHashCash_estimateTimeWithInt_(hashEffort);
  }
  @catch (JavaSecurityNoSuchAlgorithmException *e) {
  }
  return JreStrcat("$I$$", @"It is estimated that generating a HashCash Certificate with value ", hashEffort, @" for the Destination will take ", ((low < 1000l * 24l * 60l * 60l * 1000l) ? JreStrcat("$$$$", @"approximately ", NetI2pDataDataHelper_formatDurationWithLong_(low), @" to ", NetI2pDataDataHelper_formatDurationWithLong_(4 * low)) : @"longer than three years!"));
}

jboolean NetI2pDataPrivateKeyFile_verifySignatureWithNetI2pDataDestination_(NetI2pDataDestination *d) {
  NetI2pDataPrivateKeyFile_initialize();
  if ([((NetI2pDataCertificate *) nil_chk([((NetI2pDataDestination *) nil_chk(d)) getCertificate])) getCertificateType] != NetI2pDataCertificate_CERTIFICATE_TYPE_SIGNED) return false;
  jint len = NetI2pDataPublicKey_KEYSIZE_BYTES + JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES);
  IOSByteArray *data = [IOSByteArray arrayWithLength:len];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataPublicKey *) nil_chk([d getPublicKey])) getData], 0, data, 0, NetI2pDataPublicKey_KEYSIZE_BYTES);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSigningPublicKey *) nil_chk([d getSigningPublicKey])) getData], 0, data, NetI2pDataPublicKey_KEYSIZE_BYTES, JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES));
  NetI2pDataSignature *sig = create_NetI2pDataSignature_init();
  IOSByteArray *payload = [((NetI2pDataCertificate *) nil_chk([d getCertificate])) getPayload];
  NetI2pDataHash *signerHash = nil;
  if (payload == nil) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Bad signed cert - no payload"];
    return false;
  }
  else if (payload->size_ == JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES)) {
    [sig setDataWithByteArray:payload];
  }
  else if (payload->size_ == JreLoadStatic(NetI2pDataCertificate, CERTIFICATE_LENGTH_SIGNED_WITH_HASH)) {
    IOSByteArray *pl = [IOSByteArray arrayWithLength:JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES)];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, 0, pl, 0, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES));
    [sig setDataWithByteArray:pl];
    IOSByteArray *hash_ = [IOSByteArray arrayWithLength:NetI2pDataHash_HASH_LENGTH];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(payload, JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES), hash_, 0, NetI2pDataHash_HASH_LENGTH);
    signerHash = create_NetI2pDataHash_initWithByteArray_(hash_);
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$$$", @"Destination is signed by ", NetI2pDataBase32_encodeWithByteArray_(hash_), @".b32.i2p")];
  }
  else {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I", @"Bad signed cert - length = ", payload->size_)];
    return false;
  }
  IOSObjectArray *filenames = [IOSObjectArray arrayWithObjects:(id[]){ @"privatehosts.txt", @"userhosts.txt", @"hosts.txt" } count:3 type:NSString_class_()];
  jint tried = 0;
  for (jint i = 0; i < filenames->size_; i++) {
    JavaUtilProperties *hosts = create_JavaUtilProperties_init();
    @try {
      JavaIoFile *f = create_JavaIoFile_initWithNSString_(IOSObjectArray_Get(filenames, i));
      if (([f exists]) && ([f canRead])) {
        NetI2pDataDataHelper_loadPropsWithJavaUtilProperties_withJavaIoFile_withBoolean_(hosts, f, true);
        jint sz = [hosts size];
        if (sz > 0) {
          tried += sz;
          if (signerHash == nil) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I$", @"Attempting to verify using ", sz, @" hosts, this may take a while")];
        }
        for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([hosts entrySet])) {
          NSString *s = (NSString *) cast_chk([((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue], [NSString class]);
          NetI2pDataDestination *signer = create_NetI2pDataDestination_initWithNSString_(s);
          if (signerHash == nil || [((NetI2pDataHash *) nil_chk([signer calculateHash])) isEqual:signerHash]) {
            if (NetI2pDataPrivateKeyFile_checkSignatureWithNetI2pDataSignature_withByteArray_withNetI2pDataSigningPublicKey_(sig, data, [signer getSigningPublicKey])) {
              [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Good signature from: ", [entry_ getKey])];
              return true;
            }
            if (signerHash != nil) {
              [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Bad signature from: ", [entry_ getKey])];
            }
          }
        }
      }
    }
    @catch (NetI2pDataDataFormatException *dfe) {
    }
    @catch (JavaIoIOException *ioe) {
    }
  }
  if (tried > 0) [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"No valid signer found"];
  else [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"No addressbooks found to valididate signer"];
  return false;
}

jboolean NetI2pDataPrivateKeyFile_checkSignatureWithNetI2pDataSignature_withByteArray_withNetI2pDataSigningPublicKey_(NetI2pDataSignature *s, IOSByteArray *data, NetI2pDataSigningPublicKey *spk) {
  NetI2pDataPrivateKeyFile_initialize();
  return [((NetI2pCryptoDSAEngine *) nil_chk(NetI2pCryptoDSAEngine_getInstance())) verifySignatureWithNetI2pDataSignature:s withByteArray:data withNetI2pDataSigningPublicKey:spk];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataPrivateKeyFile)
