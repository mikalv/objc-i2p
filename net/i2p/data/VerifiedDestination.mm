//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/VerifiedDestination.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/nettgryppa/security/HashCash.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuilder.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/VerifiedDestination.h"

J2OBJC_INITIALIZED_DEFN(NetI2pDataVerifiedDestination)

jint NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED;
jint NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED_WITH_HASH;

@implementation NetI2pDataVerifiedDestination

+ (jint)MIN_HASHCASH_EFFORT {
  return NetI2pDataVerifiedDestination_MIN_HASHCASH_EFFORT;
}

+ (jint)CERTIFICATE_LENGTH_SIGNED {
  return NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED;
}

+ (jint)CERTIFICATE_LENGTH_SIGNED_WITH_HASH {
  return NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED_WITH_HASH;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pDataVerifiedDestination_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithNSString:(NSString *)s {
  NetI2pDataVerifiedDestination_initWithNSString_(self, s);
  return self;
}

- (instancetype)initWithNetI2pDataDestination:(NetI2pDataDestination *)d {
  NetI2pDataVerifiedDestination_initWithNetI2pDataDestination_(self, d);
  return self;
}

- (jboolean)verifyCertWithBoolean:(jboolean)allowNone {
  if (_publicKey_ == nil || _signingKey_ == nil || _certificate_ == nil) return false;
  switch ([_certificate_ getCertificateType]) {
    case NetI2pDataCertificate_CERTIFICATE_TYPE_NULL:
    case NetI2pDataCertificate_CERTIFICATE_TYPE_HIDDEN:
    return allowNone;
    case NetI2pDataCertificate_CERTIFICATE_TYPE_HASHCASH:
    return [self verifyHashCashCert];
    case NetI2pDataCertificate_CERTIFICATE_TYPE_SIGNED:
    return [self verifySignedCert];
  }
  return [self verifyUnknownCert];
}

- (jboolean)verifyHashCashCert {
  NSString *hcs = NetI2pDataDataHelper_getUTF8WithByteArray_([((NetI2pDataCertificate *) nil_chk(_certificate_)) getPayload]);
  jint end1 = 0;
  for (jint i = 0; i < 3; i++) {
    end1 = 1 + [((NSString *) nil_chk(hcs)) java_indexOf:':' fromIndex:end1];
    if (end1 < 0) return false;
  }
  jint start2 = [((NSString *) nil_chk(hcs)) java_indexOf:':' fromIndex:end1];
  if (start2 < 0) return false;
  hcs = JreStrcat("$$$$", [hcs java_substring:0 endIndex:end1], [((NetI2pDataPublicKey *) nil_chk(_publicKey_)) toBase64], [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) toBase64], [hcs java_substring:start2]);
  ComNettgryppaSecurityHashCash *hc;
  @try {
    hc = create_ComNettgryppaSecurityHashCash_initWithNSString_(hcs);
  }
  @catch (JavaLangIllegalArgumentException *iae) {
    return false;
  }
  @catch (JavaSecurityNoSuchAlgorithmException *nsae) {
    return false;
  }
  return [((ComNettgryppaSecurityHashCash *) nil_chk(hc)) getValue] >= NetI2pDataVerifiedDestination_MIN_HASHCASH_EFFORT;
}

- (jboolean)verifySignedCert {
  return [((NetI2pDataCertificate *) nil_chk(_certificate_)) getPayload] != nil && (((IOSByteArray *) nil_chk([((NetI2pDataCertificate *) nil_chk(_certificate_)) getPayload]))->size_ == NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED || ((IOSByteArray *) nil_chk([((NetI2pDataCertificate *) nil_chk(_certificate_)) getPayload]))->size_ == NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED_WITH_HASH);
}

- (jboolean)verifyUnknownCert {
  return false;
}

- (NSString *)description {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(128);
  [buf appendWithNSString:[super description]];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tVerified Certificate? "])) appendWithBoolean:[self verifyCertWithBoolean:true]];
  return [buf description];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, 1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, 1, -1, -1, -1 },
    { NULL, "Z", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 5, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithNSString:);
  methods[2].selector = @selector(initWithNetI2pDataDestination:);
  methods[3].selector = @selector(verifyCertWithBoolean:);
  methods[4].selector = @selector(verifyHashCashCert);
  methods[5].selector = @selector(verifySignedCert);
  methods[6].selector = @selector(verifyUnknownCert);
  methods[7].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "MIN_HASHCASH_EFFORT", "I", .constantValue.asInt = NetI2pDataVerifiedDestination_MIN_HASHCASH_EFFORT, 0x19, -1, -1, -1, -1 },
    { "CERTIFICATE_LENGTH_SIGNED", "I", .constantValue.asLong = 0, 0x19, -1, 6, -1, -1 },
    { "CERTIFICATE_LENGTH_SIGNED_WITH_HASH", "I", .constantValue.asLong = 0, 0x19, -1, 7, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;", "LNetI2pDataDataFormatException;", "LNetI2pDataDestination;", "verifyCert", "Z", "toString", &NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED, &NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED_WITH_HASH };
  static const J2ObjcClassInfo _NetI2pDataVerifiedDestination = { "VerifiedDestination", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 8, 3, -1, -1, -1, -1, -1 };
  return &_NetI2pDataVerifiedDestination;
}

+ (void)initialize {
  if (self == [NetI2pDataVerifiedDestination class]) {
    NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED = JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES);
    NetI2pDataVerifiedDestination_CERTIFICATE_LENGTH_SIGNED_WITH_HASH = JreLoadStatic(NetI2pDataSignature, SIGNATURE_BYTES) + NetI2pDataHash_HASH_LENGTH;
    J2OBJC_SET_INITIALIZED(NetI2pDataVerifiedDestination)
  }
}

@end

void NetI2pDataVerifiedDestination_init(NetI2pDataVerifiedDestination *self) {
  NetI2pDataDestination_init(self);
}

NetI2pDataVerifiedDestination *new_NetI2pDataVerifiedDestination_init() {
  J2OBJC_NEW_IMPL(NetI2pDataVerifiedDestination, init)
}

NetI2pDataVerifiedDestination *create_NetI2pDataVerifiedDestination_init() {
  J2OBJC_CREATE_IMPL(NetI2pDataVerifiedDestination, init)
}

void NetI2pDataVerifiedDestination_initWithNSString_(NetI2pDataVerifiedDestination *self, NSString *s) {
  NetI2pDataVerifiedDestination_init(self);
  [self fromBase64WithNSString:s];
}

NetI2pDataVerifiedDestination *new_NetI2pDataVerifiedDestination_initWithNSString_(NSString *s) {
  J2OBJC_NEW_IMPL(NetI2pDataVerifiedDestination, initWithNSString_, s)
}

NetI2pDataVerifiedDestination *create_NetI2pDataVerifiedDestination_initWithNSString_(NSString *s) {
  J2OBJC_CREATE_IMPL(NetI2pDataVerifiedDestination, initWithNSString_, s)
}

void NetI2pDataVerifiedDestination_initWithNetI2pDataDestination_(NetI2pDataVerifiedDestination *self, NetI2pDataDestination *d) {
  NetI2pDataVerifiedDestination_initWithNSString_(self, [((NetI2pDataDestination *) nil_chk(d)) toBase64]);
}

NetI2pDataVerifiedDestination *new_NetI2pDataVerifiedDestination_initWithNetI2pDataDestination_(NetI2pDataDestination *d) {
  J2OBJC_NEW_IMPL(NetI2pDataVerifiedDestination, initWithNetI2pDataDestination_, d)
}

NetI2pDataVerifiedDestination *create_NetI2pDataVerifiedDestination_initWithNetI2pDataDestination_(NetI2pDataDestination *d) {
  J2OBJC_CREATE_IMPL(NetI2pDataVerifiedDestination, initWithNetI2pDataDestination_, d)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataVerifiedDestination)
