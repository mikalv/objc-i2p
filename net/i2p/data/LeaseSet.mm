//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/LeaseSet.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Long.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/annotation/Annotation.h"
#include "java/util/ArrayList.h"
#include "java/util/Date.h"
#include "java/util/List.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/crypto/AESEngine.h"
#include "net/i2p/crypto/DSAEngine.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/DatabaseEntry.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/KeysAndCert.h"
#include "net/i2p/data/Lease.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/KeyRing.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"

@interface NetI2pDataLeaseSet () {
 @public
  NetI2pDataDestination *_destination_;
  NetI2pDataPublicKey *_encryptionKey_;
  NetI2pDataSigningPublicKey *_signingKey_;
  id<JavaUtilList> _leases_;
  jboolean _receivedAsPublished_;
  jboolean _receivedAsReply_;
  jlong _firstExpiration_;
  jlong _lastExpiration_;
  id<JavaUtilList> _decryptedLeases_;
  jboolean _decrypted_;
  jboolean _checked_;
  volatile_id _byteified_;
}

- (void)encrypWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key;

- (void)decryptWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key;

- (jboolean)isEncrypted;

@end

J2OBJC_FIELD_SETTER(NetI2pDataLeaseSet, _destination_, NetI2pDataDestination *)
J2OBJC_FIELD_SETTER(NetI2pDataLeaseSet, _encryptionKey_, NetI2pDataPublicKey *)
J2OBJC_FIELD_SETTER(NetI2pDataLeaseSet, _signingKey_, NetI2pDataSigningPublicKey *)
J2OBJC_FIELD_SETTER(NetI2pDataLeaseSet, _leases_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(NetI2pDataLeaseSet, _decryptedLeases_, id<JavaUtilList>)
J2OBJC_VOLATILE_FIELD_SETTER(NetI2pDataLeaseSet, _byteified_, IOSByteArray *)

inline jint NetI2pDataLeaseSet_get_OLD_MAX_LEASES(void);
#define NetI2pDataLeaseSet_OLD_MAX_LEASES 6
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataLeaseSet, OLD_MAX_LEASES, jint)

inline jint NetI2pDataLeaseSet_get_DATA_LEN(void);
#define NetI2pDataLeaseSet_DATA_LEN 36
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataLeaseSet, DATA_LEN, jint)

inline jint NetI2pDataLeaseSet_get_IV_LEN(void);
#define NetI2pDataLeaseSet_IV_LEN 16
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataLeaseSet, IV_LEN, jint)

__attribute__((unused)) static void NetI2pDataLeaseSet_encrypWithNetI2pDataSessionKey_(NetI2pDataLeaseSet *self, NetI2pDataSessionKey *key);

__attribute__((unused)) static void NetI2pDataLeaseSet_decryptWithNetI2pDataSessionKey_(NetI2pDataLeaseSet *self, NetI2pDataSessionKey *key);

__attribute__((unused)) static jboolean NetI2pDataLeaseSet_isEncrypted(NetI2pDataLeaseSet *self);

__attribute__((unused)) static IOSObjectArray *NetI2pDataLeaseSet__Annotations$0(void);

__attribute__((unused)) static IOSObjectArray *NetI2pDataLeaseSet__Annotations$1(void);

@implementation NetI2pDataLeaseSet

+ (jint)MAX_LEASES {
  return NetI2pDataLeaseSet_MAX_LEASES;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pDataLeaseSet_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jlong)getDate {
  return [self getEarliestLeaseDate];
}

- (NetI2pDataKeysAndCert *)getKeysAndCert {
  return _destination_;
}

- (jint)getType {
  return NetI2pDataDatabaseEntry_KEY_TYPE_LEASESET;
}

- (NetI2pDataDestination *)getDestination {
  return _destination_;
}

- (void)setDestinationWithNetI2pDataDestination:(NetI2pDataDestination *)dest {
  if (JreLoadVolatileId(&_signature_) != nil) @throw create_JavaLangIllegalStateException_init();
  JreStrongAssign(&_destination_, dest);
}

- (NetI2pDataPublicKey *)getEncryptionKey {
  return _encryptionKey_;
}

- (void)setEncryptionKeyWithNetI2pDataPublicKey:(NetI2pDataPublicKey *)encryptionKey {
  if (JreLoadVolatileId(&_signature_) != nil) @throw create_JavaLangIllegalStateException_init();
  JreStrongAssign(&_encryptionKey_, encryptionKey);
}

- (NetI2pDataSigningPublicKey *)getSigningKey {
  return _signingKey_;
}

- (void)setSigningKeyWithNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)key {
  if (key != nil && _destination_ != nil && [key getType] != [((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(_destination_)) getSigningPublicKey])) getType]) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Signing key type mismatch");
  JreStrongAssign(&_signingKey_, key);
}

- (jboolean)getReceivedAsPublished {
  return _receivedAsPublished_;
}

- (void)setReceivedAsPublishedWithBoolean:(jboolean)received {
  _receivedAsPublished_ = received;
}

- (jboolean)getReceivedAsReply {
  return _receivedAsReply_;
}

- (void)setReceivedAsReply {
  _receivedAsReply_ = true;
}

- (void)addLeaseWithNetI2pDataLease:(NetI2pDataLease *)lease {
  if (lease == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"erm, null lease");
  if ([lease getGateway] == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"erm, lease has no gateway");
  if ([lease getTunnelId] == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"erm, lease has no tunnel");
  if (JreLoadVolatileId(&_signature_) != nil) @throw create_JavaLangIllegalStateException_init();
  if ([((id<JavaUtilList>) nil_chk(_leases_)) size] >= NetI2pDataLeaseSet_MAX_LEASES) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Too many leases - max is ", NetI2pDataLeaseSet_MAX_LEASES));
  [_leases_ addWithId:lease];
  jlong expire = [((JavaUtilDate *) nil_chk([lease getEndDate])) getTime];
  if (expire < _firstExpiration_) _firstExpiration_ = expire;
  if (expire > _lastExpiration_) _lastExpiration_ = expire;
}

- (jint)getLeaseCount {
  if (NetI2pDataLeaseSet_isEncrypted(self)) return [((id<JavaUtilList>) nil_chk(_leases_)) size] - 1;
  else return [((id<JavaUtilList>) nil_chk(_leases_)) size];
}

- (NetI2pDataLease *)getLeaseWithInt:(jint)index {
  if (NetI2pDataLeaseSet_isEncrypted(self)) return [((id<JavaUtilList>) nil_chk(_decryptedLeases_)) getWithInt:index];
  else return [((id<JavaUtilList>) nil_chk(_leases_)) getWithInt:index];
}

- (jlong)getEarliestLeaseDate {
  if ([((id<JavaUtilList>) nil_chk(_leases_)) isEmpty]) return -1;
  return _firstExpiration_;
}

- (jlong)getLatestLeaseDate {
  return _lastExpiration_;
}

- (jboolean)verifySignature {
  if ([super verifySignature]) return true;
  jboolean signedByRevoker = [((NetI2pCryptoDSAEngine *) nil_chk(NetI2pCryptoDSAEngine_getInstance())) verifySignatureWithNetI2pDataSignature:JreLoadVolatileId(&_signature_) withByteArray:[self getBytes] withNetI2pDataSigningPublicKey:_signingKey_];
  return signedByRevoker;
}

- (jboolean)verifySignatureWithNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)signingKey {
  if ([super verifySignature]) return true;
  jboolean signedByRevoker = [((NetI2pCryptoDSAEngine *) nil_chk(NetI2pCryptoDSAEngine_getInstance())) verifySignatureWithNetI2pDataSignature:JreLoadVolatileId(&_signature_) withByteArray:[self getBytes] withNetI2pDataSigningPublicKey:signingKey];
  return signedByRevoker;
}

- (jboolean)isCurrentWithLong:(jlong)fudge {
  jlong now = [((NetI2pUtilClock *) nil_chk(NetI2pUtilClock_getInstance())) now];
  return _lastExpiration_ > now - fudge;
}

- (IOSByteArray *)getBytes {
  if (JreLoadVolatileId(&_byteified_) != nil) return JreLoadVolatileId(&_byteified_);
  if ((_destination_ == nil) || (_encryptionKey_ == nil) || (_signingKey_ == nil)) return nil;
  jint len = [((NetI2pDataDestination *) nil_chk(_destination_)) size] + NetI2pDataPublicKey_KEYSIZE_BYTES + [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) length] + 1 + [((id<JavaUtilList>) nil_chk(_leases_)) size] * 44;
  JavaIoByteArrayOutputStream *out = create_JavaIoByteArrayOutputStream_initWithInt_(len);
  @try {
    [((NetI2pDataDestination *) nil_chk(_destination_)) writeBytesWithJavaIoOutputStream:out];
    [((NetI2pDataPublicKey *) nil_chk(_encryptionKey_)) writeBytesWithJavaIoOutputStream:out];
    [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) writeBytesWithJavaIoOutputStream:out];
    [out writeWithInt:(jbyte) [_leases_ size]];
    for (NetI2pDataLease * __strong lease in _leases_) [((NetI2pDataLease *) nil_chk(lease)) writeBytesWithJavaIoOutputStream:out];
  }
  @catch (JavaIoIOException *ioe) {
    return nil;
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    return nil;
  }
  IOSByteArray *rv = [out toByteArray];
  if (_receivedAsPublished_) JreVolatileStrongAssign(&_byteified_, rv);
  return rv;
}

- (void)readBytesWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  if (_destination_ != nil) @throw create_JavaLangIllegalStateException_init();
  JreStrongAssign(&_destination_, NetI2pDataDestination_createWithJavaIoInputStream_(inArg));
  JreStrongAssign(&_encryptionKey_, NetI2pDataPublicKey_createWithJavaIoInputStream_(inArg));
  NetI2pCryptoSigType *type = [((NetI2pDataSigningPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(_destination_)) getSigningPublicKey])) getType];
  if (type == nil) @throw create_NetI2pDataDataFormatException_initWithNSString_(@"unknown sig type");
  JreStrongAssignAndConsume(&_signingKey_, new_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(type));
  [_signingKey_ readBytesWithJavaIoInputStream:inArg];
  jint numLeases = [((JavaIoInputStream *) nil_chk(inArg)) read];
  if (numLeases > NetI2pDataLeaseSet_MAX_LEASES) @throw create_NetI2pDataDataFormatException_initWithNSString_(JreStrcat("$I", @"Too many leases - max is ", NetI2pDataLeaseSet_MAX_LEASES));
  for (jint i = 0; i < numLeases; i++) {
    NetI2pDataLease *lease = create_NetI2pDataLease_init();
    [lease readBytesWithJavaIoInputStream:inArg];
    [self addLeaseWithNetI2pDataLease:lease];
  }
  JreVolatileStrongAssign(&_signature_, create_NetI2pDataSignature_initWithNetI2pCryptoSigType_(type));
  [((NetI2pDataSignature *) nil_chk(JreLoadVolatileId(&_signature_))) readBytesWithJavaIoInputStream:inArg];
}

- (void)writeBytesWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if ((_destination_ == nil) || (_encryptionKey_ == nil) || (_signingKey_ == nil) || (JreLoadVolatileId(&_signature_) == nil)) @throw create_NetI2pDataDataFormatException_initWithNSString_(@"Not enough data to write out a LeaseSet");
  [((NetI2pDataDestination *) nil_chk(_destination_)) writeBytesWithJavaIoOutputStream:outArg];
  [((NetI2pDataPublicKey *) nil_chk(_encryptionKey_)) writeBytesWithJavaIoOutputStream:outArg];
  [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) writeBytesWithJavaIoOutputStream:outArg];
  [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(jbyte) [((id<JavaUtilList>) nil_chk(_leases_)) size]];
  for (NetI2pDataLease * __strong lease in _leases_) [((NetI2pDataLease *) nil_chk(lease)) writeBytesWithJavaIoOutputStream:outArg];
  [((NetI2pDataSignature *) nil_chk(JreLoadVolatileId(&_signature_))) writeBytesWithJavaIoOutputStream:outArg];
}

- (jint)size {
  return [((NetI2pDataDestination *) nil_chk(_destination_)) size] + NetI2pDataPublicKey_KEYSIZE_BYTES + [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) length] + 1 + [((id<JavaUtilList>) nil_chk(_leases_)) size] * (NetI2pDataHash_HASH_LENGTH + 4 + 8);
}

- (jboolean)isEqual:(id)object {
  if (object == self) return true;
  if ((object == nil) || !([object isKindOfClass:[NetI2pDataLeaseSet class]])) return false;
  NetI2pDataLeaseSet *ls = (NetI2pDataLeaseSet *) cast_chk(object, [NetI2pDataLeaseSet class]);
  return NetI2pDataDataHelper_eqWithId_withId_(JreLoadVolatileId(&_signature_), [((NetI2pDataLeaseSet *) nil_chk(ls)) getSignature]) && NetI2pDataDataHelper_eqWithJavaUtilCollection_withJavaUtilCollection_(_leases_, ls->_leases_) && NetI2pDataDataHelper_eqWithId_withId_([self getEncryptionKey], [ls getEncryptionKey]) && NetI2pDataDataHelper_eqWithId_withId_(_signingKey_, [ls getSigningKey]) && NetI2pDataDataHelper_eqWithId_withId_(_destination_, [ls getDestination]);
}

- (NSUInteger)hash {
  if (_destination_ == nil) return 0;
  return ((jint) [_destination_ hash]);
}

- (NSString *)description {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(128);
  [buf appendWithNSString:@"[LeaseSet: "];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tDestination: "])) appendWithId:_destination_];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tEncryptionKey: "])) appendWithId:_encryptionKey_];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tSigningKey: "])) appendWithId:_signingKey_];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tSignature: "])) appendWithId:JreLoadVolatileId(&_signature_)];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\tLeases: #"])) appendWithInt:[self getLeaseCount]];
  for (jint i = 0; i < [self getLeaseCount]; i++) [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"\n\t\t"])) appendWithId:[self getLeaseWithInt:i]];
  [buf appendWithNSString:@"]"];
  return [buf description];
}

- (void)encryptWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key {
  @try {
    NetI2pDataLeaseSet_encrypWithNetI2pDataSessionKey_(self, key);
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) logManager])) getLogWithIOSClass:NetI2pDataLeaseSet_class_()];
    [((NetI2pUtilLog *) nil_chk(log)) errorWithNSString:JreStrcat("$@", @"Error encrypting lease: ", [((NetI2pDataDestination *) nil_chk(_destination_)) calculateHash]) withJavaLangThrowable:dfe];
  }
  @catch (JavaIoIOException *ioe) {
    NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) logManager])) getLogWithIOSClass:NetI2pDataLeaseSet_class_()];
    [((NetI2pUtilLog *) nil_chk(log)) errorWithNSString:JreStrcat("$@", @"Error encrypting lease: ", [((NetI2pDataDestination *) nil_chk(_destination_)) calculateHash]) withJavaLangThrowable:ioe];
  }
}

- (void)encrypWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key {
  NetI2pDataLeaseSet_encrypWithNetI2pDataSessionKey_(self, key);
}

- (void)decryptWithNetI2pDataSessionKey:(NetI2pDataSessionKey *)key {
  NetI2pDataLeaseSet_decryptWithNetI2pDataSessionKey_(self, key);
}

- (jboolean)isEncrypted {
  return NetI2pDataLeaseSet_isEncrypted(self);
}

- (void)__javaClone:(NetI2pDataLeaseSet *)original {
  [super __javaClone:original];
  JreCloneVolatileStrong(&_byteified_, &original->_byteified_);
}

- (void)dealloc {
  RELEASE_(_destination_);
  RELEASE_(_encryptionKey_);
  RELEASE_(_signingKey_);
  RELEASE_(_leases_);
  RELEASE_(_decryptedLeases_);
  JreReleaseVolatile(&_byteified_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataKeysAndCert;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataPublicKey;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSigningPublicKey;", 0x1, -1, -1, -1, -1, 4, -1 },
    { NULL, "V", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataLease;", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 13, 6, -1, -1, 14, -1 },
    { NULL, "Z", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 18, 19, -1, -1, -1 },
    { NULL, "V", 0x1, 20, 21, 19, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 22, 23, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 24, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 25, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 26, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 28, 27, 19, -1, -1, -1 },
    { NULL, "V", 0x2, 29, 27, 19, -1, -1, -1 },
    { NULL, "Z", 0x22, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(getDate);
  methods[2].selector = @selector(getKeysAndCert);
  methods[3].selector = @selector(getType);
  methods[4].selector = @selector(getDestination);
  methods[5].selector = @selector(setDestinationWithNetI2pDataDestination:);
  methods[6].selector = @selector(getEncryptionKey);
  methods[7].selector = @selector(setEncryptionKeyWithNetI2pDataPublicKey:);
  methods[8].selector = @selector(getSigningKey);
  methods[9].selector = @selector(setSigningKeyWithNetI2pDataSigningPublicKey:);
  methods[10].selector = @selector(getReceivedAsPublished);
  methods[11].selector = @selector(setReceivedAsPublishedWithBoolean:);
  methods[12].selector = @selector(getReceivedAsReply);
  methods[13].selector = @selector(setReceivedAsReply);
  methods[14].selector = @selector(addLeaseWithNetI2pDataLease:);
  methods[15].selector = @selector(getLeaseCount);
  methods[16].selector = @selector(getLeaseWithInt:);
  methods[17].selector = @selector(getEarliestLeaseDate);
  methods[18].selector = @selector(getLatestLeaseDate);
  methods[19].selector = @selector(verifySignature);
  methods[20].selector = @selector(verifySignatureWithNetI2pDataSigningPublicKey:);
  methods[21].selector = @selector(isCurrentWithLong:);
  methods[22].selector = @selector(getBytes);
  methods[23].selector = @selector(readBytesWithJavaIoInputStream:);
  methods[24].selector = @selector(writeBytesWithJavaIoOutputStream:);
  methods[25].selector = @selector(size);
  methods[26].selector = @selector(isEqual:);
  methods[27].selector = @selector(hash);
  methods[28].selector = @selector(description);
  methods[29].selector = @selector(encryptWithNetI2pDataSessionKey:);
  methods[30].selector = @selector(encrypWithNetI2pDataSessionKey:);
  methods[31].selector = @selector(decryptWithNetI2pDataSessionKey:);
  methods[32].selector = @selector(isEncrypted);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_destination_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_encryptionKey_", "LNetI2pDataPublicKey;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_signingKey_", "LNetI2pDataSigningPublicKey;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_leases_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 30, -1 },
    { "_receivedAsPublished_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_receivedAsReply_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_firstExpiration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_lastExpiration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_decryptedLeases_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 30, -1 },
    { "_decrypted_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_checked_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_byteified_", "[B", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "MAX_LEASES", "I", .constantValue.asInt = NetI2pDataLeaseSet_MAX_LEASES, 0x19, -1, -1, -1, -1 },
    { "OLD_MAX_LEASES", "I", .constantValue.asInt = NetI2pDataLeaseSet_OLD_MAX_LEASES, 0x1a, -1, -1, -1, -1 },
    { "DATA_LEN", "I", .constantValue.asInt = NetI2pDataLeaseSet_DATA_LEN, 0x1a, -1, -1, -1, -1 },
    { "IV_LEN", "I", .constantValue.asInt = NetI2pDataLeaseSet_IV_LEN, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setDestination", "LNetI2pDataDestination;", "setEncryptionKey", "LNetI2pDataPublicKey;", (void *)&NetI2pDataLeaseSet__Annotations$0, "setSigningKey", "LNetI2pDataSigningPublicKey;", "setReceivedAsPublished", "Z", "addLease", "LNetI2pDataLease;", "getLease", "I", "verifySignature", (void *)&NetI2pDataLeaseSet__Annotations$1, "isCurrent", "J", "readBytes", "LJavaIoInputStream;", "LNetI2pDataDataFormatException;LJavaIoIOException;", "writeBytes", "LJavaIoOutputStream;", "equals", "LNSObject;", "hashCode", "toString", "encrypt", "LNetI2pDataSessionKey;", "encryp", "decrypt", "Ljava/util/List<Lnet/i2p/data/Lease;>;" };
  static const J2ObjcClassInfo _NetI2pDataLeaseSet = { "LeaseSet", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 33, 16, -1, -1, -1, -1, -1 };
  return &_NetI2pDataLeaseSet;
}

@end

void NetI2pDataLeaseSet_init(NetI2pDataLeaseSet *self) {
  NetI2pDataDatabaseEntry_init(self);
  JreStrongAssignAndConsume(&self->_leases_, new_JavaUtilArrayList_initWithInt_(2));
  self->_firstExpiration_ = JavaLangLong_MAX_VALUE;
}

NetI2pDataLeaseSet *new_NetI2pDataLeaseSet_init() {
  J2OBJC_NEW_IMPL(NetI2pDataLeaseSet, init)
}

NetI2pDataLeaseSet *create_NetI2pDataLeaseSet_init() {
  J2OBJC_CREATE_IMPL(NetI2pDataLeaseSet, init)
}

void NetI2pDataLeaseSet_encrypWithNetI2pDataSessionKey_(NetI2pDataLeaseSet *self, NetI2pDataSessionKey *key) {
  jint size = [((id<JavaUtilList>) nil_chk(self->_leases_)) size];
  if (size < 1 || size > NetI2pDataLeaseSet_MAX_LEASES - 1) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Bad number of leases for encryption");
  jint datalen = ((NetI2pDataLeaseSet_DATA_LEN * size / 16) + 1) * 16;
  JavaIoByteArrayOutputStream *baos = create_JavaIoByteArrayOutputStream_initWithInt_(datalen);
  for (jint i = 0; i < size; i++) {
    [((NetI2pDataHash *) nil_chk([((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) getGateway])) writeBytesWithJavaIoOutputStream:baos];
    [((NetI2pDataTunnelId *) nil_chk([((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) getTunnelId])) writeBytesWithJavaIoOutputStream:baos];
  }
  jint padlen = datalen - (NetI2pDataLeaseSet_DATA_LEN * size);
  IOSByteArray *pad = [IOSByteArray arrayWithLength:padlen];
  [((NetI2pUtilRandomSource *) nil_chk(NetI2pUtilRandomSource_getInstance())) nextBytesWithByteArray:pad];
  [baos writeWithByteArray:pad];
  IOSByteArray *iv = [IOSByteArray arrayWithLength:NetI2pDataLeaseSet_IV_LEN];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->_destination_)) getPublicKey])) getData], 0, iv, 0, NetI2pDataLeaseSet_IV_LEN);
  IOSByteArray *enc = [IOSByteArray arrayWithLength:NetI2pDataLeaseSet_DATA_LEN * (size + 1)];
  [((NetI2pCryptoAESEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) aes])) encryptWithByteArray:[baos toByteArray] withInt:0 withByteArray:enc withInt:0 withNetI2pDataSessionKey:key withByteArray:iv withInt:datalen];
  padlen = enc->size_ - datalen;
  [((NetI2pUtilRandomSource *) nil_chk(NetI2pUtilRandomSource_getInstance())) nextBytesWithByteArray:enc withInt:datalen withInt:padlen];
  NetI2pDataLease *padLease = create_NetI2pDataLease_init();
  [padLease setEndDateWithJavaUtilDate:[((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:0])) getEndDate]];
  [self->_leases_ addWithId:padLease];
  JavaIoByteArrayInputStream *bais = create_JavaIoByteArrayInputStream_initWithByteArray_(enc);
  for (jint i = 0; i < size + 1; i++) {
    NetI2pDataHash *h = create_NetI2pDataHash_init();
    [h readBytesWithJavaIoInputStream:bais];
    [((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) setGatewayWithNetI2pDataHash:h];
    NetI2pDataTunnelId *t = create_NetI2pDataTunnelId_init();
    [t readBytesWithJavaIoInputStream:bais];
    [((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) setTunnelIdWithNetI2pDataTunnelId:t];
  }
}

void NetI2pDataLeaseSet_decryptWithNetI2pDataSessionKey_(NetI2pDataLeaseSet *self, NetI2pDataSessionKey *key) {
  jint size = [((id<JavaUtilList>) nil_chk(self->_leases_)) size];
  if (size < 2) @throw create_NetI2pDataDataFormatException_initWithNSString_(JreStrcat("$$$", @"Bad number of leases decrypting ", [((NetI2pDataDestination *) nil_chk(self->_destination_)) toBase32], @" - is this destination encrypted?"));
  jint datalen = NetI2pDataLeaseSet_DATA_LEN * size;
  JavaIoByteArrayOutputStream *baos = create_JavaIoByteArrayOutputStream_initWithInt_(datalen);
  for (jint i = 0; i < size; i++) {
    [((NetI2pDataHash *) nil_chk([((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) getGateway])) writeBytesWithJavaIoOutputStream:baos];
    [((NetI2pDataTunnelId *) nil_chk([((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) getTunnelId])) writeBytesWithJavaIoOutputStream:baos];
  }
  IOSByteArray *iv = [IOSByteArray arrayWithLength:NetI2pDataLeaseSet_IV_LEN];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataPublicKey *) nil_chk([((NetI2pDataDestination *) nil_chk(self->_destination_)) getPublicKey])) getData], 0, iv, 0, NetI2pDataLeaseSet_IV_LEN);
  jint enclen = ((NetI2pDataLeaseSet_DATA_LEN * (size - 1) / 16) + 1) * 16;
  IOSByteArray *enc = [IOSByteArray arrayWithLength:enclen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([baos toByteArray], 0, enc, 0, enclen);
  IOSByteArray *dec = [IOSByteArray arrayWithLength:enclen];
  [((NetI2pCryptoAESEngine *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) aes])) decryptWithByteArray:enc withInt:0 withByteArray:dec withInt:0 withNetI2pDataSessionKey:key withByteArray:iv withInt:enclen];
  JavaIoByteArrayInputStream *bais = create_JavaIoByteArrayInputStream_initWithByteArray_(dec);
  JreStrongAssignAndConsume(&self->_decryptedLeases_, new_JavaUtilArrayList_initWithInt_(size - 1));
  for (jint i = 0; i < size - 1; i++) {
    NetI2pDataLease *l = create_NetI2pDataLease_init();
    NetI2pDataHash *h = create_NetI2pDataHash_init();
    [h readBytesWithJavaIoInputStream:bais];
    [l setGatewayWithNetI2pDataHash:h];
    NetI2pDataTunnelId *t = create_NetI2pDataTunnelId_init();
    [t readBytesWithJavaIoInputStream:bais];
    [l setTunnelIdWithNetI2pDataTunnelId:t];
    [l setEndDateWithJavaUtilDate:[((NetI2pDataLease *) nil_chk([self->_leases_ getWithInt:i])) getEndDate]];
    [((id<JavaUtilList>) nil_chk(self->_decryptedLeases_)) addWithId:l];
  }
}

jboolean NetI2pDataLeaseSet_isEncrypted(NetI2pDataLeaseSet *self) {
  @synchronized(self) {
    if (self->_decrypted_) return true;
    if (self->_checked_ || self->_encryptionKey_ == nil || self->_destination_ == nil) return false;
    NetI2pDataSessionKey *key = [((NetI2pUtilKeyRing *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) keyRing])) getWithId:[((NetI2pDataDestination *) nil_chk(self->_destination_)) calculateHash]];
    if (key != nil) {
      @try {
        NetI2pDataLeaseSet_decryptWithNetI2pDataSessionKey_(self, key);
        self->_decrypted_ = true;
      }
      @catch (NetI2pDataDataFormatException *dfe) {
        NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) logManager])) getLogWithIOSClass:NetI2pDataLeaseSet_class_()];
        [((NetI2pUtilLog *) nil_chk(log)) errorWithNSString:JreStrcat("$$$", @"Error decrypting ", [((NetI2pDataDestination *) nil_chk(self->_destination_)) toBase32], @" - is this destination encrypted?") withJavaLangThrowable:dfe];
      }
      @catch (JavaIoIOException *ioe) {
        NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) logManager])) getLogWithIOSClass:NetI2pDataLeaseSet_class_()];
        [((NetI2pUtilLog *) nil_chk(log)) errorWithNSString:JreStrcat("$$$", @"Error decrypting ", [((NetI2pDataDestination *) nil_chk(self->_destination_)) toBase32], @" - is this destination encrypted?") withJavaLangThrowable:ioe];
      }
    }
    self->_checked_ = true;
    return self->_decrypted_;
  }
}

IOSObjectArray *NetI2pDataLeaseSet__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *NetI2pDataLeaseSet__Annotations$1() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataLeaseSet)
