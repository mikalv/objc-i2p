//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/SigningPublicKey.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/KeyCertificate.h"
#include "net/i2p/data/SDSCache.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/SimpleDataStructure.h"

@interface NetI2pDataSigningPublicKey () {
 @public
  NetI2pCryptoSigType *_type_;
}

@end

J2OBJC_FIELD_SETTER(NetI2pDataSigningPublicKey, _type_, NetI2pCryptoSigType *)

inline NetI2pCryptoSigType *NetI2pDataSigningPublicKey_get_DEF_TYPE(void);
static NetI2pCryptoSigType *NetI2pDataSigningPublicKey_DEF_TYPE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pDataSigningPublicKey, DEF_TYPE, NetI2pCryptoSigType *)

inline jint NetI2pDataSigningPublicKey_get_CACHE_SIZE(void);
#define NetI2pDataSigningPublicKey_CACHE_SIZE 1024
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataSigningPublicKey, CACHE_SIZE, jint)

inline NetI2pDataSDSCache *NetI2pDataSigningPublicKey_get__cache(void);
static NetI2pDataSDSCache *NetI2pDataSigningPublicKey__cache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pDataSigningPublicKey, _cache, NetI2pDataSDSCache *)

J2OBJC_INITIALIZED_DEFN(NetI2pDataSigningPublicKey)

jint NetI2pDataSigningPublicKey_KEYSIZE_BYTES;

@implementation NetI2pDataSigningPublicKey

+ (jint)KEYSIZE_BYTES {
  return NetI2pDataSigningPublicKey_KEYSIZE_BYTES;
}

+ (NetI2pDataSigningPublicKey *)createWithByteArray:(IOSByteArray *)data
                                            withInt:(jint)off {
  return NetI2pDataSigningPublicKey_createWithByteArray_withInt_(data, off);
}

+ (NetI2pDataSigningPublicKey *)createWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  return NetI2pDataSigningPublicKey_createWithJavaIoInputStream_(inArg);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pDataSigningPublicKey_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type {
  NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(self, type);
  return self;
}

- (instancetype)initWithByteArray:(IOSByteArray *)data {
  NetI2pDataSigningPublicKey_initWithByteArray_(self, data);
  return self;
}

- (instancetype)initWithNetI2pCryptoSigType:(NetI2pCryptoSigType *)type
                              withByteArray:(IOSByteArray *)data {
  NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(self, type, data);
  return self;
}

- (instancetype)initWithNSString:(NSString *)base64Data {
  NetI2pDataSigningPublicKey_initWithNSString_(self, base64Data);
  return self;
}

- (jint)length {
  if (_type_ != nil) return [_type_ getPubkeyLen];
  if (_data_ != nil) return _data_->size_;
  return NetI2pDataSigningPublicKey_KEYSIZE_BYTES;
}

- (NetI2pCryptoSigType *)getType {
  return _type_;
}

- (NetI2pDataSigningPublicKey *)toTypedKeyWithNetI2pDataKeyCertificate:(NetI2pDataKeyCertificate *)kcert {
  if (_data_ == nil) @throw create_JavaLangIllegalStateException_init();
  NetI2pCryptoSigType *newType = [((NetI2pDataKeyCertificate *) nil_chk(kcert)) getSigType];
  if (_type_ == newType) return self;
  if (_type_ != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"Cannot convert ", _type_, @" to ", newType));
  if (newType == nil) return create_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(nil, _data_);
  jint newLen = [newType getPubkeyLen];
  jint ctype = [kcert getCryptoTypeCode];
  if (ctype == 0) {
    jint sz = 7;
    if (newLen > NetI2pDataSigningPublicKey_KEYSIZE_BYTES) sz += newLen - NetI2pDataSigningPublicKey_KEYSIZE_BYTES;
    if ([kcert size] != sz) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Excess data in key certificate");
  }
  if (newLen == NetI2pDataSigningPublicKey_KEYSIZE_BYTES) return create_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(newType, _data_);
  IOSByteArray *newData = [IOSByteArray arrayWithLength:newLen];
  if (newLen < NetI2pDataSigningPublicKey_KEYSIZE_BYTES) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_data_, ((IOSByteArray *) nil_chk(_data_))->size_ - newLen, newData, 0, newLen);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_data_, 0, newData, 0, ((IOSByteArray *) nil_chk(_data_))->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([kcert getPayload], NetI2pDataKeyCertificate_HEADER_LENGTH, newData, ((IOSByteArray *) nil_chk(_data_))->size_, newLen - _data_->size_);
  }
  return create_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(newType, newData);
}

- (IOSByteArray *)getPaddingWithNetI2pDataKeyCertificate:(NetI2pDataKeyCertificate *)kcert {
  if (_data_ == nil) @throw create_JavaLangIllegalStateException_init();
  NetI2pCryptoSigType *newType = [((NetI2pDataKeyCertificate *) nil_chk(kcert)) getSigType];
  if (_type_ == newType || newType == nil) return nil;
  if (_type_ != JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1)) @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$@", @"Cannot convert ", _type_, @" to ", newType));
  jint newLen = [newType getPubkeyLen];
  if (newLen >= NetI2pDataSigningPublicKey_KEYSIZE_BYTES) return nil;
  jint padLen = NetI2pDataSigningPublicKey_KEYSIZE_BYTES - newLen;
  IOSByteArray *pad = [IOSByteArray arrayWithLength:padLen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_data_, 0, pad, 0, padLen);
  return pad;
}

- (void)writeTruncatedBytesWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (_data_ == nil) @throw create_NetI2pDataDataFormatException_initWithNSString_(@"No data to write out");
  if (_data_->size_ <= NetI2pDataSigningPublicKey_KEYSIZE_BYTES) [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:_data_];
  else [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:_data_ withInt:0 withInt:NetI2pDataSigningPublicKey_KEYSIZE_BYTES];
}

- (NSString *)description {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(64);
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([buf appendWithChar:'['])) appendWithNSString:[[self java_getClass] getSimpleName]])) appendWithChar:' '])) appendWithId:_type_])) appendWithNSString:@": "];
  if (_data_ == nil) {
    [buf appendWithNSString:@"null"];
  }
  else {
    [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@"size: "])) appendWithNSString:JavaLangInteger_toStringWithInt_([self length])];
  }
  [buf appendWithChar:']'];
  return [buf description];
}

+ (void)clearCache {
  NetI2pDataSigningPublicKey_clearCache();
}

- (NSUInteger)hash {
  return NetI2pDataDataHelper_hashCodeWithId_(_type_) ^ ((jint) [super hash]);
}

- (jboolean)isEqual:(id)obj {
  if (obj == self) return true;
  if (obj == nil || !([obj isKindOfClass:[NetI2pDataSigningPublicKey class]])) return false;
  NetI2pDataSigningPublicKey *s = (NetI2pDataSigningPublicKey *) cast_chk(obj, [NetI2pDataSigningPublicKey class]);
  return _type_ == s->_type_ && JavaUtilArrays_equalsWithByteArray_withByteArray_(_data_, s->_data_);
}

- (void)dealloc {
  RELEASE_(_type_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNetI2pDataSigningPublicKey;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSigningPublicKey;", 0x9, 0, 2, 3, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 4, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 6, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 7, 8, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pCryptoSigType;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSigningPublicKey;", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 11, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 13, 14, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 15, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 16, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 17, 18, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(createWithByteArray:withInt:);
  methods[1].selector = @selector(createWithJavaIoInputStream:);
  methods[2].selector = @selector(init);
  methods[3].selector = @selector(initWithNetI2pCryptoSigType:);
  methods[4].selector = @selector(initWithByteArray:);
  methods[5].selector = @selector(initWithNetI2pCryptoSigType:withByteArray:);
  methods[6].selector = @selector(initWithNSString:);
  methods[7].selector = @selector(length);
  methods[8].selector = @selector(getType);
  methods[9].selector = @selector(toTypedKeyWithNetI2pDataKeyCertificate:);
  methods[10].selector = @selector(getPaddingWithNetI2pDataKeyCertificate:);
  methods[11].selector = @selector(writeTruncatedBytesWithJavaIoOutputStream:);
  methods[12].selector = @selector(description);
  methods[13].selector = @selector(clearCache);
  methods[14].selector = @selector(hash);
  methods[15].selector = @selector(isEqual:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEF_TYPE", "LNetI2pCryptoSigType;", .constantValue.asLong = 0, 0x1a, -1, 19, -1, -1 },
    { "KEYSIZE_BYTES", "I", .constantValue.asLong = 0, 0x19, -1, 20, -1, -1 },
    { "CACHE_SIZE", "I", .constantValue.asInt = NetI2pDataSigningPublicKey_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "_cache", "LNetI2pDataSDSCache;", .constantValue.asLong = 0, 0x1a, -1, 21, 22, -1 },
    { "_type_", "LNetI2pCryptoSigType;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "create", "[BI", "LJavaIoInputStream;", "LJavaIoIOException;", "LNetI2pCryptoSigType;", "[B", "LNetI2pCryptoSigType;[B", "LNSString;", "LNetI2pDataDataFormatException;", "toTypedKey", "LNetI2pDataKeyCertificate;", "getPadding", "writeTruncatedBytes", "LJavaIoOutputStream;", "LNetI2pDataDataFormatException;LJavaIoIOException;", "toString", "hashCode", "equals", "LNSObject;", &NetI2pDataSigningPublicKey_DEF_TYPE, &NetI2pDataSigningPublicKey_KEYSIZE_BYTES, &NetI2pDataSigningPublicKey__cache, "Lnet/i2p/data/SDSCache<Lnet/i2p/data/SigningPublicKey;>;" };
  static const J2ObjcClassInfo _NetI2pDataSigningPublicKey = { "SigningPublicKey", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 16, 5, -1, -1, -1, -1, -1 };
  return &_NetI2pDataSigningPublicKey;
}

+ (void)initialize {
  if (self == [NetI2pDataSigningPublicKey class]) {
    JreStrongAssign(&NetI2pDataSigningPublicKey_DEF_TYPE, JreLoadEnum(NetI2pCryptoSigType, DSA_SHA1));
    NetI2pDataSigningPublicKey_KEYSIZE_BYTES = [((NetI2pCryptoSigType *) nil_chk(NetI2pDataSigningPublicKey_DEF_TYPE)) getPubkeyLen];
    JreStrongAssignAndConsume(&NetI2pDataSigningPublicKey__cache, new_NetI2pDataSDSCache_initWithIOSClass_withInt_withInt_(NetI2pDataSigningPublicKey_class_(), NetI2pDataSigningPublicKey_KEYSIZE_BYTES, NetI2pDataSigningPublicKey_CACHE_SIZE));
    J2OBJC_SET_INITIALIZED(NetI2pDataSigningPublicKey)
  }
}

@end

NetI2pDataSigningPublicKey *NetI2pDataSigningPublicKey_createWithByteArray_withInt_(IOSByteArray *data, jint off) {
  NetI2pDataSigningPublicKey_initialize();
  return ((NetI2pDataSigningPublicKey *) [((NetI2pDataSDSCache *) nil_chk(NetI2pDataSigningPublicKey__cache)) getWithByteArray:data withInt:off]);
}

NetI2pDataSigningPublicKey *NetI2pDataSigningPublicKey_createWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  NetI2pDataSigningPublicKey_initialize();
  return ((NetI2pDataSigningPublicKey *) [((NetI2pDataSDSCache *) nil_chk(NetI2pDataSigningPublicKey__cache)) getWithJavaIoInputStream:inArg]);
}

void NetI2pDataSigningPublicKey_init(NetI2pDataSigningPublicKey *self) {
  NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(self, NetI2pDataSigningPublicKey_DEF_TYPE);
}

NetI2pDataSigningPublicKey *new_NetI2pDataSigningPublicKey_init() {
  J2OBJC_NEW_IMPL(NetI2pDataSigningPublicKey, init)
}

NetI2pDataSigningPublicKey *create_NetI2pDataSigningPublicKey_init() {
  J2OBJC_CREATE_IMPL(NetI2pDataSigningPublicKey, init)
}

void NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(NetI2pDataSigningPublicKey *self, NetI2pCryptoSigType *type) {
  NetI2pDataSimpleDataStructure_init(self);
  JreStrongAssign(&self->_type_, type);
}

NetI2pDataSigningPublicKey *new_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(NetI2pCryptoSigType *type) {
  J2OBJC_NEW_IMPL(NetI2pDataSigningPublicKey, initWithNetI2pCryptoSigType_, type)
}

NetI2pDataSigningPublicKey *create_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_(NetI2pCryptoSigType *type) {
  J2OBJC_CREATE_IMPL(NetI2pDataSigningPublicKey, initWithNetI2pCryptoSigType_, type)
}

void NetI2pDataSigningPublicKey_initWithByteArray_(NetI2pDataSigningPublicKey *self, IOSByteArray *data) {
  NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(self, NetI2pDataSigningPublicKey_DEF_TYPE, data);
}

NetI2pDataSigningPublicKey *new_NetI2pDataSigningPublicKey_initWithByteArray_(IOSByteArray *data) {
  J2OBJC_NEW_IMPL(NetI2pDataSigningPublicKey, initWithByteArray_, data)
}

NetI2pDataSigningPublicKey *create_NetI2pDataSigningPublicKey_initWithByteArray_(IOSByteArray *data) {
  J2OBJC_CREATE_IMPL(NetI2pDataSigningPublicKey, initWithByteArray_, data)
}

void NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(NetI2pDataSigningPublicKey *self, NetI2pCryptoSigType *type, IOSByteArray *data) {
  NetI2pDataSimpleDataStructure_init(self);
  JreStrongAssign(&self->_type_, type);
  if (type != nil || data == nil) [self setDataWithByteArray:data];
  else JreStrongAssign(&self->_data_, data);
}

NetI2pDataSigningPublicKey *new_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(NetI2pCryptoSigType *type, IOSByteArray *data) {
  J2OBJC_NEW_IMPL(NetI2pDataSigningPublicKey, initWithNetI2pCryptoSigType_withByteArray_, type, data)
}

NetI2pDataSigningPublicKey *create_NetI2pDataSigningPublicKey_initWithNetI2pCryptoSigType_withByteArray_(NetI2pCryptoSigType *type, IOSByteArray *data) {
  J2OBJC_CREATE_IMPL(NetI2pDataSigningPublicKey, initWithNetI2pCryptoSigType_withByteArray_, type, data)
}

void NetI2pDataSigningPublicKey_initWithNSString_(NetI2pDataSigningPublicKey *self, NSString *base64Data) {
  NetI2pDataSigningPublicKey_init(self);
  [self fromBase64WithNSString:base64Data];
}

NetI2pDataSigningPublicKey *new_NetI2pDataSigningPublicKey_initWithNSString_(NSString *base64Data) {
  J2OBJC_NEW_IMPL(NetI2pDataSigningPublicKey, initWithNSString_, base64Data)
}

NetI2pDataSigningPublicKey *create_NetI2pDataSigningPublicKey_initWithNSString_(NSString *base64Data) {
  J2OBJC_CREATE_IMPL(NetI2pDataSigningPublicKey, initWithNSString_, base64Data)
}

void NetI2pDataSigningPublicKey_clearCache() {
  NetI2pDataSigningPublicKey_initialize();
  [((NetI2pDataSDSCache *) nil_chk(NetI2pDataSigningPublicKey__cache)) clear];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataSigningPublicKey)
