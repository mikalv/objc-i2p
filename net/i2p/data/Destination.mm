//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/Destination.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/InputStream.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/Map.h"
#include "net/i2p/data/Base32.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/KeyCertificate.h"
#include "net/i2p/data/KeysAndCert.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/util/LHMCache.h"
#include "net/i2p/util/SystemVersion.h"

@interface NetI2pDataDestination () {
 @public
  NSString *_cachedB64_;
}

- (instancetype)initWithNetI2pDataPublicKey:(NetI2pDataPublicKey *)pk
             withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)sk
                  withNetI2pDataCertificate:(NetI2pDataCertificate *)c
                              withByteArray:(IOSByteArray *)padding;

@end

J2OBJC_FIELD_SETTER(NetI2pDataDestination, _cachedB64_, NSString *)

inline jint NetI2pDataDestination_get_CACHE_SIZE(void);
static jint NetI2pDataDestination_CACHE_SIZE;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(NetI2pDataDestination, CACHE_SIZE, jint)

inline jint NetI2pDataDestination_get_MIN_CACHE_SIZE(void);
#define NetI2pDataDestination_MIN_CACHE_SIZE 32
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataDestination, MIN_CACHE_SIZE, jint)

inline jint NetI2pDataDestination_get_MAX_CACHE_SIZE(void);
#define NetI2pDataDestination_MAX_CACHE_SIZE 512
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataDestination, MAX_CACHE_SIZE, jint)

inline id<JavaUtilMap> NetI2pDataDestination_get__cache(void);
static id<JavaUtilMap> NetI2pDataDestination__cache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pDataDestination, _cache, id<JavaUtilMap>)

__attribute__((unused)) static void NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataDestination *self, NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding);

__attribute__((unused)) static NetI2pDataDestination *new_NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pDataDestination *create_NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding);

J2OBJC_INITIALIZED_DEFN(NetI2pDataDestination)

@implementation NetI2pDataDestination

+ (NetI2pDataDestination *)createWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  return NetI2pDataDestination_createWithJavaIoInputStream_(inArg);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pDataDestination_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithNSString:(NSString *)s {
  NetI2pDataDestination_initWithNSString_(self, s);
  return self;
}

- (instancetype)initWithNetI2pDataPublicKey:(NetI2pDataPublicKey *)pk
             withNetI2pDataSigningPublicKey:(NetI2pDataSigningPublicKey *)sk
                  withNetI2pDataCertificate:(NetI2pDataCertificate *)c
                              withByteArray:(IOSByteArray *)padding {
  NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(self, pk, sk, c, padding);
  return self;
}

- (jint)writeBytesWithByteArray:(IOSByteArray *)target
                        withInt:(jint)offset {
  jint cur = offset;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataPublicKey *) nil_chk(_publicKey_)) getData], 0, target, cur, NetI2pDataPublicKey_KEYSIZE_BYTES);
  cur += NetI2pDataPublicKey_KEYSIZE_BYTES;
  if (_padding_ != nil) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_padding_, 0, target, cur, _padding_->size_);
    cur += ((IOSByteArray *) nil_chk(_padding_))->size_;
  }
  jint spkTrunc = JavaLangMath_minWithInt_withInt_(JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES), [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) length]);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) getData], 0, target, cur, spkTrunc);
  cur += spkTrunc;
  cur += [((NetI2pDataCertificate *) nil_chk(_certificate_)) writeBytesWithByteArray:target withInt:cur];
  return cur - offset;
}

- (jint)readBytesWithByteArray:(IOSByteArray *)source
                       withInt:(jint)offset {
  if (source == nil) @throw create_NetI2pDataDataFormatException_initWithNSString_(@"Null source");
  if (source->size_ <= offset + NetI2pDataPublicKey_KEYSIZE_BYTES + JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES)) @throw create_NetI2pDataDataFormatException_initWithNSString_(JreStrcat("$I$IC", @"Not enough data (len=", source->size_, @" off=", offset, ')'));
  if (_publicKey_ != nil || _signingKey_ != nil || _certificate_ != nil) @throw create_JavaLangIllegalStateException_init();
  jint cur = offset;
  JreStrongAssign(&_publicKey_, NetI2pDataPublicKey_createWithByteArray_withInt_(source, cur));
  cur += NetI2pDataPublicKey_KEYSIZE_BYTES;
  JreStrongAssign(&_signingKey_, NetI2pDataSigningPublicKey_createWithByteArray_withInt_(source, cur));
  cur += JreLoadStatic(NetI2pDataSigningPublicKey, KEYSIZE_BYTES);
  JreStrongAssign(&_certificate_, NetI2pDataCertificate_createWithByteArray_withInt_(source, cur));
  cur += [((NetI2pDataCertificate *) nil_chk(_certificate_)) size];
  return cur - offset;
}

- (jint)size {
  jint rv = NetI2pDataPublicKey_KEYSIZE_BYTES + [((NetI2pDataSigningPublicKey *) nil_chk(_signingKey_)) length];
  if ([((NetI2pDataCertificate *) nil_chk(_certificate_)) getCertificateType] == NetI2pDataCertificate_CERTIFICATE_TYPE_KEY) {
    rv += 7;
    if (_padding_ != nil) rv += _padding_->size_;
  }
  else {
    rv += [((NetI2pDataCertificate *) nil_chk(_certificate_)) size];
  }
  return rv;
}

- (NSString *)toBase64 {
  if (_cachedB64_ == nil) JreStrongAssign(&_cachedB64_, [super toBase64]);
  return _cachedB64_;
}

- (NSString *)toBase32 {
  @try {
    return JreStrcat("$$", NetI2pDataBase32_encodeWithByteArray_([((NetI2pDataHash *) nil_chk([self getHash])) getData]), @".b32.i2p");
  }
  @catch (JavaLangIllegalStateException *ise) {
    return nil;
  }
}

+ (void)clearCache {
  NetI2pDataDestination_clearCache();
}

- (jboolean)isEqual:(id)o {
  return [super isEqual:o] && ([o isKindOfClass:[NetI2pDataDestination class]]);
}

- (NSUInteger)hash {
  return ((jint) [super hash]);
}

- (void)dealloc {
  RELEASE_(_cachedB64_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNetI2pDataDestination;", 0x9, 0, 1, 2, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, 4, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 8, 7, 4, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(createWithJavaIoInputStream:);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(initWithNSString:);
  methods[3].selector = @selector(initWithNetI2pDataPublicKey:withNetI2pDataSigningPublicKey:withNetI2pDataCertificate:withByteArray:);
  methods[4].selector = @selector(writeBytesWithByteArray:withInt:);
  methods[5].selector = @selector(readBytesWithByteArray:withInt:);
  methods[6].selector = @selector(size);
  methods[7].selector = @selector(toBase64);
  methods[8].selector = @selector(toBase32);
  methods[9].selector = @selector(clearCache);
  methods[10].selector = @selector(isEqual:);
  methods[11].selector = @selector(hash);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_cachedB64_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "CACHE_SIZE", "I", .constantValue.asLong = 0, 0x1a, -1, 12, -1, -1 },
    { "MIN_CACHE_SIZE", "I", .constantValue.asInt = NetI2pDataDestination_MIN_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "MAX_CACHE_SIZE", "I", .constantValue.asInt = NetI2pDataDestination_MAX_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "_cache", "LJavaUtilMap;", .constantValue.asLong = 0, 0x1a, -1, 13, 14, -1 },
  };
  static const void *ptrTable[] = { "create", "LJavaIoInputStream;", "LNetI2pDataDataFormatException;LJavaIoIOException;", "LNSString;", "LNetI2pDataDataFormatException;", "LNetI2pDataPublicKey;LNetI2pDataSigningPublicKey;LNetI2pDataCertificate;[B", "writeBytes", "[BI", "readBytes", "equals", "LNSObject;", "hashCode", &NetI2pDataDestination_CACHE_SIZE, &NetI2pDataDestination__cache, "Ljava/util/Map<Lnet/i2p/data/SigningPublicKey;Lnet/i2p/data/Destination;>;" };
  static const J2ObjcClassInfo _NetI2pDataDestination = { "Destination", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 12, 5, -1, -1, -1, -1, -1 };
  return &_NetI2pDataDestination;
}

+ (void)initialize {
  if (self == [NetI2pDataDestination class]) {
    {
      jlong maxMemory = NetI2pUtilSystemVersion_getMaxMemory();
      NetI2pDataDestination_CACHE_SIZE = (jint) JavaLangMath_minWithLong_withLong_(NetI2pDataDestination_MAX_CACHE_SIZE, JavaLangMath_maxWithLong_withLong_(NetI2pDataDestination_MIN_CACHE_SIZE, maxMemory / 512 * 1024));
    }
    JreStrongAssignAndConsume(&NetI2pDataDestination__cache, new_NetI2pUtilLHMCache_initWithInt_(NetI2pDataDestination_CACHE_SIZE));
    J2OBJC_SET_INITIALIZED(NetI2pDataDestination)
  }
}

@end

NetI2pDataDestination *NetI2pDataDestination_createWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  NetI2pDataDestination_initialize();
  NetI2pDataPublicKey *pk = NetI2pDataPublicKey_createWithJavaIoInputStream_(inArg);
  NetI2pDataSigningPublicKey *sk = NetI2pDataSigningPublicKey_createWithJavaIoInputStream_(inArg);
  NetI2pDataCertificate *c = NetI2pDataCertificate_createWithJavaIoInputStream_(inArg);
  IOSByteArray *padding;
  if ([((NetI2pDataCertificate *) nil_chk(c)) getCertificateType] == NetI2pDataCertificate_CERTIFICATE_TYPE_KEY) {
    NetI2pDataKeyCertificate *kcert = [c toKeyCertificate];
    padding = [((NetI2pDataSigningPublicKey *) nil_chk(sk)) getPaddingWithNetI2pDataKeyCertificate:kcert];
    sk = [sk toTypedKeyWithNetI2pDataKeyCertificate:kcert];
    c = kcert;
  }
  else {
    padding = nil;
  }
  NetI2pDataDestination *rv;
  @synchronized(NetI2pDataDestination__cache) {
    rv = JreRetainedLocalValue([((id<JavaUtilMap>) nil_chk(NetI2pDataDestination__cache)) getWithId:sk]);
    if (rv != nil && [((NetI2pDataPublicKey *) nil_chk([rv getPublicKey])) isEqual:pk] && [((NetI2pDataCertificate *) nil_chk([rv getCertificate])) isEqual:c]) {
      return JreRetainedLocalValue(rv);
    }
    rv = JreRetainedLocalValue(create_NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(pk, sk, c, padding));
    [NetI2pDataDestination__cache putWithId:sk withId:rv];
  }
  return rv;
}

void NetI2pDataDestination_init(NetI2pDataDestination *self) {
  NetI2pDataKeysAndCert_init(self);
}

NetI2pDataDestination *new_NetI2pDataDestination_init() {
  J2OBJC_NEW_IMPL(NetI2pDataDestination, init)
}

NetI2pDataDestination *create_NetI2pDataDestination_init() {
  J2OBJC_CREATE_IMPL(NetI2pDataDestination, init)
}

void NetI2pDataDestination_initWithNSString_(NetI2pDataDestination *self, NSString *s) {
  NetI2pDataKeysAndCert_init(self);
  [self fromBase64WithNSString:s];
}

NetI2pDataDestination *new_NetI2pDataDestination_initWithNSString_(NSString *s) {
  J2OBJC_NEW_IMPL(NetI2pDataDestination, initWithNSString_, s)
}

NetI2pDataDestination *create_NetI2pDataDestination_initWithNSString_(NSString *s) {
  J2OBJC_CREATE_IMPL(NetI2pDataDestination, initWithNSString_, s)
}

void NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataDestination *self, NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding) {
  NetI2pDataKeysAndCert_init(self);
  JreStrongAssign(&self->_publicKey_, pk);
  JreStrongAssign(&self->_signingKey_, sk);
  JreStrongAssign(&self->_certificate_, c);
  JreStrongAssign(&self->_padding_, padding);
}

NetI2pDataDestination *new_NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding) {
  J2OBJC_NEW_IMPL(NetI2pDataDestination, initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_, pk, sk, c, padding)
}

NetI2pDataDestination *create_NetI2pDataDestination_initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_(NetI2pDataPublicKey *pk, NetI2pDataSigningPublicKey *sk, NetI2pDataCertificate *c, IOSByteArray *padding) {
  J2OBJC_CREATE_IMPL(NetI2pDataDestination, initWithNetI2pDataPublicKey_withNetI2pDataSigningPublicKey_withNetI2pDataCertificate_withByteArray_, pk, sk, c, padding)
}

void NetI2pDataDestination_clearCache() {
  NetI2pDataDestination_initialize();
  @synchronized(NetI2pDataDestination__cache) {
    [((id<JavaUtilMap>) nil_chk(NetI2pDataDestination__cache)) clear];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataDestination)
