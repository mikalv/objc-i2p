//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/data/i2np/TunnelDataMessage.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/data/ByteArray.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/data/i2np/FastI2NPMessageImpl.h"
#include "net/i2p/data/i2np/I2NPMessageException.h"
#include "net/i2p/data/i2np/TunnelDataMessage.h"
#include "net/i2p/util/ByteCache.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"

@interface NetI2pDataI2npTunnelDataMessage () {
 @public
  jlong _tunnelId_;
  NetI2pDataTunnelId *_tunnelIdObj_;
  IOSByteArray *_data_;
  NetI2pDataByteArray *_dataBuf_;
  jboolean _hadCache_;
}

@end

J2OBJC_FIELD_SETTER(NetI2pDataI2npTunnelDataMessage, _tunnelIdObj_, NetI2pDataTunnelId *)
J2OBJC_FIELD_SETTER(NetI2pDataI2npTunnelDataMessage, _data_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetI2pDataI2npTunnelDataMessage, _dataBuf_, NetI2pDataByteArray *)

inline jint NetI2pDataI2npTunnelDataMessage_get_EXPIRATION_PERIOD(void);
#define NetI2pDataI2npTunnelDataMessage_EXPIRATION_PERIOD 10000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataI2npTunnelDataMessage, EXPIRATION_PERIOD, jint)

inline NetI2pUtilByteCache *NetI2pDataI2npTunnelDataMessage_get__cache(void);
static NetI2pUtilByteCache *NetI2pDataI2npTunnelDataMessage__cache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pDataI2npTunnelDataMessage, _cache, NetI2pUtilByteCache *)

inline jboolean NetI2pDataI2npTunnelDataMessage_get_PIPELINED_CACHE(void);
#define NetI2pDataI2npTunnelDataMessage_PIPELINED_CACHE true
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataI2npTunnelDataMessage, PIPELINED_CACHE, jboolean)

J2OBJC_INITIALIZED_DEFN(NetI2pDataI2npTunnelDataMessage)

@implementation NetI2pDataI2npTunnelDataMessage

+ (jint)MESSAGE_TYPE {
  return NetI2pDataI2npTunnelDataMessage_MESSAGE_TYPE;
}

+ (jint)DATA_SIZE {
  return NetI2pDataI2npTunnelDataMessage_DATA_SIZE;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context {
  NetI2pDataI2npTunnelDataMessage_initWithNetI2pI2PAppContext_(self, context);
  return self;
}

- (jlong)getTunnelId {
  return _tunnelId_;
}

- (void)setTunnelIdWithLong:(jlong)id_ {
  _hasChecksum_ = false;
  _tunnelId_ = id_;
}

- (NetI2pDataTunnelId *)getTunnelIdObj {
  if (_tunnelIdObj_ == nil) JreStrongAssignAndConsume(&_tunnelIdObj_, new_NetI2pDataTunnelId_initWithLong_(_tunnelId_));
  return _tunnelIdObj_;
}

- (void)setTunnelIdWithNetI2pDataTunnelId:(NetI2pDataTunnelId *)id_ {
  _hasChecksum_ = false;
  JreStrongAssign(&_tunnelIdObj_, id_);
  _tunnelId_ = [((NetI2pDataTunnelId *) nil_chk(id_)) getTunnelId];
}

- (IOSByteArray *)getData {
  if (_hadCache_ && _dataBuf_ == nil) {
    JavaLangRuntimeException *e = create_JavaLangRuntimeException_initWithNSString_(@"TDM data buf use after free");
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:@"TDM boom" withJavaLangThrowable:e];
    @throw e;
  }
  return _data_;
}

- (void)setDataWithByteArray:(IOSByteArray *)data {
  if (_data_ != nil) @throw create_JavaLangIllegalStateException_init();
  if ((data == nil) || (((IOSByteArray *) nil_chk(data))->size_ <= 0)) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Empty tunnel payload?");
  JreStrongAssign(&_data_, data);
}

- (void)readMessageWithByteArray:(IOSByteArray *)data
                         withInt:(jint)offset
                         withInt:(jint)dataSize
                         withInt:(jint)type {
  if (type != NetI2pDataI2npTunnelDataMessage_MESSAGE_TYPE) @throw create_NetI2pDataI2npI2NPMessageException_initWithNSString_(@"Message type is incorrect for this message");
  jint curIndex = offset;
  _tunnelId_ = NetI2pDataDataHelper_fromLongWithByteArray_withInt_withInt_(data, curIndex, 4);
  curIndex += 4;
  if (_tunnelId_ <= 0) @throw create_NetI2pDataI2npI2NPMessageException_initWithNSString_(JreStrcat("$J", @"Invalid tunnel Id ", _tunnelId_));
  {
    JreStrongAssign(&_dataBuf_, [((NetI2pUtilByteCache *) nil_chk(NetI2pDataI2npTunnelDataMessage__cache)) acquire]);
    JreStrongAssign(&_data_, [((NetI2pDataByteArray *) nil_chk(_dataBuf_)) getData]);
    _hadCache_ = true;
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, curIndex, _data_, 0, NetI2pDataI2npTunnelDataMessage_DATA_SIZE);
}

- (jint)calculateWrittenLength {
  return 4 + NetI2pDataI2npTunnelDataMessage_DATA_SIZE;
}

- (jint)writeMessageBodyWithByteArray:(IOSByteArray *)outArg
                              withInt:(jint)curIndex {
  if ((_tunnelId_ <= 0) || (_data_ == nil)) @throw create_NetI2pDataI2npI2NPMessageException_initWithNSString_(JreStrcat("$JC", @"Not enough data to write out (id=", _tunnelId_, ')'));
  if (((IOSByteArray *) nil_chk(_data_))->size_ <= 0) @throw create_NetI2pDataI2npI2NPMessageException_initWithNSString_(JreStrcat("$IC", @"Not enough data to write out (data.length=", _data_->size_, ')'));
  if (_hadCache_ && _dataBuf_ == nil) {
    NetI2pDataI2npI2NPMessageException *e = create_NetI2pDataI2npI2NPMessageException_initWithNSString_(@"TDM data buf use after free");
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:@"TDM boom" withJavaLangThrowable:e];
    @throw e;
  }
  NetI2pDataDataHelper_toLongWithByteArray_withInt_withInt_withLong_(outArg, curIndex, 4, _tunnelId_);
  curIndex += 4;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_data_, 0, outArg, curIndex, NetI2pDataI2npTunnelDataMessage_DATA_SIZE);
  curIndex += ((IOSByteArray *) nil_chk(_data_))->size_;
  return curIndex;
}

- (jint)getType {
  return NetI2pDataI2npTunnelDataMessage_MESSAGE_TYPE;
}

- (NSUInteger)hash {
  return (jint) _tunnelId_ + NetI2pDataDataHelper_hashCodeWithByteArray_(_data_);
}

- (jboolean)isEqual:(id)object {
  if ((object != nil) && ([object isKindOfClass:[NetI2pDataI2npTunnelDataMessage class]])) {
    NetI2pDataI2npTunnelDataMessage *msg = (NetI2pDataI2npTunnelDataMessage *) cast_chk(object, [NetI2pDataI2npTunnelDataMessage class]);
    return _tunnelId_ == [((NetI2pDataI2npTunnelDataMessage *) nil_chk(msg)) getTunnelId] && NetI2pDataDataHelper_eqWithByteArray_withByteArray_([self getData], [msg getData]);
  }
  else {
    return false;
  }
}

- (IOSByteArray *)toByteArray {
  IOSByteArray *rv = [super toByteArray];
  if (rv == nil) @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$$", @"unable to toByteArray(): ", [self description]));
  return rv;
}

- (NSString *)description {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_init();
  [buf appendWithNSString:@"[TunnelDataMessage:"];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@" MessageId: "])) appendWithLong:[self getUniqueId]];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@" Tunnel ID: "])) appendWithLong:_tunnelId_];
  [buf appendWithNSString:@"]"];
  return [buf description];
}

- (void)dealloc {
  RELEASE_(_tunnelIdObj_);
  RELEASE_(_data_);
  RELEASE_(_dataBuf_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataTunnelId;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, 8, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 9, 10, 8, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 14, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pI2PAppContext:);
  methods[1].selector = @selector(getTunnelId);
  methods[2].selector = @selector(setTunnelIdWithLong:);
  methods[3].selector = @selector(getTunnelIdObj);
  methods[4].selector = @selector(setTunnelIdWithNetI2pDataTunnelId:);
  methods[5].selector = @selector(getData);
  methods[6].selector = @selector(setDataWithByteArray:);
  methods[7].selector = @selector(readMessageWithByteArray:withInt:withInt:withInt:);
  methods[8].selector = @selector(calculateWrittenLength);
  methods[9].selector = @selector(writeMessageBodyWithByteArray:withInt:);
  methods[10].selector = @selector(getType);
  methods[11].selector = @selector(hash);
  methods[12].selector = @selector(isEqual:);
  methods[13].selector = @selector(toByteArray);
  methods[14].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_tunnelId_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_tunnelIdObj_", "LNetI2pDataTunnelId;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_data_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_dataBuf_", "LNetI2pDataByteArray;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "MESSAGE_TYPE", "I", .constantValue.asInt = NetI2pDataI2npTunnelDataMessage_MESSAGE_TYPE, 0x19, -1, -1, -1, -1 },
    { "DATA_SIZE", "I", .constantValue.asInt = NetI2pDataI2npTunnelDataMessage_DATA_SIZE, 0x19, -1, -1, -1, -1 },
    { "EXPIRATION_PERIOD", "I", .constantValue.asInt = NetI2pDataI2npTunnelDataMessage_EXPIRATION_PERIOD, 0x1a, -1, -1, -1, -1 },
    { "_cache", "LNetI2pUtilByteCache;", .constantValue.asLong = 0, 0x1a, -1, 15, -1, -1 },
    { "PIPELINED_CACHE", "Z", .constantValue.asBOOL = NetI2pDataI2npTunnelDataMessage_PIPELINED_CACHE, 0x1a, -1, -1, -1, -1 },
    { "_hadCache_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pI2PAppContext;", "setTunnelId", "J", "LNetI2pDataTunnelId;", "setData", "[B", "readMessage", "[BIII", "LNetI2pDataI2npI2NPMessageException;", "writeMessageBody", "[BI", "hashCode", "equals", "LNSObject;", "toString", &NetI2pDataI2npTunnelDataMessage__cache };
  static const J2ObjcClassInfo _NetI2pDataI2npTunnelDataMessage = { "TunnelDataMessage", "net.i2p.data.i2np", ptrTable, methods, fields, 7, 0x1, 15, 10, -1, -1, -1, -1, -1 };
  return &_NetI2pDataI2npTunnelDataMessage;
}

+ (void)initialize {
  if (self == [NetI2pDataI2npTunnelDataMessage class]) {
    {
      JreStrongAssign(&NetI2pDataI2npTunnelDataMessage__cache, NetI2pUtilByteCache_getInstanceWithInt_withInt_(512, NetI2pDataI2npTunnelDataMessage_DATA_SIZE));
    }
    J2OBJC_SET_INITIALIZED(NetI2pDataI2npTunnelDataMessage)
  }
}

@end

void NetI2pDataI2npTunnelDataMessage_initWithNetI2pI2PAppContext_(NetI2pDataI2npTunnelDataMessage *self, NetI2pI2PAppContext *context) {
  NetI2pDataI2npFastI2NPMessageImpl_initWithNetI2pI2PAppContext_(self, context);
  [self setMessageExpirationWithLong:[((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) clock])) now] + NetI2pDataI2npTunnelDataMessage_EXPIRATION_PERIOD];
}

NetI2pDataI2npTunnelDataMessage *new_NetI2pDataI2npTunnelDataMessage_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_NEW_IMPL(NetI2pDataI2npTunnelDataMessage, initWithNetI2pI2PAppContext_, context)
}

NetI2pDataI2npTunnelDataMessage *create_NetI2pDataI2npTunnelDataMessage_initWithNetI2pI2PAppContext_(NetI2pI2PAppContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pDataI2npTunnelDataMessage, initWithNetI2pI2PAppContext_, context)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataI2npTunnelDataMessage)
