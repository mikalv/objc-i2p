//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/data/Hash.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/InputStream.h"
#include "net/i2p/data/Base32.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/SDSCache.h"
#include "net/i2p/data/SimpleDataStructure.h"

@interface NetI2pDataHash () {
 @public
  volatile_id _base64ed_;
  jint _cachedHashCode_;
}

@end

J2OBJC_VOLATILE_FIELD_SETTER(NetI2pDataHash, _base64ed_, NSString *)

inline jint NetI2pDataHash_get_CACHE_SIZE(void);
#define NetI2pDataHash_CACHE_SIZE 2048
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pDataHash, CACHE_SIZE, jint)

inline NetI2pDataSDSCache *NetI2pDataHash_get__cache(void);
static NetI2pDataSDSCache *NetI2pDataHash__cache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pDataHash, _cache, NetI2pDataSDSCache *)

J2OBJC_INITIALIZED_DEFN(NetI2pDataHash)

NetI2pDataHash *NetI2pDataHash_FAKE_HASH;

@implementation NetI2pDataHash

+ (jint)HASH_LENGTH {
  return NetI2pDataHash_HASH_LENGTH;
}

+ (NetI2pDataHash *)FAKE_HASH {
  return NetI2pDataHash_FAKE_HASH;
}

+ (NetI2pDataHash *)createWithByteArray:(IOSByteArray *)data {
  return NetI2pDataHash_createWithByteArray_(data);
}

+ (NetI2pDataHash *)createWithByteArray:(IOSByteArray *)data
                                withInt:(jint)off {
  return NetI2pDataHash_createWithByteArray_withInt_(data, off);
}

+ (NetI2pDataHash *)createWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  return NetI2pDataHash_createWithJavaIoInputStream_(inArg);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pDataHash_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithByteArray:(IOSByteArray *)data {
  NetI2pDataHash_initWithByteArray_(self, data);
  return self;
}

- (jint)length {
  return NetI2pDataHash_HASH_LENGTH;
}

- (void)setDataWithByteArray:(IOSByteArray *)data {
  [super setDataWithByteArray:data];
  JreVolatileStrongAssign(&_base64ed_, nil);
  _cachedHashCode_ = ((jint) [super hash]);
}

- (void)readBytesWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  [super readBytesWithJavaIoInputStream:inArg];
  JreVolatileStrongAssign(&_base64ed_, nil);
  _cachedHashCode_ = ((jint) [super hash]);
}

- (NSUInteger)hash {
  return _cachedHashCode_;
}

- (NSString *)toBase64 {
  if (JreLoadVolatileId(&_base64ed_) == nil) {
    JreVolatileStrongAssign(&_base64ed_, [super toBase64]);
  }
  return JreLoadVolatileId(&_base64ed_);
}

- (NSString *)toBase32 {
  if (_data_ == nil) return nil;
  return JreStrcat("$$", NetI2pDataBase32_encodeWithByteArray_(_data_), @".b32.i2p");
}

+ (void)clearCache {
  NetI2pDataHash_clearCache();
}

- (void)__javaClone:(NetI2pDataHash *)original {
  [super __javaClone:original];
  JreCloneVolatileStrong(&_base64ed_, &original->_base64ed_);
}

- (void)dealloc {
  JreReleaseVolatile(&_base64ed_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNetI2pDataHash;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataHash;", 0x9, 0, 2, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataHash;", 0x9, 0, 3, 4, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 3, 7, -1, -1, -1 },
    { NULL, "I", 0x1, 8, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(createWithByteArray:);
  methods[1].selector = @selector(createWithByteArray:withInt:);
  methods[2].selector = @selector(createWithJavaIoInputStream:);
  methods[3].selector = @selector(init);
  methods[4].selector = @selector(initWithByteArray:);
  methods[5].selector = @selector(length);
  methods[6].selector = @selector(setDataWithByteArray:);
  methods[7].selector = @selector(readBytesWithJavaIoInputStream:);
  methods[8].selector = @selector(hash);
  methods[9].selector = @selector(toBase64);
  methods[10].selector = @selector(toBase32);
  methods[11].selector = @selector(clearCache);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_base64ed_", "LNSString;", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "_cachedHashCode_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "HASH_LENGTH", "I", .constantValue.asInt = NetI2pDataHash_HASH_LENGTH, 0x19, -1, -1, -1, -1 },
    { "FAKE_HASH", "LNetI2pDataHash;", .constantValue.asLong = 0, 0x19, -1, 9, -1, -1 },
    { "CACHE_SIZE", "I", .constantValue.asInt = NetI2pDataHash_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "_cache", "LNetI2pDataSDSCache;", .constantValue.asLong = 0, 0x1a, -1, 10, 11, -1 },
  };
  static const void *ptrTable[] = { "create", "[B", "[BI", "LJavaIoInputStream;", "LJavaIoIOException;", "setData", "readBytes", "LNetI2pDataDataFormatException;LJavaIoIOException;", "hashCode", &NetI2pDataHash_FAKE_HASH, &NetI2pDataHash__cache, "Lnet/i2p/data/SDSCache<Lnet/i2p/data/Hash;>;" };
  static const J2ObjcClassInfo _NetI2pDataHash = { "Hash", "net.i2p.data", ptrTable, methods, fields, 7, 0x1, 12, 6, -1, -1, -1, -1, -1 };
  return &_NetI2pDataHash;
}

+ (void)initialize {
  if (self == [NetI2pDataHash class]) {
    JreStrongAssignAndConsume(&NetI2pDataHash_FAKE_HASH, new_NetI2pDataHash_initWithByteArray_([IOSByteArray arrayWithLength:NetI2pDataHash_HASH_LENGTH]));
    JreStrongAssignAndConsume(&NetI2pDataHash__cache, new_NetI2pDataSDSCache_initWithIOSClass_withInt_withInt_(NetI2pDataHash_class_(), NetI2pDataHash_HASH_LENGTH, NetI2pDataHash_CACHE_SIZE));
    J2OBJC_SET_INITIALIZED(NetI2pDataHash)
  }
}

@end

NetI2pDataHash *NetI2pDataHash_createWithByteArray_(IOSByteArray *data) {
  NetI2pDataHash_initialize();
  return ((NetI2pDataHash *) [((NetI2pDataSDSCache *) nil_chk(NetI2pDataHash__cache)) getWithByteArray:data]);
}

NetI2pDataHash *NetI2pDataHash_createWithByteArray_withInt_(IOSByteArray *data, jint off) {
  NetI2pDataHash_initialize();
  return ((NetI2pDataHash *) [((NetI2pDataSDSCache *) nil_chk(NetI2pDataHash__cache)) getWithByteArray:data withInt:off]);
}

NetI2pDataHash *NetI2pDataHash_createWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  NetI2pDataHash_initialize();
  return ((NetI2pDataHash *) [((NetI2pDataSDSCache *) nil_chk(NetI2pDataHash__cache)) getWithJavaIoInputStream:inArg]);
}

void NetI2pDataHash_init(NetI2pDataHash *self) {
  NetI2pDataSimpleDataStructure_init(self);
}

NetI2pDataHash *new_NetI2pDataHash_init() {
  J2OBJC_NEW_IMPL(NetI2pDataHash, init)
}

NetI2pDataHash *create_NetI2pDataHash_init() {
  J2OBJC_CREATE_IMPL(NetI2pDataHash, init)
}

void NetI2pDataHash_initWithByteArray_(NetI2pDataHash *self, IOSByteArray *data) {
  NetI2pDataSimpleDataStructure_init(self);
  [self setDataWithByteArray:data];
}

NetI2pDataHash *new_NetI2pDataHash_initWithByteArray_(IOSByteArray *data) {
  J2OBJC_NEW_IMPL(NetI2pDataHash, initWithByteArray_, data)
}

NetI2pDataHash *create_NetI2pDataHash_initWithByteArray_(IOSByteArray *data) {
  J2OBJC_CREATE_IMPL(NetI2pDataHash, initWithByteArray_, data)
}

void NetI2pDataHash_clearCache() {
  NetI2pDataHash_initialize();
  [((NetI2pDataSDSCache *) nil_chk(NetI2pDataHash__cache)) clear];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pDataHash)
