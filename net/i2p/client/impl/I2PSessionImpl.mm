//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: core/java/src/net/i2p/client/impl/I2PSessionImpl.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/Boolean.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/Enum.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalAccessException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InstantiationException.h"
#include "java/lang/Integer.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/Long.h"
#include "java/lang/NoSuchMethodException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/lang/Throwable.h"
#include "java/lang/reflect/Constructor.h"
#include "java/lang/reflect/InvocationTargetException.h"
#include "java/lang/reflect/Method.h"
#include "java/net/Socket.h"
#include "java/net/UnknownHostException.h"
#include "java/security/GeneralSecurityException.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/Map.h"
#include "java/util/Properties.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/CopyOnWriteArrayList.h"
#include "java/util/concurrent/LinkedBlockingQueue.h"
#include "java/util/concurrent/atomic/AtomicInteger.h"
#include "net/i2p/CoreVersion.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/client/I2PClient.h"
#include "net/i2p/client/I2PSession.h"
#include "net/i2p/client/I2PSessionException.h"
#include "net/i2p/client/I2PSessionListener.h"
#include "net/i2p/client/impl/ClientWriterRunner.h"
#include "net/i2p/client/impl/I2CPMessageHandler.h"
#include "net/i2p/client/impl/I2CPMessageProducer.h"
#include "net/i2p/client/impl/I2PClientMessageHandlerMap.h"
#include "net/i2p/client/impl/I2PSessionImpl.h"
#include "net/i2p/client/impl/SessionIdleTimer.h"
#include "net/i2p/client/impl/SubSession.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/Base32.h"
#include "net/i2p/data/DataFormatException.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/Payload.h"
#include "net/i2p/data/PrivateKey.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/SigningPublicKey.h"
#include "net/i2p/data/i2cp/DestLookupMessage.h"
#include "net/i2p/data/i2cp/DestReplyMessage.h"
#include "net/i2p/data/i2cp/GetBandwidthLimitsMessage.h"
#include "net/i2p/data/i2cp/GetDateMessage.h"
#include "net/i2p/data/i2cp/HostLookupMessage.h"
#include "net/i2p/data/i2cp/HostReplyMessage.h"
#include "net/i2p/data/i2cp/I2CPMessage.h"
#include "net/i2p/data/i2cp/I2CPMessageReader.h"
#include "net/i2p/data/i2cp/MessagePayloadMessage.h"
#include "net/i2p/data/i2cp/SessionId.h"
#include "net/i2p/data/i2cp/SessionStatusMessage.h"
#include "net/i2p/internal/I2CPMessageQueue.h"
#include "net/i2p/internal/InternalClientManager.h"
#include "net/i2p/internal/QueuedI2CPMessageReader.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/I2PAppThread.h"
#include "net/i2p/util/I2PSSLSocketFactory.h"
#include "net/i2p/util/KeyRing.h"
#include "net/i2p/util/LHMCache.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/OrderedProperties.h"
#include "net/i2p/util/SimpleTimer2.h"
#include "net/i2p/util/SystemVersion.h"
#include "net/i2p/util/VersionComparator.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface NetI2pClientImplI2PSessionImpl () {
 @public
  NetI2pDataDestination *_myDestination_;
  NetI2pDataPrivateKey *_privateKey_;
  NetI2pDataSigningPrivateKey *_signingPrivateKey_;
  JavaUtilProperties *_options_;
  NetI2pDataI2cpSessionId *_sessionId_;
  id<JavaUtilList> _subsessions_;
  JavaUtilConcurrentConcurrentHashMap *_subsessionMap_;
  id _subsessionLock_;
  volatile_jboolean _routerSupportsSubsessions_;
  JavaUtilConcurrentAtomicAtomicInteger *_lookupID_;
  jlong _lastActivity_;
  jboolean _isReduced_;
  jboolean _fastReceive_;
  volatile_jboolean _routerSupportsFastReceive_;
  volatile_jboolean _routerSupportsHostLookup_;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                     withJavaUtilProperties:(JavaUtilProperties *)options
withNetI2pClientImplI2PClientMessageHandlerMap:(NetI2pClientImplI2PClientMessageHandlerMap *)handlerMap
    withNetI2pClientImplI2CPMessageProducer:(NetI2pClientImplI2CPMessageProducer *)producer
                                withBoolean:(jboolean)hasDest;

- (JavaUtilProperties *)loadConfigWithJavaUtilProperties:(JavaUtilProperties *)opts;

- (NSString *)getHost;

- (jint)getPort;

- (JavaUtilProperties *)filterWithJavaUtilProperties:(JavaUtilProperties *)options;

- (void)readDestinationWithJavaIoInputStream:(JavaIoInputStream *)destKeyStream;

- (void)closeSocket;

- (void)locked_closeSocket;

- (void)startIdleMonitor;

@end

J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _myDestination_, NetI2pDataDestination *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _privateKey_, NetI2pDataPrivateKey *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _signingPrivateKey_, NetI2pDataSigningPrivateKey *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _options_, JavaUtilProperties *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _sessionId_, NetI2pDataI2cpSessionId *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _subsessions_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _subsessionMap_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _subsessionLock_, id)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl, _lookupID_, JavaUtilConcurrentAtomicAtomicInteger *)

inline NSString *NetI2pClientImplI2PSessionImpl_get_MIN_SUBSESSION_VERSION(void);
static NSString *NetI2pClientImplI2PSessionImpl_MIN_SUBSESSION_VERSION = @"0.9.21";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pClientImplI2PSessionImpl, MIN_SUBSESSION_VERSION, NSString *)

inline id<JavaUtilMap> NetI2pClientImplI2PSessionImpl_get__lookupCache(void);
static id<JavaUtilMap> NetI2pClientImplI2PSessionImpl__lookupCache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pClientImplI2PSessionImpl, _lookupCache, id<JavaUtilMap>)

inline NSString *NetI2pClientImplI2PSessionImpl_get_MIN_HOST_LOOKUP_VERSION(void);
static NSString *NetI2pClientImplI2PSessionImpl_MIN_HOST_LOOKUP_VERSION = @"0.9.11";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pClientImplI2PSessionImpl, MIN_HOST_LOOKUP_VERSION, NSString *)

inline jboolean NetI2pClientImplI2PSessionImpl_get_TEST_LOOKUP(void);
#define NetI2pClientImplI2PSessionImpl_TEST_LOOKUP false
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, TEST_LOOKUP, jboolean)

inline jlong NetI2pClientImplI2PSessionImpl_get_VERIFY_USAGE_TIME(void);
#define NetI2pClientImplI2PSessionImpl_VERIFY_USAGE_TIME 60000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, VERIFY_USAGE_TIME, jlong)

inline jlong NetI2pClientImplI2PSessionImpl_get_MAX_SEND_WAIT(void);
#define NetI2pClientImplI2PSessionImpl_MAX_SEND_WAIT 10000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, MAX_SEND_WAIT, jlong)

inline NSString *NetI2pClientImplI2PSessionImpl_get_MIN_FAST_VERSION(void);
static NSString *NetI2pClientImplI2PSessionImpl_MIN_FAST_VERSION = @"0.9.4";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pClientImplI2PSessionImpl, MIN_FAST_VERSION, NSString *)

inline jint NetI2pClientImplI2PSessionImpl_get_BUF_SIZE(void);
#define NetI2pClientImplI2PSessionImpl_BUF_SIZE 32768
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, BUF_SIZE, jint)

inline jint NetI2pClientImplI2PSessionImpl_get_MAX_RECONNECT_DELAY(void);
#define NetI2pClientImplI2PSessionImpl_MAX_RECONNECT_DELAY 320000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, MAX_RECONNECT_DELAY, jint)

inline jint NetI2pClientImplI2PSessionImpl_get_BASE_RECONNECT_DELAY(void);
#define NetI2pClientImplI2PSessionImpl_BASE_RECONNECT_DELAY 10000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pClientImplI2PSessionImpl, BASE_RECONNECT_DELAY, jint)

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(NetI2pClientImplI2PSessionImpl *self, NetI2pI2PAppContext *context, JavaUtilProperties *options, NetI2pClientImplI2PClientMessageHandlerMap *handlerMap, NetI2pClientImplI2CPMessageProducer *producer, jboolean hasDest);

__attribute__((unused)) static JavaUtilProperties *NetI2pClientImplI2PSessionImpl_loadConfigWithJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, JavaUtilProperties *opts);

__attribute__((unused)) static NSString *NetI2pClientImplI2PSessionImpl_getHost(NetI2pClientImplI2PSessionImpl *self);

__attribute__((unused)) static jint NetI2pClientImplI2PSessionImpl_getPort(NetI2pClientImplI2PSessionImpl *self);

__attribute__((unused)) static JavaUtilProperties *NetI2pClientImplI2PSessionImpl_filterWithJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, JavaUtilProperties *options);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_readDestinationWithJavaIoInputStream_(NetI2pClientImplI2PSessionImpl *self, JavaIoInputStream *destKeyStream);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_closeSocket(NetI2pClientImplI2PSessionImpl *self);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_locked_closeSocket(NetI2pClientImplI2PSessionImpl *self);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_startIdleMonitor(NetI2pClientImplI2PSessionImpl *self);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_State_initWithNSString_withInt_(NetI2pClientImplI2PSessionImpl_State *self, NSString *__name, jint __ordinal);

@interface NetI2pClientImplI2PSessionImpl_VerifyUsage : NetI2pUtilSimpleTimer2_TimedEvent {
 @public
  NetI2pClientImplI2PSessionImpl *this$0_;
  id<JavaUtilList> toCheck_;
}

- (instancetype)initWithNetI2pClientImplI2PSessionImpl:(NetI2pClientImplI2PSessionImpl *)outer$;

- (void)timeReached;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pClientImplI2PSessionImpl_VerifyUsage)

J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_VerifyUsage, toCheck_, id<JavaUtilList>)

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl_VerifyUsage *self, NetI2pClientImplI2PSessionImpl *outer$);

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_VerifyUsage *new_NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_VerifyUsage *create_NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pClientImplI2PSessionImpl_VerifyUsage)

@interface NetI2pClientImplI2PSessionImpl_AvailabilityNotifier () {
 @public
  NetI2pClientImplI2PSessionImpl *this$0_;
  id<JavaUtilList> _pendingIds_;
  id<JavaUtilList> _pendingSizes_;
  volatile_jboolean _alive_;
}

@end

J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier, _pendingIds_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier, _pendingSizes_, id<JavaUtilList>)

@interface NetI2pClientImplI2PSessionImpl_LookupWaiter : NSObject {
 @public
  NetI2pDataHash *hash__;
  NSString *name_;
  jlong nonce_;
  NetI2pDataDestination *destination_;
}

- (instancetype)initWithNetI2pDataHash:(NetI2pDataHash *)h;

- (instancetype)initWithNetI2pDataHash:(NetI2pDataHash *)h
                              withLong:(jlong)nonce;

- (instancetype)initWithNSString:(NSString *)name
                        withLong:(jlong)nonce;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pClientImplI2PSessionImpl_LookupWaiter)

J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_LookupWaiter, hash__, NetI2pDataHash *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_LookupWaiter, name_, NSString *)
J2OBJC_FIELD_SETTER(NetI2pClientImplI2PSessionImpl_LookupWaiter, destination_, NetI2pDataDestination *)

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NetI2pDataHash *h);

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pDataHash *h) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pDataHash *h);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NetI2pDataHash *h, jlong nonce);

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pDataHash *h, jlong nonce) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pDataHash *h, jlong nonce);

__attribute__((unused)) static void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NSString *name, jlong nonce);

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NSString *name, jlong nonce) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NSString *name, jlong nonce);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pClientImplI2PSessionImpl_LookupWaiter)

J2OBJC_INITIALIZED_DEFN(NetI2pClientImplI2PSessionImpl)

jint NetI2pClientImplI2PSessionImpl_CACHE_MAX_SIZE;
NSString *NetI2pClientImplI2PSessionImpl_PROP_ENABLE_SSL = @"i2cp.SSL";
NSString *NetI2pClientImplI2PSessionImpl_PROP_USER = @"i2cp.username";
NSString *NetI2pClientImplI2PSessionImpl_PROP_PW = @"i2cp.password";
NSString *NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET = @"i2cp.domainSocket";

@implementation NetI2pClientImplI2PSessionImpl

+ (jint)CACHE_MAX_SIZE {
  return NetI2pClientImplI2PSessionImpl_CACHE_MAX_SIZE;
}

+ (NSString *)PROP_ENABLE_SSL {
  return NetI2pClientImplI2PSessionImpl_PROP_ENABLE_SSL;
}

+ (NSString *)PROP_USER {
  return NetI2pClientImplI2PSessionImpl_PROP_USER;
}

+ (NSString *)PROP_PW {
  return NetI2pClientImplI2PSessionImpl_PROP_PW;
}

+ (NSString *)PROP_DOMAIN_SOCKET {
  return NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET;
}

+ (jint)LISTEN_PORT {
  return NetI2pClientImplI2PSessionImpl_LISTEN_PORT;
}

- (void)dateUpdatedWithNSString:(NSString *)routerVersion {
  JreAssignVolatileBoolean(&_routerSupportsFastReceive_, [((NetI2pI2PAppContext *) nil_chk(_context_)) isRouterContext] || (routerVersion != nil && [routerVersion java_length] > 0 && NetI2pUtilVersionComparator_compWithNSString_withNSString_(routerVersion, NetI2pClientImplI2PSessionImpl_MIN_FAST_VERSION) >= 0));
  JreAssignVolatileBoolean(&_routerSupportsHostLookup_, [_context_ isRouterContext] || (routerVersion != nil && [routerVersion java_length] > 0 && NetI2pUtilVersionComparator_compWithNSString_withNSString_(routerVersion, NetI2pClientImplI2PSessionImpl_MIN_HOST_LOOKUP_VERSION) >= 0));
  JreAssignVolatileBoolean(&_routerSupportsSubsessions_, [_context_ isRouterContext] || (routerVersion != nil && [routerVersion java_length] > 0 && NetI2pUtilVersionComparator_compWithNSString_withNSString_(routerVersion, NetI2pClientImplI2PSessionImpl_MIN_SUBSESSION_VERSION) >= 0));
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING)) {
      [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, GOTDATE)];
    }
  }
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                     withJavaUtilProperties:(JavaUtilProperties *)options
withNetI2pClientImplI2PClientMessageHandlerMap:(NetI2pClientImplI2PClientMessageHandlerMap *)handlerMap {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_(self, context, options, handlerMap);
  return self;
}

- (instancetype)initWithNetI2pClientImplI2PSessionImpl:(NetI2pClientImplI2PSessionImpl *)primary
                                 withJavaIoInputStream:(JavaIoInputStream *)destKeyStream
                                withJavaUtilProperties:(JavaUtilProperties *)options {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pClientImplI2PSessionImpl_withJavaIoInputStream_withJavaUtilProperties_(self, primary, destKeyStream, options);
  return self;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                     withJavaUtilProperties:(JavaUtilProperties *)options
withNetI2pClientImplI2PClientMessageHandlerMap:(NetI2pClientImplI2PClientMessageHandlerMap *)handlerMap
    withNetI2pClientImplI2CPMessageProducer:(NetI2pClientImplI2CPMessageProducer *)producer
                                withBoolean:(jboolean)hasDest {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(self, context, options, handlerMap, producer, hasDest);
  return self;
}

- (instancetype)initWithNetI2pI2PAppContext:(NetI2pI2PAppContext *)context
                      withJavaIoInputStream:(JavaIoInputStream *)destKeyStream
                     withJavaUtilProperties:(JavaUtilProperties *)options {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaIoInputStream_withJavaUtilProperties_(self, context, destKeyStream, options);
  return self;
}

- (id<NetI2pClientI2PSession>)addSubsessionWithJavaIoInputStream:(JavaIoInputStream *)privateKeyStream
                                          withJavaUtilProperties:(JavaUtilProperties *)opts {
  if (!JreLoadVolatileBoolean(&_routerSupportsSubsessions_)) @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Router does not support subsessions");
  NetI2pClientImplSubSession *sub;
  @synchronized(_subsessionLock_) {
    if ([((id<JavaUtilList>) nil_chk(_subsessions_)) size] > [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_subsessionMap_)) size]) @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Subsession request already pending");
    sub = JreRetainedLocalValue(create_NetI2pClientImplSubSession_initWithNetI2pClientI2PSession_withJavaIoInputStream_withJavaUtilProperties_(self, privateKeyStream, opts));
    for (NetI2pClientImplSubSession * __strong ss in _subsessions_) {
      if ([((NetI2pDataPrivateKey *) nil_chk([((NetI2pClientImplSubSession *) nil_chk(ss)) getDecryptionKey])) isEqual:[sub getDecryptionKey]] && [((NetI2pDataSigningPrivateKey *) nil_chk([ss getPrivateKey])) isEqual:[sub getPrivateKey]]) {
        @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Dup subsession");
      }
    }
    [_subsessions_ addWithId:sub];
  }
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPEN)) {
      [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) connectWithNetI2pClientImplI2PSessionImpl:sub];
    }
  }
  return sub;
}

- (void)removeSubsessionWithNetI2pClientI2PSession:(id<NetI2pClientI2PSession>)session {
  if (!([session isKindOfClass:[NetI2pClientImplSubSession class]])) return;
  @synchronized(_subsessionLock_) {
    [((id<JavaUtilList>) nil_chk(_subsessions_)) removeWithId:session];
    NetI2pDataI2cpSessionId *id_ = [((NetI2pClientImplSubSession *) nil_chk(((NetI2pClientImplSubSession *) cast_chk(session, [NetI2pClientImplSubSession class])))) getSessionId];
    if (id_ != nil) [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_subsessionMap_)) removeWithId:id_];
    @try {
      [((id<NetI2pClientI2PSession>) nil_chk(session)) destroySession];
    }
    @catch (NetI2pClientI2PSessionException *ise) {
    }
  }
  NetI2pDataDestination *d = [session getMyDestination];
  if (d != nil) [((NetI2pUtilKeyRing *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) keyRing])) removeWithId:[d calculateHash]];
}

- (id<JavaUtilList>)getSubsessions {
  @synchronized(_subsessionLock_) {
    return JreRetainedLocalValue(create_JavaUtilArrayList_initWithJavaUtilCollection_(_subsessions_));
  }
}

- (JavaUtilProperties *)loadConfigWithJavaUtilProperties:(JavaUtilProperties *)opts {
  return NetI2pClientImplI2PSessionImpl_loadConfigWithJavaUtilProperties_(self, opts);
}

- (NSString *)getHost {
  return NetI2pClientImplI2PSessionImpl_getHost(self);
}

- (jint)getPort {
  return NetI2pClientImplI2PSessionImpl_getPort(self);
}

- (JavaUtilProperties *)filterWithJavaUtilProperties:(JavaUtilProperties *)options {
  return NetI2pClientImplI2PSessionImpl_filterWithJavaUtilProperties_(self, options);
}

- (void)updateOptionsWithJavaUtilProperties:(JavaUtilProperties *)options {
  [((JavaUtilProperties *) nil_chk(_options_)) putAllWithJavaUtilMap:NetI2pClientImplI2PSessionImpl_filterWithJavaUtilProperties_(self, options)];
  [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) updateBandwidthWithNetI2pClientImplI2PSessionImpl:self];
  @try {
    [_producer_ updateTunnelsWithNetI2pClientImplI2PSessionImpl:self withInt:0];
  }
  @catch (NetI2pClientI2PSessionException *ise) {
  }
}

- (jboolean)getFastReceive {
  return _fastReceive_ && JreLoadVolatileBoolean(&_routerSupportsFastReceive_);
}

- (void)setLeaseSetWithNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)ls {
  JreVolatileStrongAssign(&_leaseSet_, ls);
  if (ls != nil) {
    @synchronized(_leaseSetWait_) {
      [nil_chk(_leaseSetWait_) java_notifyAll];
    }
  }
}

- (NetI2pDataLeaseSet *)getLeaseSet {
  return JreLoadVolatileId(&_leaseSet_);
}

- (void)changeStateWithNetI2pClientImplI2PSessionImpl_State:(NetI2pClientImplI2PSessionImpl_State *)state {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldInfo]) [_log_ infoWithNSString:JreStrcat("$$@", [self getPrefix], @"Change state to ", state)];
  @synchronized(_stateLock_) {
    JreStrongAssign(&_state_, state);
    [nil_chk(_stateLock_) java_notifyAll];
  }
}

- (void)readDestinationWithJavaIoInputStream:(JavaIoInputStream *)destKeyStream {
  NetI2pClientImplI2PSessionImpl_readDestinationWithJavaIoInputStream_(self, destKeyStream);
}

- (void)connect {
  @synchronized(_stateLock_) {
    jboolean wasOpening = false;
    jboolean loop = true;
    while (loop) {
      switch ([_state_ ordinal]) {
        case NetI2pClientImplI2PSessionImpl_State_Enum_INIT:
        loop = false;
        break;
        case NetI2pClientImplI2PSessionImpl_State_Enum_CLOSED:
        if (wasOpening) @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"connect by other thread failed");
        loop = false;
        break;
        case NetI2pClientImplI2PSessionImpl_State_Enum_OPENING:
        case NetI2pClientImplI2PSessionImpl_State_Enum_GOTDATE:
        wasOpening = true;
        @try {
          [nil_chk(_stateLock_) java_waitWithLong:10 * 1000];
        }
        @catch (JavaLangInterruptedException *ie) {
          @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
        }
        break;
        case NetI2pClientImplI2PSessionImpl_State_Enum_CLOSING:
        @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"close in progress");
        case NetI2pClientImplI2PSessionImpl_State_Enum_OPEN:
        return;
      }
    }
    [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING)];
  }
  [((NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *) nil_chk(_availabilityNotifier_)) stopNotifying];
  if ((_options_ != nil) && ([((NSString *) nil_chk(NetI2pClientI2PClient_PROP_RELIABILITY_GUARANTEED)) isEqual:[((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientI2PClient_PROP_RELIABILITY withNSString:NetI2pClientI2PClient_PROP_RELIABILITY_BEST_EFFORT]])) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"I2CP guaranteed delivery mode has been removed, using best effort."];
  }
  jboolean success = false;
  jlong startConnect = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) clock])) now];
  @try {
    @synchronized(_stateLock_) {
      if ([_context_ isRouterContext]) {
        id<NetI2pInternalInternalClientManager> mgr = [_context_ internalClientManager];
        if (mgr == nil) @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Router is not ready for connections");
        JreStrongAssign(&_queue_, [mgr connect]);
        JreStrongAssignAndConsume(&_reader_, new_NetI2pInternalQueuedI2CPMessageReader_initWithNetI2pInternalI2CPMessageQueue_withNetI2pDataI2cpI2CPMessageReader_I2CPMessageEventListener_(_queue_, self));
      }
      else {
        if (NetI2pUtilSystemVersion_isAndroid() && [((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET] != nil) {
          @try {
            IOSClass *clazz = IOSClass_forName_(@"net.i2p.client.DomainSocketFactory");
            JavaLangReflectConstructor *ctor = [((IOSClass *) nil_chk(clazz)) getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ NetI2pI2PAppContext_class_() } count:1 type:IOSClass_class_()]];
            id fact = [((JavaLangReflectConstructor *) nil_chk(ctor)) newInstanceWithNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ _context_ } count:1 type:NSObject_class_()]];
            JavaLangReflectMethod *createSocket = [clazz getDeclaredMethod:@"createSocket" parameterTypes:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
            @try {
              JreStrongAssign(&_socket_, (JavaNetSocket *) cast_chk([((JavaLangReflectMethod *) nil_chk(createSocket)) invokeWithId:fact withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET] } count:1 type:NSObject_class_()]], [JavaNetSocket class]));
            }
            @catch (JavaLangReflectInvocationTargetException *e) {
              @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot create domain socket", e);
            }
          }
          @catch (JavaLangClassNotFoundException *e) {
            @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot load DomainSocketFactory", e);
          }
          @catch (JavaLangNoSuchMethodException *e) {
            @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot load DomainSocketFactory", e);
          }
          @catch (JavaLangInstantiationException *e) {
            @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot load DomainSocketFactory", e);
          }
          @catch (JavaLangIllegalAccessException *e) {
            @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot load DomainSocketFactory", e);
          }
          @catch (JavaLangReflectInvocationTargetException *e) {
            @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Cannot load DomainSocketFactory", e);
          }
        }
        else if (JavaLangBoolean_parseBooleanWithNSString_([((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_ENABLE_SSL])) {
          @try {
            NetI2pUtilI2PSSLSocketFactory *fact = create_NetI2pUtilI2PSSLSocketFactory_initWithNetI2pI2PAppContext_withBoolean_withNSString_(_context_, false, @"certificates/i2cp");
            JreStrongAssign(&_socket_, [fact createSocketWithNSString:_hostname_ withInt:_portNum_]);
            [((JavaNetSocket *) nil_chk(_socket_)) setKeepAliveWithBoolean:true];
          }
          @catch (JavaSecurityGeneralSecurityException *gse) {
            JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"SSL Fail");
            [ioe initCauseWithJavaLangThrowable:gse];
            @throw ioe;
          }
        }
        else {
          JreStrongAssignAndConsume(&_socket_, new_JavaNetSocket_initWithNSString_withInt_(_hostname_, _portNum_));
          [_socket_ setKeepAliveWithBoolean:true];
        }
        JavaIoOutputStream *out = [((JavaNetSocket *) nil_chk(_socket_)) getOutputStream];
        [((JavaIoOutputStream *) nil_chk(out)) writeWithInt:NetI2pClientI2PClient_PROTOCOL_BYTE];
        [out flush];
        JreStrongAssignAndConsume(&_writer_, new_NetI2pClientImplClientWriterRunner_initWithJavaIoOutputStream_withNetI2pClientImplI2PSessionImpl_(out, self));
        [_writer_ startWriting];
        JavaIoInputStream *in = create_JavaIoBufferedInputStream_initWithJavaIoInputStream_withInt_([((JavaNetSocket *) nil_chk(_socket_)) getInputStream], NetI2pClientImplI2PSessionImpl_BUF_SIZE);
        JreStrongAssignAndConsume(&_reader_, new_NetI2pDataI2cpI2CPMessageReader_initWithJavaIoInputStream_withNetI2pDataI2cpI2CPMessageReader_I2CPMessageEventListener_(in, self));
      }
    }
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"before startReading")];
    [((NetI2pDataI2cpI2CPMessageReader *) nil_chk(_reader_)) startReading];
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"Before getDate")];
    JavaUtilProperties *auth = nil;
    if ((![_context_ isRouterContext]) && [((JavaUtilProperties *) nil_chk(_options_)) containsKeyWithId:NetI2pClientImplI2PSessionImpl_PROP_USER] && [_options_ containsKeyWithId:NetI2pClientImplI2PSessionImpl_PROP_PW]) {
      auth = create_NetI2pUtilOrderedProperties_init();
      [auth setPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_USER withNSString:[((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_USER]];
      [auth setPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_PW withNSString:[_options_ getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_PW]];
    }
    [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpGetDateMessage_initWithNSString_withJavaUtilProperties_(NetI2pCoreVersion_VERSION, auth)];
    [self waitForDate];
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"Before producer.connect()")];
    [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) connectWithNetI2pClientImplI2PSessionImpl:self];
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"After producer.connect()")];
    jint waitcount = 0;
    while (JreLoadVolatileId(&_leaseSet_) == nil) {
      if (waitcount++ > 5 * 60) {
        @throw create_JavaIoIOException_initWithNSString_(@"No tunnels built after waiting 5 minutes. Your network connection may be down, or there is severe network congestion.");
      }
      @synchronized(_leaseSetWait_) {
        [nil_chk(_leaseSetWait_) java_waitWithLong:1000];
      }
      if ([self isClosed]) @throw create_JavaIoIOException_initWithNSString_(@"Disconnected from router while waiting for tunnels");
    }
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) {
      jlong connected = [((NetI2pUtilClock *) nil_chk([_context_ clock])) now];
      [_log_ infoWithNSString:JreStrcat("$$J$", [self getPrefix], @"Lease set created with inbound tunnels after ", (connected - startConnect), @"ms - ready to participate in the network!")];
    }
    JavaLangThread *notifier = create_NetI2pUtilI2PAppThread_initWithJavaLangRunnable_withNSString_withBoolean_(_availabilityNotifier_, JreStrcat("$$", @"ClientNotifier ", [self getPrefix]), true);
    [notifier start];
    NetI2pClientImplI2PSessionImpl_startIdleMonitor(self);
    [self startVerifyUsage];
    success = true;
    @synchronized(_subsessionLock_) {
      for (NetI2pClientImplSubSession * __strong ss in nil_chk(_subsessions_)) {
        if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$@", [self getPrefix], @"Connecting subsession ", ss)];
        [_producer_ connectWithNetI2pClientImplI2PSessionImpl:ss];
      }
    }
  }
  @catch (JavaLangInterruptedException *ie) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
  }
  @catch (JavaNetUnknownHostException *uhe) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(JreStrcat("$$$CI", [self getPrefix], @"Cannot connect to the router on ", _hostname_, ':', _portNum_), uhe);
  }
  @catch (JavaIoIOException *ioe) {
    NSString *msg;
    if ([_context_ isRouterContext]) msg = @"Failed to build tunnels";
    else if (NetI2pUtilSystemVersion_isAndroid() && [((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET] != nil) msg = JreStrcat("$$$", @"Failed to bind to the router on ", [((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET], @" and build tunnels");
    else msg = JreStrcat("$$CI$", @"Cannot connect to the router on ", _hostname_, ':', _portNum_, @" and build tunnels");
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(JreStrcat("$$", [self getPrefix], msg), ioe);
  }
  @finally {
    if (success) {
      [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPEN)];
    }
    else {
      [((NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *) nil_chk(_availabilityNotifier_)) stopNotifying];
      @synchronized(_stateLock_) {
        [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING)];
        @try {
          [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) disconnectWithNetI2pClientImplI2PSessionImpl:self];
        }
        @catch (NetI2pClientI2PSessionException *ipe) {
        }
        NetI2pClientImplI2PSessionImpl_closeSocket(self);
      }
    }
  }
}

- (void)waitForDate {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"After getDate / begin waiting for a response")];
  jint waitcount = 0;
  while (true) {
    if (waitcount++ > 30) {
      @throw create_JavaIoIOException_initWithNSString_(@"No handshake received from the router");
    }
    @synchronized(_stateLock_) {
      if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, GOTDATE)) break;
      if (_state_ != JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING) && _state_ != JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT)) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"Socket closed, state=", _state_));
      [nil_chk(_stateLock_) java_waitWithLong:1000];
    }
  }
  if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"After received a SetDate response")];
}

- (IOSByteArray *)receiveMessageWithInt:(jint)msgId {
  NetI2pDataI2cpMessagePayloadMessage *msg = [((id<JavaUtilMap>) nil_chk(_availableMessages_)) removeWithId:JavaLangLong_valueOfWithLong_(msgId)];
  if (msg == nil) {
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:JreStrcat("$I$", @"Receive message ", msgId, @" had no matches")];
    return nil;
  }
  [self updateActivity];
  return [((NetI2pDataPayload *) nil_chk([msg getPayload])) getUnencryptedData];
}

- (void)reportAbuseWithInt:(jint)msgId
                   withInt:(jint)severity {
  [self verifyOpen];
  [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) reportAbuseWithNetI2pClientImplI2PSessionImpl:self withInt:msgId withInt:severity];
}

- (void)receiveStatusWithInt:(jint)msgId
                    withLong:(jlong)nonce
                     withInt:(jint)status {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)addNewMessageWithNetI2pDataI2cpMessagePayloadMessage:(NetI2pDataI2cpMessagePayloadMessage *)msg {
  JavaLangLong *mid = JavaLangLong_valueOfWithLong_([((NetI2pDataI2cpMessagePayloadMessage *) nil_chk(msg)) getMessageId]);
  [((id<JavaUtilMap>) nil_chk(_availableMessages_)) putWithId:mid withId:msg];
  jlong id_ = [msg getMessageId];
  IOSByteArray *data = [((NetI2pDataPayload *) nil_chk([msg getPayload])) getUnencryptedData];
  if ((data == nil) || (((IOSByteArray *) nil_chk(data))->size_ <= 0)) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_CRIT]) [_log_ logWithInt:NetI2pUtilLog_CRIT withNSString:JreStrcat("$$", [self getPrefix], @"addNewMessage of a message with no unencrypted data") withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"Empty message")];
  }
  else {
    jint size = ((IOSByteArray *) nil_chk(data))->size_;
    [((NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *) nil_chk(_availabilityNotifier_)) availableWithLong:id_ withInt:size];
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$@$J", [self getPrefix], @"Notified availability for session ", _sessionId_, @", message ", id_)];
  }
}

- (void)startVerifyUsage {
  create_NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(self);
}

- (void)messageReceivedWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader
                             withNetI2pDataI2cpI2CPMessage:(id<NetI2pDataI2cpI2CPMessage>)message {
  jint type = [((id<NetI2pDataI2cpI2CPMessage>) nil_chk(message)) getType];
  NetI2pDataI2cpSessionId *id_ = [message sessionId];
  NetI2pDataI2cpSessionId *currId = _sessionId_;
  if (id_ == nil || [id_ isEqual:currId] || (currId == nil && id_ != nil && type == NetI2pDataI2cpSessionStatusMessage_MESSAGE_TYPE) || ((id_ == nil || [id_ getSessionId] == 65535) && (type == NetI2pDataI2cpHostReplyMessage_MESSAGE_TYPE || type == NetI2pDataI2cpDestReplyMessage_MESSAGE_TYPE))) {
    id<NetI2pClientImplI2CPMessageHandler> handler = [((NetI2pClientImplI2PClientMessageHandlerMap *) nil_chk(_handlerMap_)) getHandlerWithInt:type];
    if (handler != nil) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$I$$", [self getPrefix], @"Message received of type ", type, @" to be handled by ", [[handler java_getClass] getSimpleName])];
      [handler handleMessageWithNetI2pDataI2cpI2CPMessage:message withNetI2pClientImplI2PSessionImpl:self];
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$$I", [self getPrefix], @"Unknown message or unhandleable message received: type = ", type)];
    }
  }
  else {
    NetI2pClientImplSubSession *sub = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_subsessionMap_)) getWithId:id_];
    if (sub != nil) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$I$@", [self getPrefix], @"Message received of type ", type, @" to be handled by ", sub)];
      [sub messageReceivedWithNetI2pDataI2cpI2CPMessageReader:reader withNetI2pDataI2cpI2CPMessage:message];
    }
    else if (id_ != nil && type == NetI2pDataI2cpSessionStatusMessage_MESSAGE_TYPE) {
      @synchronized(_subsessionLock_) {
        for (NetI2pClientImplSubSession * __strong sess in nil_chk(_subsessions_)) {
          if ([((NetI2pClientImplSubSession *) nil_chk(sess)) getSessionId] == nil) {
            [sess messageReceivedWithNetI2pDataI2cpI2CPMessageReader:reader withNetI2pDataI2cpI2CPMessage:message];
            id_ = JreRetainedLocalValue([sess getSessionId]);
            if (id_ != nil) {
              if ([id_ isEqual:_sessionId_]) {
                [sess setSessionIdWithNetI2pDataI2cpSessionId:nil];
                if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@", @"Dup or our session id ", id_)];
              }
              else {
                NetI2pClientImplSubSession *old = [_subsessionMap_ putIfAbsentWithId:id_ withId:sess];
                if (old != nil) {
                  [sess setSessionIdWithNetI2pDataI2cpSessionId:nil];
                  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@", @"Dup session id ", id_)];
                }
              }
            }
            return;
          }
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$$@$I", [self getPrefix], @"No session ", id_, @" to handle message: type = ", type)];
        }
      }
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$$@$I", [self getPrefix], @"No session ", id_, @" to handle message: type = ", type)];
    }
  }
}

- (void)readErrorWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader
                               withJavaLangException:(JavaLangException *)error {
  [self propogateErrorWithNSString:@"There was an error reading data" withJavaLangThrowable:error];
  [self disconnect];
}

- (NetI2pDataDestination *)getMyDestination {
  return _myDestination_;
}

- (NetI2pDataPrivateKey *)getDecryptionKey {
  return _privateKey_;
}

- (NetI2pDataSigningPrivateKey *)getPrivateKey {
  return _signingPrivateKey_;
}

- (NetI2pClientImplI2CPMessageProducer *)getProducer {
  return _producer_;
}

- (NetI2pClientImplI2PClientMessageHandlerMap *)getHandlerMap {
  return _handlerMap_;
}

- (NetI2pI2PAppContext *)getContext {
  return _context_;
}

- (JavaUtilProperties *)getOptions {
  return _options_;
}

- (NetI2pDataI2cpSessionId *)getSessionId {
  return _sessionId_;
}

- (void)setSessionIdWithNetI2pDataI2cpSessionId:(NetI2pDataI2cpSessionId *)id_ {
  JreStrongAssign(&_sessionId_, id_);
}

- (void)setSessionListenerWithNetI2pClientI2PSessionListener:(id<NetI2pClientI2PSessionListener>)lsnr {
  JreStrongAssign(&_sessionListener_, lsnr);
}

- (jboolean)isClosed {
  @synchronized(_stateLock_) {
    return _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT);
  }
}

- (void)verifyOpen {
  @synchronized(_stateLock_) {
    while (true) {
      switch ([_state_ ordinal]) {
        case NetI2pClientImplI2PSessionImpl_State_Enum_INIT:
        @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Not open, must call connect() first");
        case NetI2pClientImplI2PSessionImpl_State_Enum_OPENING:
        case NetI2pClientImplI2PSessionImpl_State_Enum_GOTDATE:
        @try {
          [nil_chk(_stateLock_) java_waitWithLong:5 * 1000];
          continue;
        }
        @catch (JavaLangInterruptedException *ie) {
          @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
        }
        case NetI2pClientImplI2PSessionImpl_State_Enum_OPEN:
        return;
        case NetI2pClientImplI2PSessionImpl_State_Enum_CLOSING:
        case NetI2pClientImplI2PSessionImpl_State_Enum_CLOSED:
        @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Already closed");
      }
    }
  }
}

- (void)sendMessageWithNetI2pDataI2cpI2CPMessage:(id<NetI2pDataI2cpI2CPMessage>)message {
  [self verifyOpen];
  [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:message];
}

- (void)sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:(id<NetI2pDataI2cpI2CPMessage>)message {
  if (_queue_ != nil) {
    @try {
      if (![_queue_ offerWithNetI2pDataI2cpI2CPMessage:message withLong:NetI2pClientImplI2PSessionImpl_MAX_SEND_WAIT]) @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Timed out waiting while write queue was full");
    }
    @catch (JavaLangInterruptedException *ie) {
      @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
    }
  }
  else {
    NetI2pClientImplClientWriterRunner *writer = _writer_;
    if (writer == nil) {
      @throw create_NetI2pClientI2PSessionException_initWithNSString_(@"Already closed or not open");
    }
    else {
      [writer addMessageWithNetI2pDataI2cpI2CPMessage:message];
    }
  }
}

- (void)propogateErrorWithNSString:(NSString *)msg
             withJavaLangThrowable:(JavaLangThrowable *)error {
  jint level;
  NSString *msgpfx;
  if ([error isKindOfClass:[JavaIoEOFException class]]) {
    level = NetI2pUtilLog_WARN;
    msgpfx = @"Router closed connection: ";
  }
  else {
    level = NetI2pUtilLog_ERROR;
    msgpfx = @"Error occurred communicating with router: ";
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:level]) [_log_ logWithInt:level withNSString:JreStrcat("$$$", [self getPrefix], msgpfx, msg) withJavaLangThrowable:error];
  if (_sessionListener_ != nil) [_sessionListener_ errorOccurredWithNetI2pClientI2PSession:self withNSString:msg withJavaLangThrowable:error];
}

- (void)destroySession {
  [self destroySessionWithBoolean:true];
}

- (void)destroySessionWithBoolean:(jboolean)sendDisconnect {
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT)) return;
    [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING)];
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$", [self getPrefix], @"Destroy the session") withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"DestroySession()")];
  if (sendDisconnect && _producer_ != nil) {
    @try {
      [_producer_ disconnectWithNetI2pClientImplI2PSessionImpl:self];
    }
    @catch (NetI2pClientI2PSessionException *ipe) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Error destroying the session" withJavaLangThrowable:ipe];
    }
  }
  if (_availabilityNotifier_ != nil) [_availabilityNotifier_ stopNotifying];
  NetI2pClientImplI2PSessionImpl_closeSocket(self);
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_subsessionMap_)) clear];
  if (_sessionListener_ != nil) [_sessionListener_ disconnectedWithNetI2pClientI2PSession:self];
}

- (void)closeSocket {
  NetI2pClientImplI2PSessionImpl_closeSocket(self);
}

- (void)locked_closeSocket {
  NetI2pClientImplI2PSessionImpl_locked_closeSocket(self);
}

- (void)disconnectedWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"Disconnected") withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"Disconnected")];
  [self disconnect];
}

- (void)disconnect {
  NetI2pClientImplI2PSessionImpl_State *oldState;
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT)) return;
    oldState = JreRetainedLocalValue(_state_);
    [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING)];
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", [self getPrefix], @"Disconnect() called") withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"Disconnect")];
  if (oldState != JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING) && [self shouldReconnect]) {
    if ([self reconnect]) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$", [self getPrefix], @"I2CP reconnection successful")];
      return;
    }
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$$", [self getPrefix], @"I2CP reconnection failed")];
  }
  if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$$", [self getPrefix], @"Disconned from the router, and not trying to reconnect")];
  if (_sessionListener_ != nil) [_sessionListener_ disconnectedWithNetI2pClientI2PSession:self];
  NetI2pClientImplI2PSessionImpl_closeSocket(self);
  [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED)];
  @synchronized(_leaseSetWait_) {
    [nil_chk(_leaseSetWait_) java_notifyAll];
  }
}

- (jboolean)shouldReconnect {
  return true;
}

- (jboolean)reconnect {
  NetI2pClientImplI2PSessionImpl_closeSocket(self);
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$", [self getPrefix], @"Reconnecting...")];
  jint i = 0;
  while (true) {
    jlong delay = JreLShift32(NetI2pClientImplI2PSessionImpl_BASE_RECONNECT_DELAY, i);
    i++;
    if ((delay > NetI2pClientImplI2PSessionImpl_MAX_RECONNECT_DELAY) || (delay <= 0)) delay = NetI2pClientImplI2PSessionImpl_MAX_RECONNECT_DELAY;
    @try {
      JavaLangThread_sleepWithLong_(delay);
    }
    @catch (JavaLangInterruptedException *ie) {
      return false;
    }
    @try {
      [self connect];
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$I", [self getPrefix], @"Reconnected on attempt ", i)];
      return true;
    }
    @catch (NetI2pClientI2PSessionException *ise) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$$I", [self getPrefix], @"Error reconnecting on attempt ", i) withJavaLangThrowable:ise];
    }
  }
}

- (NSString *)getPrefix {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_init();
  [buf appendWithChar:'['];
  [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:[((NetI2pClientImplI2PSessionImpl_State *) nil_chk(_state_)) description]])) appendWithChar:' '];
  NSString *s = [((JavaUtilProperties *) nil_chk(_options_)) getPropertyWithNSString:@"inbound.nickname"];
  if (s != nil) [buf appendWithNSString:s];
  else [buf appendWithNSString:[[self java_getClass] getSimpleName]];
  NetI2pDataI2cpSessionId *id_ = _sessionId_;
  if (id_ != nil) [((JavaLangStringBuilder *) nil_chk([buf appendWithNSString:@" #"])) appendWithInt:[id_ getSessionId]];
  [buf appendWithNSString:@"]: "];
  return [buf description];
}

- (void)destReceivedWithNetI2pDataDestination:(NetI2pDataDestination *)d {
  NetI2pDataHash *h = [((NetI2pDataDestination *) nil_chk(d)) calculateHash];
  @synchronized(NetI2pClientImplI2PSessionImpl__lookupCache) {
    [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) putWithId:h withId:d];
  }
  for (NetI2pClientImplI2PSessionImpl_LookupWaiter * __strong w in nil_chk(_pendingLookups_)) {
    if ([((NetI2pDataHash *) nil_chk(h)) isEqual:((NetI2pClientImplI2PSessionImpl_LookupWaiter *) nil_chk(w))->hash__]) {
      @synchronized(w) {
        JreStrongAssign(&w->destination_, d);
        [w java_notifyAll];
      }
    }
  }
}

- (void)destLookupFailedWithNetI2pDataHash:(NetI2pDataHash *)h {
  for (NetI2pClientImplI2PSessionImpl_LookupWaiter * __strong w in nil_chk(_pendingLookups_)) {
    if ([((NetI2pDataHash *) nil_chk(h)) isEqual:((NetI2pClientImplI2PSessionImpl_LookupWaiter *) nil_chk(w))->hash__]) {
      @synchronized(w) {
        [w java_notifyAll];
      }
    }
  }
}

- (void)destReceivedWithLong:(jlong)nonce
   withNetI2pDataDestination:(NetI2pDataDestination *)d {
  NetI2pDataHash *h = [((NetI2pDataDestination *) nil_chk(d)) calculateHash];
  for (NetI2pClientImplI2PSessionImpl_LookupWaiter * __strong w in nil_chk(_pendingLookups_)) {
    if (nonce == ((NetI2pClientImplI2PSessionImpl_LookupWaiter *) nil_chk(w))->nonce_ || [((NetI2pDataHash *) nil_chk(h)) isEqual:w->hash__]) {
      @synchronized(NetI2pClientImplI2PSessionImpl__lookupCache) {
        if (w->name_ != nil) [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) putWithId:w->name_ withId:d];
        [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) putWithId:h withId:d];
      }
      @synchronized(w) {
        JreStrongAssign(&w->destination_, d);
        [w java_notifyAll];
      }
    }
  }
}

- (void)destLookupFailedWithLong:(jlong)nonce {
  for (NetI2pClientImplI2PSessionImpl_LookupWaiter * __strong w in nil_chk(_pendingLookups_)) {
    if (nonce == ((NetI2pClientImplI2PSessionImpl_LookupWaiter *) nil_chk(w))->nonce_) {
      @synchronized(w) {
        [w java_notifyAll];
      }
    }
  }
}

- (void)bwReceivedWithIntArray:(IOSIntArray *)i {
  JreVolatileStrongAssign(&_bwLimits_, i);
  @synchronized(_bwReceivedLock_) {
    [nil_chk(_bwReceivedLock_) java_notifyAll];
  }
}

+ (void)clearCache {
  NetI2pClientImplI2PSessionImpl_clearCache();
}

- (NetI2pDataDestination *)lookupDestWithNetI2pDataHash:(NetI2pDataHash *)h {
  return [self lookupDestWithNetI2pDataHash:h withLong:10 * 1000];
}

- (NetI2pDataDestination *)lookupDestWithNetI2pDataHash:(NetI2pDataHash *)h
                                               withLong:(jlong)maxWait {
  @synchronized(NetI2pClientImplI2PSessionImpl__lookupCache) {
    NetI2pDataDestination *rv = [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) getWithId:h];
    if (rv != nil) return JreRetainedLocalValue(rv);
  }
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING)) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Session closed, cannot lookup ", h)];
      return JreRetainedLocalValue(nil);
    }
  }
  NetI2pClientImplI2PSessionImpl_LookupWaiter *waiter;
  jlong nonce;
  if (JreLoadVolatileBoolean(&_routerSupportsHostLookup_)) {
    nonce = [((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(_lookupID_)) incrementAndGet] & (jint) 0x7fffffff;
    waiter = create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(h, nonce);
  }
  else {
    nonce = 0;
    waiter = create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(h);
  }
  [((JavaUtilConcurrentLinkedBlockingQueue *) nil_chk(_pendingLookups_)) offerWithId:waiter];
  NetI2pDataDestination *rv = nil;
  @try {
    if (JreLoadVolatileBoolean(&_routerSupportsHostLookup_)) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Sending HostLookup for ", h)];
      NetI2pDataI2cpSessionId *id_ = _sessionId_;
      if (id_ == nil) id_ = create_NetI2pDataI2cpSessionId_initWithInt_(65535);
      [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpHostLookupMessage_initWithNetI2pDataI2cpSessionId_withNetI2pDataHash_withLong_withLong_(id_, h, nonce, maxWait)];
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Sending DestLookup for ", h)];
      [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpDestLookupMessage_initWithNetI2pDataHash_(h)];
    }
    @try {
      @synchronized(waiter) {
        [waiter java_waitWithLong:maxWait];
        rv = JreRetainedLocalValue(waiter->destination_);
      }
    }
    @catch (JavaLangInterruptedException *ie) {
      @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
    }
  }
  @finally {
    [_pendingLookups_ removeWithId:waiter];
  }
  return rv;
}

- (NetI2pDataDestination *)lookupDestWithNSString:(NSString *)name {
  return [self lookupDestWithNSString:name withLong:10 * 1000];
}

- (NetI2pDataDestination *)lookupDestWithNSString:(NSString *)name
                                         withLong:(jlong)maxWait {
  if ([((NSString *) nil_chk(name)) java_length] == 0) return nil;
  if ([name java_length] >= 516) {
    @try {
      return create_NetI2pDataDestination_initWithNSString_(name);
    }
    @catch (NetI2pDataDataFormatException *dfe) {
      return nil;
    }
  }
  if ([name java_length] >= 256 && ![((NetI2pI2PAppContext *) nil_chk(_context_)) isRouterContext]) return nil;
  @synchronized(NetI2pClientImplI2PSessionImpl__lookupCache) {
    NetI2pDataDestination *rv = [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) getWithId:name];
    if (rv != nil) return JreRetainedLocalValue(rv);
  }
  if ([self isClosed]) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$", @"Session closed, cannot lookup ", name)];
    return nil;
  }
  if (!JreLoadVolatileBoolean(&_routerSupportsHostLookup_)) {
    if ([name java_length] == 60 && [((NSString *) nil_chk([name java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, US)])) java_hasSuffix:@".b32.i2p"]) return [self lookupDestWithNetI2pDataHash:NetI2pDataHash_createWithByteArray_(NetI2pDataBase32_decodeWithNSString_([((NSString *) nil_chk([name java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, US)])) java_substring:0 endIndex:52])) withLong:maxWait];
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$$", @"Router does not support HostLookup for ", name)];
    return nil;
  }
  jint nonce = [((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(_lookupID_)) incrementAndGet] & (jint) 0x7fffffff;
  NetI2pClientImplI2PSessionImpl_LookupWaiter *waiter = create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(name, nonce);
  [((JavaUtilConcurrentLinkedBlockingQueue *) nil_chk(_pendingLookups_)) offerWithId:waiter];
  NetI2pDataDestination *rv = nil;
  @try {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$$", @"Sending HostLookup for ", name)];
    NetI2pDataI2cpSessionId *id_ = _sessionId_;
    if (id_ == nil) id_ = create_NetI2pDataI2cpSessionId_initWithInt_(65535);
    [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpHostLookupMessage_initWithNetI2pDataI2cpSessionId_withNSString_withLong_withLong_(id_, name, nonce, maxWait)];
    @try {
      @synchronized(waiter) {
        [waiter java_waitWithLong:maxWait];
        rv = JreRetainedLocalValue(waiter->destination_);
      }
    }
    @catch (JavaLangInterruptedException *ie) {
      @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
    }
  }
  @finally {
    [_pendingLookups_ removeWithId:waiter];
  }
  return rv;
}

- (IOSIntArray *)bandwidthLimits {
  @synchronized(_stateLock_) {
    if (_state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT) || _state_ == JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, OPENING)) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:@"Session closed, cannot get bw limits"];
      return JreRetainedLocalValue(nil);
    }
  }
  [self sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpGetBandwidthLimitsMessage_init()];
  @try {
    @synchronized(_bwReceivedLock_) {
      [nil_chk(_bwReceivedLock_) java_waitWithLong:5 * 1000];
    }
  }
  @catch (JavaLangInterruptedException *ie) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Interrupted", ie);
  }
  return JreLoadVolatileId(&_bwLimits_);
}

- (void)updateActivity {
  _lastActivity_ = [((NetI2pUtilClock *) nil_chk([((NetI2pI2PAppContext *) nil_chk(_context_)) clock])) now];
  if (_isReduced_) {
    _isReduced_ = false;
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$$", [self getPrefix], @"Restoring original tunnel quantity")];
    @try {
      [((NetI2pClientImplI2CPMessageProducer *) nil_chk(_producer_)) updateTunnelsWithNetI2pClientImplI2PSessionImpl:self withInt:0];
    }
    @catch (NetI2pClientI2PSessionException *ise) {
      [_log_ errorWithNSString:JreStrcat("$$", [self getPrefix], @"bork restore from reduced")];
    }
  }
}

- (jlong)lastActivity {
  return _lastActivity_;
}

- (void)setReduced {
  _isReduced_ = true;
}

- (void)startIdleMonitor {
  NetI2pClientImplI2PSessionImpl_startIdleMonitor(self);
}

- (NSString *)description {
  JavaLangStringBuilder *buf = create_JavaLangStringBuilder_initWithInt_(32);
  [buf appendWithNSString:@"Session: "];
  if (_myDestination_ != nil) [buf appendWithNSString:[((NSString *) nil_chk([((NetI2pDataHash *) nil_chk([_myDestination_ calculateHash])) toBase64])) java_substring:0 endIndex:4]];
  else [buf appendWithNSString:@"[null dest]"];
  [buf appendWithNSString:[self getPrefix]];
  return [buf description];
}

- (void)__javaClone:(NetI2pClientImplI2PSessionImpl *)original {
  [super __javaClone:original];
  JreCloneVolatileStrong(&_leaseSet_, &original->_leaseSet_);
  JreCloneVolatileStrong(&_bwLimits_, &original->_bwLimits_);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_myDestination_);
  RELEASE_(_privateKey_);
  RELEASE_(_signingPrivateKey_);
  RELEASE_(_options_);
  RELEASE_(_sessionId_);
  JreReleaseVolatile(&_leaseSet_);
  RELEASE_(_subsessions_);
  RELEASE_(_subsessionMap_);
  RELEASE_(_subsessionLock_);
  RELEASE_(_hostname_);
  RELEASE_(_socket_);
  RELEASE_(_reader_);
  RELEASE_(_writer_);
  RELEASE_(_queue_);
  RELEASE_(_sessionListener_);
  RELEASE_(_producer_);
  RELEASE_(_availableMessages_);
  RELEASE_(_pendingLookups_);
  RELEASE_(_lookupID_);
  RELEASE_(_bwReceivedLock_);
  JreReleaseVolatile(&_bwLimits_);
  RELEASE_(_handlerMap_);
  RELEASE_(_context_);
  RELEASE_(_leaseSetWait_);
  RELEASE_(_state_);
  RELEASE_(_stateLock_);
  RELEASE_(_availabilityNotifier_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 3, 4, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 6, 4, -1, -1, -1 },
    { NULL, "LNetI2pClientI2PSession;", 0x1, 7, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, -1, -1, -1, 11, -1, -1 },
    { NULL, "LJavaUtilProperties;", 0x12, 12, 13, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilProperties;", 0x2, 14, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 13, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 16, 17, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataLeaseSet;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 21, 22, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 23, -1, -1, -1 },
    { NULL, "[B", 0x1, 24, 25, 4, -1, -1, -1 },
    { NULL, "V", 0x1, 26, 27, 4, -1, -1, -1 },
    { NULL, "V", 0x401, 28, 29, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 30, 31, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 32, 33, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 34, 35, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataPrivateKey;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataSigningPrivateKey;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pClientImplI2CPMessageProducer;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pClientImplI2PClientMessageHandlerMap;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pI2PAppContext;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilProperties;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataI2cpSessionId;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 36, 37, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 38, 39, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x0, 40, 41, 4, -1, -1, -1 },
    { NULL, "V", 0x0, 42, 41, 4, -1, -1, -1 },
    { NULL, "V", 0x0, 43, 44, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 45, 46, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 47, 48, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 49, 50, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 51, 52, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 49, 53, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 51, 54, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 55, 56, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, 57, 52, 4, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, 57, 58, 4, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, 57, 1, 4, -1, -1, -1 },
    { NULL, "LNetI2pDataDestination;", 0x1, 57, 59, 4, -1, -1, -1 },
    { NULL, "[I", 0x1, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 60, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(dateUpdatedWithNSString:);
  methods[1].selector = @selector(initWithNetI2pI2PAppContext:withJavaUtilProperties:withNetI2pClientImplI2PClientMessageHandlerMap:);
  methods[2].selector = @selector(initWithNetI2pClientImplI2PSessionImpl:withJavaIoInputStream:withJavaUtilProperties:);
  methods[3].selector = @selector(initWithNetI2pI2PAppContext:withJavaUtilProperties:withNetI2pClientImplI2PClientMessageHandlerMap:withNetI2pClientImplI2CPMessageProducer:withBoolean:);
  methods[4].selector = @selector(initWithNetI2pI2PAppContext:withJavaIoInputStream:withJavaUtilProperties:);
  methods[5].selector = @selector(addSubsessionWithJavaIoInputStream:withJavaUtilProperties:);
  methods[6].selector = @selector(removeSubsessionWithNetI2pClientI2PSession:);
  methods[7].selector = @selector(getSubsessions);
  methods[8].selector = @selector(loadConfigWithJavaUtilProperties:);
  methods[9].selector = @selector(getHost);
  methods[10].selector = @selector(getPort);
  methods[11].selector = @selector(filterWithJavaUtilProperties:);
  methods[12].selector = @selector(updateOptionsWithJavaUtilProperties:);
  methods[13].selector = @selector(getFastReceive);
  methods[14].selector = @selector(setLeaseSetWithNetI2pDataLeaseSet:);
  methods[15].selector = @selector(getLeaseSet);
  methods[16].selector = @selector(changeStateWithNetI2pClientImplI2PSessionImpl_State:);
  methods[17].selector = @selector(readDestinationWithJavaIoInputStream:);
  methods[18].selector = @selector(connect);
  methods[19].selector = @selector(waitForDate);
  methods[20].selector = @selector(receiveMessageWithInt:);
  methods[21].selector = @selector(reportAbuseWithInt:withInt:);
  methods[22].selector = @selector(receiveStatusWithInt:withLong:withInt:);
  methods[23].selector = @selector(addNewMessageWithNetI2pDataI2cpMessagePayloadMessage:);
  methods[24].selector = @selector(startVerifyUsage);
  methods[25].selector = @selector(messageReceivedWithNetI2pDataI2cpI2CPMessageReader:withNetI2pDataI2cpI2CPMessage:);
  methods[26].selector = @selector(readErrorWithNetI2pDataI2cpI2CPMessageReader:withJavaLangException:);
  methods[27].selector = @selector(getMyDestination);
  methods[28].selector = @selector(getDecryptionKey);
  methods[29].selector = @selector(getPrivateKey);
  methods[30].selector = @selector(getProducer);
  methods[31].selector = @selector(getHandlerMap);
  methods[32].selector = @selector(getContext);
  methods[33].selector = @selector(getOptions);
  methods[34].selector = @selector(getSessionId);
  methods[35].selector = @selector(setSessionIdWithNetI2pDataI2cpSessionId:);
  methods[36].selector = @selector(setSessionListenerWithNetI2pClientI2PSessionListener:);
  methods[37].selector = @selector(isClosed);
  methods[38].selector = @selector(verifyOpen);
  methods[39].selector = @selector(sendMessageWithNetI2pDataI2cpI2CPMessage:);
  methods[40].selector = @selector(sendMessage_uncheckedWithNetI2pDataI2cpI2CPMessage:);
  methods[41].selector = @selector(propogateErrorWithNSString:withJavaLangThrowable:);
  methods[42].selector = @selector(destroySession);
  methods[43].selector = @selector(destroySessionWithBoolean:);
  methods[44].selector = @selector(closeSocket);
  methods[45].selector = @selector(locked_closeSocket);
  methods[46].selector = @selector(disconnectedWithNetI2pDataI2cpI2CPMessageReader:);
  methods[47].selector = @selector(disconnect);
  methods[48].selector = @selector(shouldReconnect);
  methods[49].selector = @selector(reconnect);
  methods[50].selector = @selector(getPrefix);
  methods[51].selector = @selector(destReceivedWithNetI2pDataDestination:);
  methods[52].selector = @selector(destLookupFailedWithNetI2pDataHash:);
  methods[53].selector = @selector(destReceivedWithLong:withNetI2pDataDestination:);
  methods[54].selector = @selector(destLookupFailedWithLong:);
  methods[55].selector = @selector(bwReceivedWithIntArray:);
  methods[56].selector = @selector(clearCache);
  methods[57].selector = @selector(lookupDestWithNetI2pDataHash:);
  methods[58].selector = @selector(lookupDestWithNetI2pDataHash:withLong:);
  methods[59].selector = @selector(lookupDestWithNSString:);
  methods[60].selector = @selector(lookupDestWithNSString:withLong:);
  methods[61].selector = @selector(bandwidthLimits);
  methods[62].selector = @selector(updateActivity);
  methods[63].selector = @selector(lastActivity);
  methods[64].selector = @selector(setReduced);
  methods[65].selector = @selector(startIdleMonitor);
  methods[66].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_myDestination_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_privateKey_", "LNetI2pDataPrivateKey;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_signingPrivateKey_", "LNetI2pDataSigningPrivateKey;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_options_", "LJavaUtilProperties;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_sessionId_", "LNetI2pDataI2cpSessionId;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_leaseSet_", "LNetI2pDataLeaseSet;", .constantValue.asLong = 0, 0x44, -1, -1, -1, -1 },
    { "_subsessions_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 61, -1 },
    { "_subsessionMap_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 62, -1 },
    { "_subsessionLock_", "LNSObject;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "MIN_SUBSESSION_VERSION", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 63, -1, -1 },
    { "_routerSupportsSubsessions_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "_hostname_", "LNSString;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_portNum_", "I", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_socket_", "LJavaNetSocket;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_reader_", "LNetI2pDataI2cpI2CPMessageReader;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_writer_", "LNetI2pClientImplClientWriterRunner;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_queue_", "LNetI2pInternalI2CPMessageQueue;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_sessionListener_", "LNetI2pClientI2PSessionListener;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_producer_", "LNetI2pClientImplI2CPMessageProducer;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_availableMessages_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x4, -1, -1, 64, -1 },
    { "_pendingLookups_", "LJavaUtilConcurrentLinkedBlockingQueue;", .constantValue.asLong = 0, 0x14, -1, -1, 65, -1 },
    { "_lookupID_", "LJavaUtilConcurrentAtomicAtomicInteger;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_bwReceivedLock_", "LNSObject;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_bwLimits_", "[I", .constantValue.asLong = 0, 0x44, -1, -1, -1, -1 },
    { "_handlerMap_", "LNetI2pClientImplI2PClientMessageHandlerMap;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_context_", "LNetI2pI2PAppContext;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_leaseSetWait_", "LNSObject;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_state_", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_stateLock_", "LNSObject;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_availabilityNotifier_", "LNetI2pClientImplI2PSessionImpl_AvailabilityNotifier;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "_lastActivity_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_isReduced_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_fastReceive_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_routerSupportsFastReceive_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "_routerSupportsHostLookup_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "CACHE_MAX_SIZE", "I", .constantValue.asLong = 0, 0x1c, -1, 66, -1, -1 },
    { "_lookupCache", "LJavaUtilMap;", .constantValue.asLong = 0, 0x1a, -1, 67, 68, -1 },
    { "MIN_HOST_LOOKUP_VERSION", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 69, -1, -1 },
    { "TEST_LOOKUP", "Z", .constantValue.asBOOL = NetI2pClientImplI2PSessionImpl_TEST_LOOKUP, 0x1a, -1, -1, -1, -1 },
    { "PROP_ENABLE_SSL", "LNSString;", .constantValue.asLong = 0, 0x1c, -1, 70, -1, -1 },
    { "PROP_USER", "LNSString;", .constantValue.asLong = 0, 0x1c, -1, 71, -1, -1 },
    { "PROP_PW", "LNSString;", .constantValue.asLong = 0, 0x1c, -1, 72, -1, -1 },
    { "PROP_DOMAIN_SOCKET", "LNSString;", .constantValue.asLong = 0, 0x1c, -1, 73, -1, -1 },
    { "VERIFY_USAGE_TIME", "J", .constantValue.asLong = NetI2pClientImplI2PSessionImpl_VERIFY_USAGE_TIME, 0x1a, -1, -1, -1, -1 },
    { "MAX_SEND_WAIT", "J", .constantValue.asLong = NetI2pClientImplI2PSessionImpl_MAX_SEND_WAIT, 0x1a, -1, -1, -1, -1 },
    { "MIN_FAST_VERSION", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 74, -1, -1 },
    { "LISTEN_PORT", "I", .constantValue.asInt = NetI2pClientImplI2PSessionImpl_LISTEN_PORT, 0x19, -1, -1, -1, -1 },
    { "BUF_SIZE", "I", .constantValue.asInt = NetI2pClientImplI2PSessionImpl_BUF_SIZE, 0x1a, -1, -1, -1, -1 },
    { "MAX_RECONNECT_DELAY", "I", .constantValue.asInt = NetI2pClientImplI2PSessionImpl_MAX_RECONNECT_DELAY, 0x1a, -1, -1, -1, -1 },
    { "BASE_RECONNECT_DELAY", "I", .constantValue.asInt = NetI2pClientImplI2PSessionImpl_BASE_RECONNECT_DELAY, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "dateUpdated", "LNSString;", "LNetI2pI2PAppContext;LJavaUtilProperties;LNetI2pClientImplI2PClientMessageHandlerMap;", "LNetI2pClientImplI2PSessionImpl;LJavaIoInputStream;LJavaUtilProperties;", "LNetI2pClientI2PSessionException;", "LNetI2pI2PAppContext;LJavaUtilProperties;LNetI2pClientImplI2PClientMessageHandlerMap;LNetI2pClientImplI2CPMessageProducer;Z", "LNetI2pI2PAppContext;LJavaIoInputStream;LJavaUtilProperties;", "addSubsession", "LJavaIoInputStream;LJavaUtilProperties;", "removeSubsession", "LNetI2pClientI2PSession;", "()Ljava/util/List<Lnet/i2p/client/I2PSession;>;", "loadConfig", "LJavaUtilProperties;", "filter", "updateOptions", "setLeaseSet", "LNetI2pDataLeaseSet;", "changeState", "LNetI2pClientImplI2PSessionImpl_State;", "readDestination", "LJavaIoInputStream;", "LNetI2pDataDataFormatException;LJavaIoIOException;", "LJavaLangInterruptedException;LJavaIoIOException;", "receiveMessage", "I", "reportAbuse", "II", "receiveStatus", "IJI", "addNewMessage", "LNetI2pDataI2cpMessagePayloadMessage;", "messageReceived", "LNetI2pDataI2cpI2CPMessageReader;LNetI2pDataI2cpI2CPMessage;", "readError", "LNetI2pDataI2cpI2CPMessageReader;LJavaLangException;", "setSessionId", "LNetI2pDataI2cpSessionId;", "setSessionListener", "LNetI2pClientI2PSessionListener;", "sendMessage", "LNetI2pDataI2cpI2CPMessage;", "sendMessage_unchecked", "propogateError", "LNSString;LJavaLangThrowable;", "destroySession", "Z", "disconnected", "LNetI2pDataI2cpI2CPMessageReader;", "destReceived", "LNetI2pDataDestination;", "destLookupFailed", "LNetI2pDataHash;", "JLNetI2pDataDestination;", "J", "bwReceived", "[I", "lookupDest", "LNetI2pDataHash;J", "LNSString;J", "toString", "Ljava/util/List<Lnet/i2p/client/impl/SubSession;>;", "Ljava/util/concurrent/ConcurrentHashMap<Lnet/i2p/data/i2cp/SessionId;Lnet/i2p/client/impl/SubSession;>;", &NetI2pClientImplI2PSessionImpl_MIN_SUBSESSION_VERSION, "Ljava/util/Map<Ljava/lang/Long;Lnet/i2p/data/i2cp/MessagePayloadMessage;>;", "Ljava/util/concurrent/LinkedBlockingQueue<Lnet/i2p/client/impl/I2PSessionImpl$LookupWaiter;>;", &NetI2pClientImplI2PSessionImpl_CACHE_MAX_SIZE, &NetI2pClientImplI2PSessionImpl__lookupCache, "Ljava/util/Map<Ljava/lang/Object;Lnet/i2p/data/Destination;>;", &NetI2pClientImplI2PSessionImpl_MIN_HOST_LOOKUP_VERSION, &NetI2pClientImplI2PSessionImpl_PROP_ENABLE_SSL, &NetI2pClientImplI2PSessionImpl_PROP_USER, &NetI2pClientImplI2PSessionImpl_PROP_PW, &NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET, &NetI2pClientImplI2PSessionImpl_MIN_FAST_VERSION, "LNetI2pClientImplI2PSessionImpl_State;LNetI2pClientImplI2PSessionImpl_VerifyUsage;LNetI2pClientImplI2PSessionImpl_AvailabilityNotifier;LNetI2pClientImplI2PSessionImpl_LookupWaiter;" };
  static const J2ObjcClassInfo _NetI2pClientImplI2PSessionImpl = { "I2PSessionImpl", "net.i2p.client.impl", ptrTable, methods, fields, 7, 0x401, 67, 51, -1, 75, -1, -1, -1 };
  return &_NetI2pClientImplI2PSessionImpl;
}

+ (void)initialize {
  if (self == [NetI2pClientImplI2PSessionImpl class]) {
    NetI2pClientImplI2PSessionImpl_CACHE_MAX_SIZE = NetI2pUtilSystemVersion_isAndroid() ? 32 : 128;
    JreStrongAssignAndConsume(&NetI2pClientImplI2PSessionImpl__lookupCache, new_NetI2pUtilLHMCache_initWithInt_(NetI2pClientImplI2PSessionImpl_CACHE_MAX_SIZE));
    J2OBJC_SET_INITIALIZED(NetI2pClientImplI2PSessionImpl)
  }
}

@end

void NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_(NetI2pClientImplI2PSessionImpl *self, NetI2pI2PAppContext *context, JavaUtilProperties *options, NetI2pClientImplI2PClientMessageHandlerMap *handlerMap) {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(self, context, options, handlerMap, nil, false);
}

void NetI2pClientImplI2PSessionImpl_initWithNetI2pClientImplI2PSessionImpl_withJavaIoInputStream_withJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, NetI2pClientImplI2PSessionImpl *primary, JavaIoInputStream *destKeyStream, JavaUtilProperties *options) {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(self, [((NetI2pClientImplI2PSessionImpl *) nil_chk(primary)) getContext], options, [primary getHandlerMap], [primary getProducer], true);
  JreStrongAssignAndConsume(&self->_availabilityNotifier_, new_NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(self));
  @try {
    NetI2pClientImplI2PSessionImpl_readDestinationWithJavaIoInputStream_(self, destKeyStream);
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Error reading the destination key stream", dfe);
  }
  @catch (JavaIoIOException *ioe) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Error reading the destination key stream", ioe);
  }
}

void NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(NetI2pClientImplI2PSessionImpl *self, NetI2pI2PAppContext *context, JavaUtilProperties *options, NetI2pClientImplI2PClientMessageHandlerMap *handlerMap, NetI2pClientImplI2CPMessageProducer *producer, jboolean hasDest) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_subsessionLock_, new_NSObject_init());
  JreStrongAssignAndConsume(&self->_pendingLookups_, new_JavaUtilConcurrentLinkedBlockingQueue_init());
  JreStrongAssignAndConsume(&self->_lookupID_, new_JavaUtilConcurrentAtomicAtomicInteger_init());
  JreStrongAssignAndConsume(&self->_bwReceivedLock_, new_NSObject_init());
  JreStrongAssignAndConsume(&self->_leaseSetWait_, new_NSObject_init());
  JreStrongAssign(&self->_state_, JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, INIT));
  JreStrongAssignAndConsume(&self->_stateLock_, new_NSObject_init());
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_handlerMap_, handlerMap);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(context)) logManager])) getLogWithIOSClass:[self java_getClass]]);
  JreStrongAssignAndConsume(&self->_subsessions_, new_JavaUtilConcurrentCopyOnWriteArrayList_init());
  JreStrongAssignAndConsume(&self->_subsessionMap_, new_JavaUtilConcurrentConcurrentHashMap_initWithInt_(4));
  if (options == nil) options = (JavaUtilProperties *) cast_chk([((JavaUtilProperties *) nil_chk(JavaLangSystem_getProperties())) java_clone], [JavaUtilProperties class]);
  JreStrongAssign(&self->_options_, NetI2pClientImplI2PSessionImpl_loadConfigWithJavaUtilProperties_(self, options));
  JreStrongAssign(&self->_hostname_, NetI2pClientImplI2PSessionImpl_getHost(self));
  self->_portNum_ = NetI2pClientImplI2PSessionImpl_getPort(self);
  self->_fastReceive_ = JavaLangBoolean_parseBooleanWithNSString_([((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:NetI2pClientI2PClient_PROP_FAST_RECEIVE]);
  if (hasDest) {
    JreStrongAssign(&self->_producer_, producer);
    JreStrongAssignAndConsume(&self->_availableMessages_, new_JavaUtilConcurrentConcurrentHashMap_init());
    JreStrongAssignAndConsume(&self->_myDestination_, new_NetI2pDataDestination_init());
    JreStrongAssignAndConsume(&self->_privateKey_, new_NetI2pDataPrivateKey_init());
    JreStrongAssignAndConsume(&self->_signingPrivateKey_, new_NetI2pDataSigningPrivateKey_init());
  }
  else {
    JreStrongAssign(&self->_producer_, nil);
    JreStrongAssign(&self->_availableMessages_, nil);
    JreStrongAssign(&self->_myDestination_, nil);
    JreStrongAssign(&self->_privateKey_, nil);
    JreStrongAssign(&self->_signingPrivateKey_, nil);
  }
  JreAssignVolatileBoolean(&self->_routerSupportsFastReceive_, [((NetI2pI2PAppContext *) nil_chk(self->_context_)) isRouterContext]);
  JreAssignVolatileBoolean(&self->_routerSupportsHostLookup_, [self->_context_ isRouterContext]);
  JreAssignVolatileBoolean(&self->_routerSupportsSubsessions_, [self->_context_ isRouterContext]);
}

void NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaIoInputStream_withJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, NetI2pI2PAppContext *context, JavaIoInputStream *destKeyStream, JavaUtilProperties *options) {
  NetI2pClientImplI2PSessionImpl_initWithNetI2pI2PAppContext_withJavaUtilProperties_withNetI2pClientImplI2PClientMessageHandlerMap_withNetI2pClientImplI2CPMessageProducer_withBoolean_(self, context, options, create_NetI2pClientImplI2PClientMessageHandlerMap_initWithNetI2pI2PAppContext_(context), create_NetI2pClientImplI2CPMessageProducer_initWithNetI2pI2PAppContext_(context), true);
  JreStrongAssignAndConsume(&self->_availabilityNotifier_, new_NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(self));
  @try {
    NetI2pClientImplI2PSessionImpl_readDestinationWithJavaIoInputStream_(self, destKeyStream);
  }
  @catch (NetI2pDataDataFormatException *dfe) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Error reading the destination key stream", dfe);
  }
  @catch (JavaIoIOException *ioe) {
    @throw create_NetI2pClientI2PSessionException_initWithNSString_withJavaLangThrowable_(@"Error reading the destination key stream", ioe);
  }
}

JavaUtilProperties *NetI2pClientImplI2PSessionImpl_loadConfigWithJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, JavaUtilProperties *opts) {
  JavaUtilProperties *options = create_JavaUtilProperties_init();
  [options putAllWithJavaUtilMap:NetI2pClientImplI2PSessionImpl_filterWithJavaUtilProperties_(self, opts)];
  if ((![((NetI2pI2PAppContext *) nil_chk(self->_context_)) isRouterContext]) && [self->_context_ getBooleanPropertyWithNSString:@"i2cp.auth"] && ((![((JavaUtilProperties *) nil_chk(opts)) containsKeyWithId:NetI2pClientImplI2PSessionImpl_PROP_USER]) || (![opts containsKeyWithId:NetI2pClientImplI2PSessionImpl_PROP_PW]))) {
    NSString *configUser = [self->_context_ getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_USER];
    NSString *configPW = [self->_context_ getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_PW];
    if (configUser != nil && configPW != nil) {
      [options setPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_USER withNSString:configUser];
      [options setPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_PW withNSString:configPW];
    }
  }
  if ([options getPropertyWithNSString:NetI2pClientI2PClient_PROP_FAST_RECEIVE] == nil) [options setPropertyWithNSString:NetI2pClientI2PClient_PROP_FAST_RECEIVE withNSString:@"true"];
  if ([options getPropertyWithNSString:NetI2pClientI2PClient_PROP_RELIABILITY] == nil) [options setPropertyWithNSString:NetI2pClientI2PClient_PROP_RELIABILITY withNSString:@"none"];
  return options;
}

NSString *NetI2pClientImplI2PSessionImpl_getHost(NetI2pClientImplI2PSessionImpl *self) {
  if ([((NetI2pI2PAppContext *) nil_chk(self->_context_)) isRouterContext]) return @"[internal connection]";
  else if (NetI2pUtilSystemVersion_isAndroid() && JavaLangBoolean_parseBooleanWithNSString_([((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET])) return @"[Domain socket connection]";
  return [((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:NetI2pClientI2PClient_PROP_TCP_HOST withNSString:@"127.0.0.1"];
}

jint NetI2pClientImplI2PSessionImpl_getPort(NetI2pClientImplI2PSessionImpl *self) {
  if ([((NetI2pI2PAppContext *) nil_chk(self->_context_)) isRouterContext] || (NetI2pUtilSystemVersion_isAndroid() && JavaLangBoolean_parseBooleanWithNSString_([((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:NetI2pClientImplI2PSessionImpl_PROP_DOMAIN_SOCKET]))) return 0;
  NSString *portNum = [((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:NetI2pClientI2PClient_PROP_TCP_PORT withNSString:JreStrcat("I", NetI2pClientImplI2PSessionImpl_LISTEN_PORT)];
  @try {
    return JavaLangInteger_parseIntWithNSString_(portNum);
  }
  @catch (JavaLangNumberFormatException *nfe) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$I", [self getPrefix], @"Invalid port number specified, defaulting to ", NetI2pClientImplI2PSessionImpl_LISTEN_PORT) withJavaLangThrowable:nfe];
    return NetI2pClientImplI2PSessionImpl_LISTEN_PORT;
  }
}

JavaUtilProperties *NetI2pClientImplI2PSessionImpl_filterWithJavaUtilProperties_(NetI2pClientImplI2PSessionImpl *self, JavaUtilProperties *options) {
  JavaUtilProperties *rv = create_JavaUtilProperties_init();
  for (NSString * __strong key in nil_chk([((JavaUtilProperties *) nil_chk(options)) stringPropertyNames])) {
    if ([((NSString *) nil_chk(key)) java_hasPrefix:@"java."] || [key java_hasPrefix:@"user."] || [key java_hasPrefix:@"os."] || [key java_hasPrefix:@"sun."] || [key java_hasPrefix:@"awt."] || [key java_hasPrefix:@"file."] || [key isEqual:@"line.separator"] || [key isEqual:@"path.separator"] || [key isEqual:@"prng.buffers"] || [key isEqual:@"router.trustedUpdateKeys"] || [key java_hasPrefix:@"router.update"] || [key java_hasPrefix:@"routerconsole."] || [key java_hasPrefix:@"time."] || [key java_hasPrefix:@"stat."] || [key java_hasPrefix:@"gnu."] || [key java_hasPrefix:@"net.i2p.router.web."] || [key isEqual:@"loggerFilenameOverride"] || [key isEqual:@"router.version"] || [key isEqual:@"i2p.dir.base"] || [key java_hasPrefix:@"networkaddress.cache."] || [key java_hasPrefix:@"http."] || [key java_hasPrefix:@"jetty."] || [key java_hasPrefix:@"org.mortbay."] || [key java_hasPrefix:@"wrapper."]) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$$", @"Skipping property: ", key)];
      continue;
    }
    NSString *val = [options getPropertyWithNSString:key];
    if ([key java_length] > 255 || [((NSString *) nil_chk(val)) java_length] > 255) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$$$", @"Not passing on property [", key, @"] in the session config, key or value is too long (max = 255): ", val)];
    }
    else {
      [rv setPropertyWithNSString:key withNSString:val];
    }
  }
  return rv;
}

void NetI2pClientImplI2PSessionImpl_readDestinationWithJavaIoInputStream_(NetI2pClientImplI2PSessionImpl *self, JavaIoInputStream *destKeyStream) {
  [((NetI2pDataDestination *) nil_chk(self->_myDestination_)) readBytesWithJavaIoInputStream:destKeyStream];
  [((NetI2pDataPrivateKey *) nil_chk(self->_privateKey_)) readBytesWithJavaIoInputStream:destKeyStream];
  JreStrongAssignAndConsume(&self->_signingPrivateKey_, new_NetI2pDataSigningPrivateKey_initWithNetI2pCryptoSigType_([((NetI2pDataSigningPublicKey *) nil_chk([self->_myDestination_ getSigningPublicKey])) getType]));
  [self->_signingPrivateKey_ readBytesWithJavaIoInputStream:destKeyStream];
}

void NetI2pClientImplI2PSessionImpl_closeSocket(NetI2pClientImplI2PSessionImpl *self) {
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$$", [self getPrefix], @"Closing the socket") withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"closeSocket")];
  NetI2pDataDestination *d = self->_myDestination_;
  if (d != nil) [((NetI2pUtilKeyRing *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) keyRing])) removeWithId:[d calculateHash]];
  @synchronized(self->_stateLock_) {
    [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING)];
    NetI2pClientImplI2PSessionImpl_locked_closeSocket(self);
    [self changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED)];
  }
  @synchronized(self->_subsessionLock_) {
    for (NetI2pClientImplSubSession * __strong sess in nil_chk(self->_subsessions_)) {
      d = JreRetainedLocalValue([((NetI2pClientImplSubSession *) nil_chk(sess)) getMyDestination]);
      if (d != nil) [((NetI2pUtilKeyRing *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) keyRing])) removeWithId:[d calculateHash]];
      [sess changeStateWithNetI2pClientImplI2PSessionImpl_State:JreLoadEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED)];
      [sess setSessionIdWithNetI2pDataI2cpSessionId:nil];
      [sess setLeaseSetWithNetI2pDataLeaseSet:nil];
    }
  }
}

void NetI2pClientImplI2PSessionImpl_locked_closeSocket(NetI2pClientImplI2PSessionImpl *self) {
  if (self->_reader_ != nil) {
    [self->_reader_ stopReading];
    JreStrongAssign(&self->_reader_, nil);
  }
  if (self->_queue_ != nil) {
    [self->_queue_ close];
  }
  if (self->_writer_ != nil) {
    [self->_writer_ stopWriting];
    JreStrongAssign(&self->_writer_, nil);
  }
  if (self->_socket_ != nil) {
    @try {
      [self->_socket_ close];
    }
    @catch (JavaIoIOException *ioe) {
      [self propogateErrorWithNSString:@"Caught an IO error closing the socket.  ignored" withJavaLangThrowable:ioe];
    }
    @finally {
      JreStrongAssign(&self->_socket_, nil);
    }
  }
  [self setSessionIdWithNetI2pDataI2cpSessionId:nil];
  [self setLeaseSetWithNetI2pDataLeaseSet:nil];
}

void NetI2pClientImplI2PSessionImpl_clearCache() {
  NetI2pClientImplI2PSessionImpl_initialize();
  @synchronized(NetI2pClientImplI2PSessionImpl__lookupCache) {
    [((id<JavaUtilMap>) nil_chk(NetI2pClientImplI2PSessionImpl__lookupCache)) clear];
  }
}

void NetI2pClientImplI2PSessionImpl_startIdleMonitor(NetI2pClientImplI2PSessionImpl *self) {
  self->_isReduced_ = false;
  jboolean reduce = JavaLangBoolean_parseBooleanWithNSString_([((JavaUtilProperties *) nil_chk(self->_options_)) getPropertyWithNSString:@"i2cp.reduceOnIdle"]);
  jboolean close = JavaLangBoolean_parseBooleanWithNSString_([self->_options_ getPropertyWithNSString:@"i2cp.closeOnIdle"]);
  if (reduce || close) {
    [self updateActivity];
    [((NetI2pUtilSimpleTimer2 *) nil_chk([((NetI2pI2PAppContext *) nil_chk(self->_context_)) simpleTimer2])) addEventWithNetI2pUtilSimpleTimer_TimedEvent:create_NetI2pClientImplSessionIdleTimer_initWithNetI2pI2PAppContext_withNetI2pClientImplI2PSessionImpl_withBoolean_withBoolean_(self->_context_, self, reduce, close) withLong:NetI2pClientImplSessionIdleTimer_MINIMUM_TIME];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pClientImplI2PSessionImpl)

J2OBJC_INITIALIZED_DEFN(NetI2pClientImplI2PSessionImpl_State)

NetI2pClientImplI2PSessionImpl_State *NetI2pClientImplI2PSessionImpl_State_values_[6];

@implementation NetI2pClientImplI2PSessionImpl_State

+ (NetI2pClientImplI2PSessionImpl_State *)INIT {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, INIT);
}

+ (NetI2pClientImplI2PSessionImpl_State *)OPENING {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, OPENING);
}

+ (NetI2pClientImplI2PSessionImpl_State *)GOTDATE {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, GOTDATE);
}

+ (NetI2pClientImplI2PSessionImpl_State *)OPEN {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, OPEN);
}

+ (NetI2pClientImplI2PSessionImpl_State *)CLOSING {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING);
}

+ (NetI2pClientImplI2PSessionImpl_State *)CLOSED {
  return JreEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED);
}

+ (IOSObjectArray *)values {
  return NetI2pClientImplI2PSessionImpl_State_values();
}

+ (NetI2pClientImplI2PSessionImpl_State *)valueOfWithNSString:(NSString *)name {
  return NetI2pClientImplI2PSessionImpl_State_valueOfWithNSString_(name);
}

- (NetI2pClientImplI2PSessionImpl_State_Enum)toNSEnum {
  return (NetI2pClientImplI2PSessionImpl_State_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LNetI2pClientImplI2PSessionImpl_State;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pClientImplI2PSessionImpl_State;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "INIT", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "OPENING", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "GOTDATE", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "OPEN", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 5, -1, -1 },
    { "CLOSING", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 6, -1, -1 },
    { "CLOSED", "LNetI2pClientImplI2PSessionImpl_State;", .constantValue.asLong = 0, 0x4019, -1, 7, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(NetI2pClientImplI2PSessionImpl_State, INIT), &JreEnum(NetI2pClientImplI2PSessionImpl_State, OPENING), &JreEnum(NetI2pClientImplI2PSessionImpl_State, GOTDATE), &JreEnum(NetI2pClientImplI2PSessionImpl_State, OPEN), &JreEnum(NetI2pClientImplI2PSessionImpl_State, CLOSING), &JreEnum(NetI2pClientImplI2PSessionImpl_State, CLOSED), "LNetI2pClientImplI2PSessionImpl;", "Ljava/lang/Enum<Lnet/i2p/client/impl/I2PSessionImpl$State;>;" };
  static const J2ObjcClassInfo _NetI2pClientImplI2PSessionImpl_State = { "State", "net.i2p.client.impl", ptrTable, methods, fields, 7, 0x401c, 2, 6, 8, -1, -1, 9, -1 };
  return &_NetI2pClientImplI2PSessionImpl_State;
}

+ (void)initialize {
  if (self == [NetI2pClientImplI2PSessionImpl_State class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 6 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    for (jint i = 0; i < 6; i++) {
      ((void)(NetI2pClientImplI2PSessionImpl_State_values_[i] = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
      NetI2pClientImplI2PSessionImpl_State_initWithNSString_withInt_(e, JreEnumConstantName(NetI2pClientImplI2PSessionImpl_State_class_(), i), i);
    }
    J2OBJC_SET_INITIALIZED(NetI2pClientImplI2PSessionImpl_State)
  }
}

@end

void NetI2pClientImplI2PSessionImpl_State_initWithNSString_withInt_(NetI2pClientImplI2PSessionImpl_State *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *NetI2pClientImplI2PSessionImpl_State_values() {
  NetI2pClientImplI2PSessionImpl_State_initialize();
  return [IOSObjectArray arrayWithObjects:NetI2pClientImplI2PSessionImpl_State_values_ count:6 type:NetI2pClientImplI2PSessionImpl_State_class_()];
}

NetI2pClientImplI2PSessionImpl_State *NetI2pClientImplI2PSessionImpl_State_valueOfWithNSString_(NSString *name) {
  NetI2pClientImplI2PSessionImpl_State_initialize();
  for (int i = 0; i < 6; i++) {
    NetI2pClientImplI2PSessionImpl_State *e = NetI2pClientImplI2PSessionImpl_State_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

NetI2pClientImplI2PSessionImpl_State *NetI2pClientImplI2PSessionImpl_State_fromOrdinal(NSUInteger ordinal) {
  NetI2pClientImplI2PSessionImpl_State_initialize();
  if (ordinal >= 6) {
    return nil;
  }
  return NetI2pClientImplI2PSessionImpl_State_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pClientImplI2PSessionImpl_State)

@implementation NetI2pClientImplI2PSessionImpl_VerifyUsage

- (instancetype)initWithNetI2pClientImplI2PSessionImpl:(NetI2pClientImplI2PSessionImpl *)outer$ {
  NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(self, outer$);
  return self;
}

- (void)timeReached {
  if ([this$0_ isClosed]) return;
  if (![((id<JavaUtilList>) nil_chk(toCheck_)) isEmpty]) {
    for (JavaLangLong * __strong msgId in toCheck_) {
      NetI2pDataI2cpMessagePayloadMessage *removed = [((id<JavaUtilMap>) nil_chk(this$0_->_availableMessages_)) removeWithId:msgId];
      if (removed != nil) [((NetI2pUtilLog *) nil_chk(this$0_->_log_)) errorWithNSString:JreStrcat("$$@$@", [this$0_ getPrefix], @" Client not responding? Message not processed! id=", msgId, @": ", removed)];
    }
    [toCheck_ clear];
  }
  [toCheck_ addAllWithJavaUtilCollection:[((id<JavaUtilMap>) nil_chk(this$0_->_availableMessages_)) keySet]];
  [self scheduleWithLong:NetI2pClientImplI2PSessionImpl_VERIFY_USAGE_TIME];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(toCheck_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pClientImplI2PSessionImpl:);
  methods[1].selector = @selector(timeReached);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pClientImplI2PSessionImpl;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "toCheck_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 0, -1 },
  };
  static const void *ptrTable[] = { "Ljava/util/List<Ljava/lang/Long;>;", "LNetI2pClientImplI2PSessionImpl;" };
  static const J2ObjcClassInfo _NetI2pClientImplI2PSessionImpl_VerifyUsage = { "VerifyUsage", "net.i2p.client.impl", ptrTable, methods, fields, 7, 0x2, 2, 2, 1, -1, -1, -1, -1 };
  return &_NetI2pClientImplI2PSessionImpl_VerifyUsage;
}

@end

void NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl_VerifyUsage *self, NetI2pClientImplI2PSessionImpl *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pUtilSimpleTimer2_TimedEvent_initWithNetI2pUtilSimpleTimer2_withLong_(self, [((NetI2pI2PAppContext *) nil_chk(outer$->_context_)) simpleTimer2], NetI2pClientImplI2PSessionImpl_VERIFY_USAGE_TIME);
  JreStrongAssignAndConsume(&self->toCheck_, new_JavaUtilArrayList_init());
}

NetI2pClientImplI2PSessionImpl_VerifyUsage *new_NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$) {
  J2OBJC_NEW_IMPL(NetI2pClientImplI2PSessionImpl_VerifyUsage, initWithNetI2pClientImplI2PSessionImpl_, outer$)
}

NetI2pClientImplI2PSessionImpl_VerifyUsage *create_NetI2pClientImplI2PSessionImpl_VerifyUsage_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$) {
  J2OBJC_CREATE_IMPL(NetI2pClientImplI2PSessionImpl_VerifyUsage, initWithNetI2pClientImplI2PSessionImpl_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pClientImplI2PSessionImpl_VerifyUsage)

@implementation NetI2pClientImplI2PSessionImpl_AvailabilityNotifier

- (instancetype)initWithNetI2pClientImplI2PSessionImpl:(NetI2pClientImplI2PSessionImpl *)outer$ {
  NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(self, outer$);
  return self;
}

- (void)stopNotifying {
  JreAssignVolatileBoolean(&_alive_, false);
  @synchronized(self) {
    [self java_notifyAll];
  }
}

- (void)availableWithLong:(jlong)msgId
                  withInt:(jint)size {
  @synchronized(self) {
    [((id<JavaUtilList>) nil_chk(_pendingIds_)) addWithId:JavaLangLong_valueOfWithLong_(msgId)];
    [((id<JavaUtilList>) nil_chk(_pendingSizes_)) addWithId:JavaLangInteger_valueOfWithInt_(size)];
    [self java_notifyAll];
  }
}

- (void)run {
  JreAssignVolatileBoolean(&_alive_, true);
  while (JreLoadVolatileBoolean(&_alive_)) {
    JavaLangLong *msgId = nil;
    JavaLangInteger *size = nil;
    @synchronized(self) {
      if ([((id<JavaUtilList>) nil_chk(_pendingIds_)) isEmpty]) {
        @try {
          [self java_wait];
        }
        @catch (JavaLangInterruptedException *ie) {
        }
      }
      if (![_pendingIds_ isEmpty]) {
        msgId = JreRetainedLocalValue([_pendingIds_ removeWithInt:0]);
        size = JreRetainedLocalValue([((id<JavaUtilList>) nil_chk(_pendingSizes_)) removeWithInt:0]);
      }
    }
    if ((msgId != nil) && (size != nil)) {
      if (this$0_->_sessionListener_ != nil) {
        @try {
          jlong before = JavaLangSystem_currentTimeMillis();
          [((id<NetI2pClientI2PSessionListener>) nil_chk(this$0_->_sessionListener_)) messageAvailableWithNetI2pClientI2PSession:this$0_ withInt:[((JavaLangLong *) nil_chk(msgId)) intValue] withLong:[((JavaLangInteger *) nil_chk(size)) intValue]];
          jlong duration = JavaLangSystem_currentTimeMillis() - before;
          if ((duration > 100) && [((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [((NetI2pUtilLog *) nil_chk(this$0_->_log_)) infoWithNSString:JreStrcat("$I$J$@", @"Message availability notification for ", [msgId intValue], @" took ", duration, @" to ", this$0_->_sessionListener_)];
        }
        @catch (JavaLangRuntimeException *e) {
          [((NetI2pUtilLog *) nil_chk(this$0_->_log_)) logWithInt:NetI2pUtilLog_CRIT withNSString:@"Error notifying app of message availability" withJavaLangThrowable:e];
        }
      }
      else {
        [((NetI2pUtilLog *) nil_chk(this$0_->_log_)) logWithInt:NetI2pUtilLog_CRIT withNSString:JreStrcat("$@$@$", @"Unable to notify an app that ", msgId, @" of size ", size, @" is available!")];
      }
    }
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(_pendingIds_);
  RELEASE_(_pendingSizes_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pClientImplI2PSessionImpl:);
  methods[1].selector = @selector(stopNotifying);
  methods[2].selector = @selector(availableWithLong:withInt:);
  methods[3].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pClientImplI2PSessionImpl;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "_pendingIds_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 2, -1 },
    { "_pendingSizes_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 3, -1 },
    { "_alive_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "available", "JI", "Ljava/util/List<Ljava/lang/Long;>;", "Ljava/util/List<Ljava/lang/Integer;>;", "LNetI2pClientImplI2PSessionImpl;" };
  static const J2ObjcClassInfo _NetI2pClientImplI2PSessionImpl_AvailabilityNotifier = { "AvailabilityNotifier", "net.i2p.client.impl", ptrTable, methods, fields, 7, 0x4, 4, 4, 4, -1, -1, -1, -1 };
  return &_NetI2pClientImplI2PSessionImpl_AvailabilityNotifier;
}

@end

void NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *self, NetI2pClientImplI2PSessionImpl *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_pendingIds_, new_JavaUtilArrayList_initWithInt_(2));
  JreStrongAssignAndConsume(&self->_pendingSizes_, new_JavaUtilArrayList_initWithInt_(2));
}

NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *new_NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$) {
  J2OBJC_NEW_IMPL(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier, initWithNetI2pClientImplI2PSessionImpl_, outer$)
}

NetI2pClientImplI2PSessionImpl_AvailabilityNotifier *create_NetI2pClientImplI2PSessionImpl_AvailabilityNotifier_initWithNetI2pClientImplI2PSessionImpl_(NetI2pClientImplI2PSessionImpl *outer$) {
  J2OBJC_CREATE_IMPL(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier, initWithNetI2pClientImplI2PSessionImpl_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pClientImplI2PSessionImpl_AvailabilityNotifier)

@implementation NetI2pClientImplI2PSessionImpl_LookupWaiter

- (instancetype)initWithNetI2pDataHash:(NetI2pDataHash *)h {
  NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(self, h);
  return self;
}

- (instancetype)initWithNetI2pDataHash:(NetI2pDataHash *)h
                              withLong:(jlong)nonce {
  NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(self, h, nonce);
  return self;
}

- (instancetype)initWithNSString:(NSString *)name
                        withLong:(jlong)nonce {
  NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(self, name, nonce);
  return self;
}

- (void)dealloc {
  RELEASE_(hash__);
  RELEASE_(name_);
  RELEASE_(destination_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pDataHash:);
  methods[1].selector = @selector(initWithNetI2pDataHash:withLong:);
  methods[2].selector = @selector(initWithNSString:withLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "hash__", "LNetI2pDataHash;", .constantValue.asLong = 0, 0x11, 3, -1, -1, -1 },
    { "name_", "LNSString;", .constantValue.asLong = 0, 0x11, -1, -1, -1, -1 },
    { "nonce_", "J", .constantValue.asLong = 0, 0x11, -1, -1, -1, -1 },
    { "destination_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pDataHash;", "LNetI2pDataHash;J", "LNSString;J", "hash", "LNetI2pClientImplI2PSessionImpl;" };
  static const J2ObjcClassInfo _NetI2pClientImplI2PSessionImpl_LookupWaiter = { "LookupWaiter", "net.i2p.client.impl", ptrTable, methods, fields, 7, 0xa, 3, 4, 4, -1, -1, -1, -1 };
  return &_NetI2pClientImplI2PSessionImpl_LookupWaiter;
}

@end

void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NetI2pDataHash *h) {
  NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(self, h, -1);
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pDataHash *h) {
  J2OBJC_NEW_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNetI2pDataHash_, h)
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_(NetI2pDataHash *h) {
  J2OBJC_CREATE_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNetI2pDataHash_, h)
}

void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NetI2pDataHash *h, jlong nonce) {
  NSObject_init(self);
  JreStrongAssign(&self->hash__, h);
  JreStrongAssign(&self->name_, nil);
  self->nonce_ = nonce;
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pDataHash *h, jlong nonce) {
  J2OBJC_NEW_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNetI2pDataHash_withLong_, h, nonce)
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNetI2pDataHash_withLong_(NetI2pDataHash *h, jlong nonce) {
  J2OBJC_CREATE_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNetI2pDataHash_withLong_, h, nonce)
}

void NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NetI2pClientImplI2PSessionImpl_LookupWaiter *self, NSString *name, jlong nonce) {
  NSObject_init(self);
  JreStrongAssign(&self->hash__, nil);
  JreStrongAssign(&self->name_, name);
  self->nonce_ = nonce;
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *new_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NSString *name, jlong nonce) {
  J2OBJC_NEW_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNSString_withLong_, name, nonce)
}

NetI2pClientImplI2PSessionImpl_LookupWaiter *create_NetI2pClientImplI2PSessionImpl_LookupWaiter_initWithNSString_withLong_(NSString *name, jlong nonce) {
  J2OBJC_CREATE_IMPL(NetI2pClientImplI2PSessionImpl_LookupWaiter, initWithNSString_withLong_, name, nonce)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pClientImplI2PSessionImpl_LookupWaiter)
