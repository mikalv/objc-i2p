//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/tunnel/TunnelDispatcher.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/Writer.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Enum.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/annotation/Annotation.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/List.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/LinkedBlockingQueue.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/data/i2np/I2NPMessage.h"
#include "net/i2p/data/i2np/TunnelBuildMessage.h"
#include "net/i2p/data/i2np/TunnelBuildReplyMessage.h"
#include "net/i2p/data/i2np/TunnelDataMessage.h"
#include "net/i2p/data/i2np/TunnelGatewayMessage.h"
#include "net/i2p/data/i2np/VariableTunnelBuildMessage.h"
#include "net/i2p/data/i2np/VariableTunnelBuildReplyMessage.h"
#include "net/i2p/router/JobImpl.h"
#include "net/i2p/router/JobQueue.h"
#include "net/i2p/router/JobTiming.h"
#include "net/i2p/router/MessageHistory.h"
#include "net/i2p/router/Router.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/peermanager/PeerProfile.h"
#include "net/i2p/router/peermanager/ProfileOrganizer.h"
#include "net/i2p/router/peermanager/TunnelHistory.h"
#include "net/i2p/router/transport/FIFOBandwidthLimiter.h"
#include "net/i2p/router/tunnel/BatchedRouterPreprocessor.h"
#include "net/i2p/router/tunnel/BloomFilterIVValidator.h"
#include "net/i2p/router/tunnel/HopConfig.h"
#include "net/i2p/router/tunnel/HopProcessor.h"
#include "net/i2p/router/tunnel/InboundEndpointProcessor.h"
#include "net/i2p/router/tunnel/InboundGatewayReceiver.h"
#include "net/i2p/router/tunnel/InboundSender.h"
#include "net/i2p/router/tunnel/OutboundReceiver.h"
#include "net/i2p/router/tunnel/OutboundSender.h"
#include "net/i2p/router/tunnel/OutboundTunnelEndpoint.h"
#include "net/i2p/router/tunnel/PumpedTunnelGateway.h"
#include "net/i2p/router/tunnel/ThrottledPumpedTunnelGateway.h"
#include "net/i2p/router/tunnel/TunnelCreatorConfig.h"
#include "net/i2p/router/tunnel/TunnelDispatcher.h"
#include "net/i2p/router/tunnel/TunnelGateway.h"
#include "net/i2p/router/tunnel/TunnelGatewayPumper.h"
#include "net/i2p/router/tunnel/TunnelGatewayZeroHop.h"
#include "net/i2p/router/tunnel/TunnelParticipant.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"

@class NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel;

@interface NetI2pRouterTunnelTunnelDispatcher () {
 @public
  NetI2pRouterRouterContext *_context_;
  NetI2pUtilLog *_log_;
  JavaUtilConcurrentConcurrentHashMap *_outboundGateways_;
  JavaUtilConcurrentConcurrentHashMap *_outboundEndpoints_;
  JavaUtilConcurrentConcurrentHashMap *_participants_;
  JavaUtilConcurrentConcurrentHashMap *_inboundGateways_;
  JavaUtilConcurrentConcurrentHashMap *_participatingConfig_;
  jlong _lastParticipatingExpiration_;
  NetI2pRouterTunnelBloomFilterIVValidator *_validator_;
  NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *_leaveJob_;
  NetI2pRouterTunnelTunnelGatewayPumper *_pumper_;
  id _joinParticipantLock_;
}

- (id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor>)createPreprocessorWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg;

- (id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor>)createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig:(NetI2pRouterTunnelTunnelCreatorConfig *)cfg;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _context_, NetI2pRouterRouterContext *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _outboundGateways_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _outboundEndpoints_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _participants_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _inboundGateways_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _participatingConfig_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _validator_, NetI2pRouterTunnelBloomFilterIVValidator *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _leaveJob_, NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _pumper_, NetI2pRouterTunnelTunnelGatewayPumper *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher, _joinParticipantLock_, id)

inline IOSLongArray *NetI2pRouterTunnelTunnelDispatcher_get_RATES(void);
static IOSLongArray *NetI2pRouterTunnelTunnelDispatcher_RATES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterTunnelTunnelDispatcher, RATES, IOSLongArray *)

inline jlong NetI2pRouterTunnelTunnelDispatcher_get_MAX_FUTURE_EXPIRATION(void);
#define NetI2pRouterTunnelTunnelDispatcher_MAX_FUTURE_EXPIRATION 240000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTunnelTunnelDispatcher, MAX_FUTURE_EXPIRATION, jlong)

__attribute__((unused)) static id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelHopConfig_(NetI2pRouterTunnelTunnelDispatcher *self, NetI2pRouterTunnelHopConfig *cfg);

__attribute__((unused)) static id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig_(NetI2pRouterTunnelTunnelDispatcher *self, NetI2pRouterTunnelTunnelCreatorConfig *cfg);

__attribute__((unused)) static IOSObjectArray *NetI2pRouterTunnelTunnelDispatcher__Annotations$0(void);

__attribute__((unused)) static void NetI2pRouterTunnelTunnelDispatcher_Location_initWithNSString_withInt_(NetI2pRouterTunnelTunnelDispatcher_Location *self, NSString *__name, jint __ordinal);

@interface NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel : NetI2pRouterJobImpl {
 @public
  NetI2pRouterTunnelTunnelDispatcher *this$0_;
  JavaUtilConcurrentLinkedBlockingQueue *_configs_;
}

- (instancetype)initWithNetI2pRouterTunnelTunnelDispatcher:(NetI2pRouterTunnelTunnelDispatcher *)outer$
                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx;

- (void)addWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg;

- (void)clear;

- (NSString *)getName;

- (void)runJob;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel)

J2OBJC_FIELD_SETTER(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel, _configs_, JavaUtilConcurrentLinkedBlockingQueue *)

inline jint NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_get_LEAVE_BATCH_TIME(void);
#define NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_LEAVE_BATCH_TIME 10000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel, LEAVE_BATCH_TIME, jint)

__attribute__((unused)) static void NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *self, NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx);

__attribute__((unused)) static NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *new_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *create_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel)

J2OBJC_INITIALIZED_DEFN(NetI2pRouterTunnelTunnelDispatcher)

@implementation NetI2pRouterTunnelTunnelDispatcher

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx {
  NetI2pRouterTunnelTunnelDispatcher_initWithNetI2pRouterRouterContext_(self, ctx);
  return self;
}

- (id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor>)createPreprocessorWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  return NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelHopConfig_(self, cfg);
}

- (id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor>)createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig:(NetI2pRouterTunnelTunnelCreatorConfig *)cfg {
  return NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig_(self, cfg);
}

- (jboolean)joinOutboundWithNetI2pRouterTunnelTunnelCreatorConfig:(NetI2pRouterTunnelTunnelCreatorConfig *)cfg {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Outbound built successfully: ", cfg)];
  NetI2pRouterTunnelTunnelGateway *gw;
  if ([((NetI2pRouterTunnelTunnelCreatorConfig *) nil_chk(cfg)) getLength] > 1) {
    id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> preproc = NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig_(self, cfg);
    id<NetI2pRouterTunnelTunnelGateway_Sender> sender = create_NetI2pRouterTunnelOutboundSender_initWithNetI2pI2PAppContext_withNetI2pRouterTunnelTunnelCreatorConfig_(_context_, cfg);
    id<NetI2pRouterTunnelTunnelGateway_Receiver> receiver = create_NetI2pRouterTunnelOutboundReceiver_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelCreatorConfig_(_context_, cfg);
    gw = create_NetI2pRouterTunnelPumpedTunnelGateway_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelGateway_QueuePreprocessor_withNetI2pRouterTunnelTunnelGateway_Sender_withNetI2pRouterTunnelTunnelGateway_Receiver_withNetI2pRouterTunnelTunnelGatewayPumper_(_context_, preproc, sender, receiver, _pumper_);
  }
  else {
    gw = create_NetI2pRouterTunnelTunnelGatewayZeroHop_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelCreatorConfig_(_context_, cfg);
  }
  NetI2pDataTunnelId *outId = [((NetI2pRouterTunnelHopConfig *) nil_chk([cfg getConfigWithInt:0])) getSendTunnel];
  if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundGateways_)) putIfAbsentWithId:outId withId:gw] != nil) return false;
  if ([cfg getLength] > 1) {
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.joinOutboundGateway" withLong:1];
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelJoinedWithNSString:@"outbound" withNetI2pRouterTunnelInfo:cfg];
  }
  else {
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.joinOutboundGatewayZeroHop" withLong:1];
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelJoinedWithNSString:@"outboundZeroHop" withNetI2pRouterTunnelInfo:cfg];
  }
  return true;
}

- (jboolean)joinInboundWithNetI2pRouterTunnelTunnelCreatorConfig:(NetI2pRouterTunnelTunnelCreatorConfig *)cfg {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Inbound built successfully: ", cfg)];
  if ([((NetI2pRouterTunnelTunnelCreatorConfig *) nil_chk(cfg)) getLength] > 1) {
    NetI2pRouterTunnelTunnelParticipant *participant = create_NetI2pRouterTunnelTunnelParticipant_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelInboundEndpointProcessor_(_context_, create_NetI2pRouterTunnelInboundEndpointProcessor_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelCreatorConfig_withNetI2pRouterTunnelIVValidator_(_context_, cfg, _validator_));
    NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk([cfg getConfigWithInt:[cfg getLength] - 1])) getReceiveTunnel];
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) putIfAbsentWithId:recvId withId:participant] != nil) return false;
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.joinInboundEndpoint" withLong:1];
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelJoinedWithNSString:@"inboundEndpoint" withNetI2pRouterTunnelInfo:cfg];
  }
  else {
    NetI2pRouterTunnelTunnelGatewayZeroHop *gw = create_NetI2pRouterTunnelTunnelGatewayZeroHop_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelCreatorConfig_(_context_, cfg);
    NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk([cfg getConfigWithInt:0])) getReceiveTunnel];
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) putIfAbsentWithId:recvId withId:gw] != nil) return false;
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.joinInboundEndpointZeroHop" withLong:1];
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelJoinedWithNSString:@"inboundEndpointZeroHop" withNetI2pRouterTunnelInfo:cfg];
  }
  return true;
}

- (jboolean)joinParticipantWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Joining as participant: ", cfg)];
  NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk(cfg)) getReceiveTunnel];
  NetI2pRouterTunnelTunnelParticipant *participant = create_NetI2pRouterTunnelTunnelParticipant_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelHopConfig_withNetI2pRouterTunnelHopProcessor_(_context_, cfg, create_NetI2pRouterTunnelHopProcessor_initWithNetI2pI2PAppContext_withNetI2pRouterTunnelHopConfig_withNetI2pRouterTunnelIVValidator_(_context_, cfg, _validator_));
  @synchronized(_joinParticipantLock_) {
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) putIfAbsentWithId:recvId withId:cfg] != nil) return false;
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) putIfAbsentWithId:recvId withId:participant] != nil) {
      [_participatingConfig_ removeWithId:recvId];
      return false;
    }
  }
  [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) tunnelJoinedWithNSString:@"participant" withNetI2pRouterTunnelHopConfig:cfg];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.joinParticipant" withLong:1];
  if ([cfg getExpiration] > _lastParticipatingExpiration_) _lastParticipatingExpiration_ = [cfg getExpiration];
  [((NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *) nil_chk(_leaveJob_)) addWithNetI2pRouterTunnelHopConfig:cfg];
  return true;
}

- (jboolean)joinOutboundEndpointWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Joining as OBEP: ", cfg)];
  NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk(cfg)) getReceiveTunnel];
  NetI2pRouterTunnelOutboundTunnelEndpoint *endpoint = create_NetI2pRouterTunnelOutboundTunnelEndpoint_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelHopConfig_withNetI2pRouterTunnelHopProcessor_(_context_, cfg, create_NetI2pRouterTunnelHopProcessor_initWithNetI2pI2PAppContext_withNetI2pRouterTunnelHopConfig_withNetI2pRouterTunnelIVValidator_(_context_, cfg, _validator_));
  @synchronized(_joinParticipantLock_) {
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) putIfAbsentWithId:recvId withId:cfg] != nil) return false;
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundEndpoints_)) putIfAbsentWithId:recvId withId:endpoint] != nil) {
      [_participatingConfig_ removeWithId:recvId];
      return false;
    }
  }
  [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) tunnelJoinedWithNSString:@"outboundEndpoint" withNetI2pRouterTunnelHopConfig:cfg];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.joinOutboundEndpoint" withLong:1];
  if ([cfg getExpiration] > _lastParticipatingExpiration_) _lastParticipatingExpiration_ = [cfg getExpiration];
  [((NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *) nil_chk(_leaveJob_)) addWithNetI2pRouterTunnelHopConfig:cfg];
  return true;
}

- (jboolean)joinInboundGatewayWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Joining as IBGW: ", cfg)];
  id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> preproc = NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelHopConfig_(self, cfg);
  id<NetI2pRouterTunnelTunnelGateway_Sender> sender = create_NetI2pRouterTunnelInboundSender_initWithNetI2pI2PAppContext_withNetI2pRouterTunnelHopConfig_(_context_, cfg);
  id<NetI2pRouterTunnelTunnelGateway_Receiver> receiver = create_NetI2pRouterTunnelInboundGatewayReceiver_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelHopConfig_(_context_, cfg);
  NetI2pRouterTunnelTunnelGateway *gw = create_NetI2pRouterTunnelThrottledPumpedTunnelGateway_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelGateway_QueuePreprocessor_withNetI2pRouterTunnelTunnelGateway_Sender_withNetI2pRouterTunnelTunnelGateway_Receiver_withNetI2pRouterTunnelTunnelGatewayPumper_withNetI2pRouterTunnelHopConfig_(_context_, preproc, sender, receiver, _pumper_, cfg);
  NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk(cfg)) getReceiveTunnel];
  @synchronized(_joinParticipantLock_) {
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) putIfAbsentWithId:recvId withId:cfg] != nil) return false;
    if ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) putIfAbsentWithId:recvId withId:gw] != nil) {
      [_participatingConfig_ removeWithId:recvId];
      return false;
    }
  }
  [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) tunnelJoinedWithNSString:@"inboundGateway" withNetI2pRouterTunnelHopConfig:cfg];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.joinInboundGateway" withLong:1];
  if ([cfg getExpiration] > _lastParticipatingExpiration_) _lastParticipatingExpiration_ = [cfg getExpiration];
  [((NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *) nil_chk(_leaveJob_)) addWithNetI2pRouterTunnelHopConfig:cfg];
  return true;
}

- (jint)getParticipatingCount {
  return [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) size];
}

- (jlong)getNewOBGWID {
  jlong rv;
  NetI2pDataTunnelId *tid;
  do {
    rv = 1 + [((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) random])) nextLongWithLong:NetI2pDataTunnelId_MAX_ID_VALUE];
    tid = create_NetI2pDataTunnelId_initWithLong_(rv);
  }
  while ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundGateways_)) containsKeyWithId:tid]);
  return rv;
}

- (jlong)getNewIBEPID {
  jlong rv;
  NetI2pDataTunnelId *tid;
  do {
    rv = 1 + [((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) random])) nextLongWithLong:NetI2pDataTunnelId_MAX_ID_VALUE];
    tid = create_NetI2pDataTunnelId_initWithLong_(rv);
  }
  while ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) containsKeyWithId:tid]);
  return rv;
}

- (jlong)getNewIBZeroHopID {
  jlong rv;
  NetI2pDataTunnelId *tid;
  do {
    rv = 1 + [((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) random])) nextLongWithLong:NetI2pDataTunnelId_MAX_ID_VALUE];
    tid = create_NetI2pDataTunnelId_initWithLong_(rv);
  }
  while ([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) containsKeyWithId:tid]);
  return rv;
}

- (jlong)getLastParticipatingExpiration {
  return _lastParticipatingExpiration_;
}

- (void)removeWithNetI2pRouterTunnelTunnelCreatorConfig:(NetI2pRouterTunnelTunnelCreatorConfig *)cfg {
  if ([((NetI2pRouterTunnelTunnelCreatorConfig *) nil_chk(cfg)) isInbound]) {
    NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk([cfg getConfigWithInt:[cfg getLength] - 1])) getReceiveTunnel];
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"removing our own inbound ", cfg)];
    NetI2pRouterTunnelTunnelParticipant *participant = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) removeWithId:recvId];
    if (participant == nil) {
      [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) removeWithId:recvId];
    }
    else {
      for (jint i = 0; i < [cfg getLength] - 1; i++) {
        NetI2pDataHash *peer = [cfg getPeerWithInt:i];
        NetI2pRouterPeermanagerPeerProfile *profile = [((NetI2pRouterPeermanagerProfileOrganizer *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) profileOrganizer])) getProfileWithNetI2pDataHash:peer];
        if (profile != nil) {
          jint ok = [participant getCompleteCount];
          jint fail = [participant getFailedCount];
          [((NetI2pRouterPeermanagerTunnelHistory *) nil_chk([profile getTunnelHistory])) incrementProcessedWithInt:ok withInt:fail];
        }
      }
    }
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"removing our own outbound ", cfg)];
    NetI2pDataTunnelId *outId = [((NetI2pRouterTunnelHopConfig *) nil_chk([cfg getConfigWithInt:0])) getSendTunnel];
    NetI2pRouterTunnelTunnelGateway *gw = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundGateways_)) removeWithId:outId];
    if (gw != nil) {
    }
  }
  jlong msgs = [cfg getProcessedMessagesCount];
  jint failures = [cfg getTunnelFailures];
  jboolean failed = [cfg getTunnelFailed];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.ownedMessageCount" withLong:msgs withLong:failures];
  if (failed) {
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.failedCompletelyMessages" withLong:msgs withLong:failures];
  }
  else if (failures > 0) {
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.failedPartiallyMessages" withLong:msgs withLong:failures];
  }
}

- (void)removeWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  NetI2pDataTunnelId *recvId = [((NetI2pRouterTunnelHopConfig *) nil_chk(cfg)) getReceiveTunnel];
  jboolean removed = (nil != [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) removeWithId:recvId]);
  if (removed) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"removing ", cfg)];
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@", @"Participating tunnel, but no longer listed in participatingConfig? ", cfg)];
  }
  removed = (nil != [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) removeWithId:recvId]);
  if (removed) return;
  removed = (nil != [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) removeWithId:recvId]);
  if (removed) return;
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundEndpoints_)) removeWithId:recvId];
}

- (void)dispatchWithNetI2pDataI2npTunnelDataMessage:(NetI2pDataI2npTunnelDataMessage *)msg
                                 withNetI2pDataHash:(NetI2pDataHash *)recvFrom {
  NetI2pRouterTunnelTunnelParticipant *participant = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) getWithId:[((NetI2pDataI2npTunnelDataMessage *) nil_chk(msg)) getTunnelIdObj]];
  if (participant != nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@$J$$", @"dispatch to participant ", participant, @": ", [msg getUniqueId], @" from ", [((NSString *) nil_chk([((NetI2pDataHash *) nil_chk(recvFrom)) toBase64])) java_substring:0 endIndex:4])];
    [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) tunnelDispatchedWithLong:[msg getUniqueId] withLong:[msg getTunnelId] withNSString:@"participant"];
    [participant dispatchWithNetI2pDataI2npTunnelDataMessage:msg withNetI2pDataHash:recvFrom];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.dispatchParticipant" withLong:1];
  }
  else {
    NetI2pRouterTunnelOutboundTunnelEndpoint *endpoint = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundEndpoints_)) getWithId:[msg getTunnelIdObj]];
    if (endpoint != nil) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@$@$$", @"dispatch where we are the outbound endpoint: ", endpoint, @": ", msg, @" from ", [((NSString *) nil_chk([((NetI2pDataHash *) nil_chk(recvFrom)) toBase64])) java_substring:0 endIndex:4])];
      [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) tunnelDispatchedWithLong:[msg getUniqueId] withLong:[msg getTunnelId] withNSString:@"outbound endpoint"];
      [endpoint dispatchWithNetI2pDataI2npTunnelDataMessage:msg withNetI2pDataHash:recvFrom];
      [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.dispatchEndpoint" withLong:1];
    }
    else {
      [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) messageHistory])) droppedTunnelDataMessageUnknownWithLong:[msg getUniqueId] withLong:[msg getTunnelId]];
      jint level = ([((NetI2pRouterRouter *) nil_chk([_context_ router])) getUptime] > 10 * 60 * 1000 ? NetI2pUtilLog_WARN : NetI2pUtilLog_DEBUG);
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:level]) [_log_ logWithInt:level withNSString:JreStrcat("$J$$$I$I", @"no matching participant/endpoint for id=", [msg getTunnelId], @" expiring in ", NetI2pDataDataHelper_formatDurationWithLong_([msg getMessageExpiration] - [((NetI2pUtilClock *) nil_chk([_context_ clock])) now]), @": existing = ", [_participants_ size], @" / ", [_outboundEndpoints_ size])];
    }
  }
}

- (void)dispatchWithNetI2pDataI2npTunnelGatewayMessage:(NetI2pDataI2npTunnelGatewayMessage *)msg {
  jlong before = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) clock])) now];
  NetI2pRouterTunnelTunnelGateway *gw = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) getWithId:[((NetI2pDataI2npTunnelGatewayMessage *) nil_chk(msg)) getTunnelId]];
  if (gw != nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@$@", @"dispatch where we are the inbound gateway: ", gw, @": ", msg)];
    jlong minTime = before - NetI2pRouterRouter_CLOCK_FUDGE_FACTOR;
    jlong maxTime = before + NetI2pRouterTunnelTunnelDispatcher_MAX_FUTURE_EXPIRATION;
    if (([msg getMessageExpiration] < minTime) || ([((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getMessageExpiration] < minTime) || ([msg getMessageExpiration] > maxTime) || ([((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getMessageExpiration] > maxTime)) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$J$$$$$JCJ$$", @"Not dispatching a gateway message for tunnel ", [((NetI2pDataTunnelId *) nil_chk([msg getTunnelId])) getTunnelId], @" as the wrapper's expiration is in ", NetI2pDataDataHelper_formatDurationWithLong_([msg getMessageExpiration] - before), @" and/or the content's expiration is in ", NetI2pDataDataHelper_formatDurationWithLong_([((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getMessageExpiration] - before), @" with messageId ", [msg getUniqueId], '/', [((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getUniqueId], @" and message type ", [[((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) java_getClass] getSimpleName])];
      return;
    }
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelDispatchedWithLong:[msg getUniqueId] withLong:[((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getUniqueId] withLong:[((NetI2pDataTunnelId *) nil_chk([msg getTunnelId])) getTunnelId] withNSString:@"inbound gateway"];
    [gw addWithNetI2pDataI2npTunnelGatewayMessage:msg];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.dispatchInbound" withLong:1];
  }
  else {
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) droppedTunnelGatewayMessageUnknownWithLong:[msg getUniqueId] withLong:[((NetI2pDataTunnelId *) nil_chk([msg getTunnelId])) getTunnelId]];
    jint level = ([((NetI2pRouterRouter *) nil_chk([_context_ router])) getUptime] > 10 * 60 * 1000 ? NetI2pUtilLog_WARN : NetI2pUtilLog_INFO);
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:level]) [_log_ logWithInt:level withNSString:JreStrcat("$J$$C$$JCJ$$$I", @"no matching tunnel for id=", [((NetI2pDataTunnelId *) nil_chk([msg getTunnelId])) getTunnelId], @": gateway message expiring in ", NetI2pDataDataHelper_formatDurationWithLong_([msg getMessageExpiration] - [((NetI2pUtilClock *) nil_chk([_context_ clock])) now]), '/', NetI2pDataDataHelper_formatDurationWithLong_([((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getMessageExpiration] - [((NetI2pUtilClock *) nil_chk([_context_ clock])) now]), @" messageId ", [msg getUniqueId], '/', [((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) getUniqueId], @" messageType: ", [[((id<NetI2pDataI2npI2NPMessage>) nil_chk([msg getMessage])) java_getClass] getSimpleName], @" existing = ", [_inboundGateways_ size])];
  }
}

- (void)dispatchOutboundWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg
                               withNetI2pDataTunnelId:(NetI2pDataTunnelId *)outboundTunnel
                                   withNetI2pDataHash:(NetI2pDataHash *)targetPeer {
  [self dispatchOutboundWithNetI2pDataI2npI2NPMessage:msg withNetI2pDataTunnelId:outboundTunnel withNetI2pDataTunnelId:nil withNetI2pDataHash:targetPeer];
}

- (void)dispatchOutboundWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg
                               withNetI2pDataTunnelId:(NetI2pDataTunnelId *)outboundTunnel
                               withNetI2pDataTunnelId:(NetI2pDataTunnelId *)targetTunnel
                                   withNetI2pDataHash:(NetI2pDataHash *)targetPeer {
  if (outboundTunnel == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"null outbound tunnel?");
  jlong before = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) clock])) now];
  NetI2pRouterTunnelTunnelGateway *gw = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundGateways_)) getWithId:outboundTunnel];
  if (gw != nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$J$@", @"dispatch outbound through ", [outboundTunnel getTunnelId], @": ", msg)];
    if ([((id<NetI2pDataI2npI2NPMessage>) nil_chk(msg)) getMessageExpiration] < before - NetI2pRouterRouter_CLOCK_FUDGE_FACTOR) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$J$@", @"why are you sending a tunnel message that expired ", (before - [msg getMessageExpiration]), @"ms ago? ", msg) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
      return;
    }
    else if ([msg getMessageExpiration] < before) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$J$@", @"why are you sending a tunnel message that expired ", (before - [msg getMessageExpiration]), @"ms ago? ", msg) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
    }
    else if ([msg getMessageExpiration] > before + NetI2pRouterTunnelTunnelDispatcher_MAX_FUTURE_EXPIRATION) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$J$@", @"why are you sending a tunnel message that expires ", ([msg getMessageExpiration] - before), @"ms from now? ", msg) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
      return;
    }
    jlong tid1 = [outboundTunnel getTunnelId];
    jlong tid2 = (targetTunnel != nil ? [targetTunnel getTunnelId] : -1);
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) tunnelDispatchedWithLong:[msg getUniqueId] withLong:tid1 withLong:tid2 withNetI2pDataHash:targetPeer withNSString:@"outbound gateway"];
    [gw addWithNetI2pDataI2npI2NPMessage:msg withNetI2pDataHash:targetPeer withNetI2pDataTunnelId:targetTunnel];
    if (targetTunnel == nil) [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.dispatchOutboundPeer" withLong:1];
    else [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.dispatchOutboundTunnel" withLong:1];
  }
  else {
    [((NetI2pRouterMessageHistory *) nil_chk([_context_ messageHistory])) droppedTunnelGatewayMessageUnknownWithLong:[((id<NetI2pDataI2npI2NPMessage>) nil_chk(msg)) getUniqueId] withLong:[outboundTunnel getTunnelId]];
    jint level = NetI2pUtilLog_WARN;
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:level]) [_log_ logWithInt:level withNSString:JreStrcat("$@$I", @"no matching outbound tunnel for id=", outboundTunnel, @": existing = ", [_outboundGateways_ size]) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"src")];
  }
}

- (id<JavaUtilList>)listParticipatingTunnels {
  return create_JavaUtilArrayList_initWithJavaUtilCollection_([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) values]);
}

- (void)updateParticipatingStatsWithInt:(jint)ms {
  jlong count = 0;
  jlong bw = 0;
  jlong tcount = 0;
  jlong tooYoung = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) clock])) now] - 60 * 1000;
  jlong tooOld = tooYoung - 9 * 60 * 1000;
  for (NetI2pRouterTunnelHopConfig * __strong cfg in nil_chk([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) values])) {
    jlong c = [((NetI2pRouterTunnelHopConfig *) nil_chk(cfg)) getAndResetRecentMessagesCount];
    bw += c;
    jlong created = [cfg getCreation];
    if (created > tooYoung || created < tooOld) continue;
    tcount++;
    count += c;
  }
  if (tcount > 0) count = count * (10 * 60 * 1000 / ms) / tcount;
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.participatingMessageCountAvgPerTunnel" withLong:count withLong:ms];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.participatingMessageCount" withLong:bw withLong:ms];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.participatingBandwidth" withLong:bw * 1024 / (ms / 1000) withLong:ms];
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.participatingTunnels" withLong:tcount];
}

- (jboolean)shouldDropParticipatingMessageWithNetI2pRouterTunnelTunnelDispatcher_Location:(NetI2pRouterTunnelTunnelDispatcher_Location *)loc
                                                                                  withInt:(jint)type
                                                                                  withInt:(jint)length {
  if (length <= 0) return false;
  jint used = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) bandwidthLimiter])) getCurrentParticipatingBandwidth];
  if (used <= 0) return false;
  jint maxKBps = JavaLangMath_minWithInt_withInt_([((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([_context_ bandwidthLimiter])) getInboundKBytesPerSecond], [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([_context_ bandwidthLimiter])) getOutboundKBytesPerSecond]);
  jfloat share = (jfloat) [((NetI2pRouterRouter *) nil_chk([_context_ router])) getSharePercentage];
  jfloat maxBps = maxKBps * share * (1024.0f * 1.20f);
  jfloat pctDrop = (used - maxBps) / used;
  if (pctDrop <= 0) return false;
  jdouble len = length;
  if (loc == JreLoadEnum(NetI2pRouterTunnelTunnelDispatcher_Location, OBEP)) {
    if (type == NetI2pDataI2npVariableTunnelBuildMessage_MESSAGE_TYPE || type == NetI2pDataI2npTunnelBuildMessage_MESSAGE_TYPE) JreDivideAssignDoubleD(&len, 1.5);
    else JreTimesAssignDoubleD(&len, 1.5);
  }
  else if (loc == JreLoadEnum(NetI2pRouterTunnelTunnelDispatcher_Location, IBGW)) {
    if (type == NetI2pDataI2npVariableTunnelBuildReplyMessage_MESSAGE_TYPE || type == NetI2pDataI2npTunnelBuildReplyMessage_MESSAGE_TYPE) JreDivideAssignDoubleD(&len, 1.5 * 1.5 * 1.5);
    else JreDivideAssignDoubleD(&len, 1.5);
  }
  if (JreFpToInt(len) != 1024) pctDrop = (jfloat) JavaLangMath_powWithDouble_withDouble_(pctDrop, 1024.0 / len);
  jfloat rand = [((NetI2pUtilRandomSource *) nil_chk([_context_ random])) nextFloat];
  jboolean reject = rand <= pctDrop;
  if (reject) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) {
      jint availBps = JreFpToInt((((maxKBps * 1024) * share) - used));
      [_log_ warnWithNSString:JreStrcat("$ICICI$FC@CICI", @"Drop part. msg. avail/max/used ", availBps, '/', JreFpToInt(maxBps), '/', used, @" %Drop = ", pctDrop, ' ', loc, ' ', type, ' ', length)];
    }
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.participatingMessageDropped" withLong:1];
  }
  return reject;
}

- (void)startup {
  @synchronized(self) {
    JreStrongAssignAndConsume(&_validator_, new_NetI2pRouterTunnelBloomFilterIVValidator_initWithNetI2pRouterRouterContext_withInt_(_context_, NetI2pRouterTunnelTunnelDispatcher_getShareBandwidthWithNetI2pRouterRouterContext_(_context_)));
  }
}

+ (jint)getShareBandwidthWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx {
  return NetI2pRouterTunnelTunnelDispatcher_getShareBandwidthWithNetI2pRouterRouterContext_(ctx);
}

- (void)shutdown {
  @synchronized(self) {
    if (_validator_ != nil) [_validator_ destroy];
    JreStrongAssign(&_validator_, nil);
    [((NetI2pRouterTunnelTunnelGatewayPumper *) nil_chk(_pumper_)) stopPumping];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundGateways_)) clear];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_outboundEndpoints_)) clear];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participants_)) clear];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_inboundGateways_)) clear];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(_participatingConfig_)) clear];
    [((NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *) nil_chk(_leaveJob_)) clear];
  }
}

- (void)restart {
  [self shutdown];
  [self startup];
}

- (void)renderStatusHTMLWithJavaIoWriter:(JavaIoWriter *)outArg {
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_log_);
  RELEASE_(_outboundGateways_);
  RELEASE_(_outboundEndpoints_);
  RELEASE_(_participants_);
  RELEASE_(_inboundGateways_);
  RELEASE_(_participatingConfig_);
  RELEASE_(_validator_);
  RELEASE_(_leaveJob_);
  RELEASE_(_pumper_);
  RELEASE_(_joinParticipantLock_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelTunnelGateway_QueuePreprocessor;", 0x2, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelTunnelGateway_QueuePreprocessor;", 0x2, 1, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 5, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 8, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 15, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, -1, -1, -1, 16, -1, -1 },
    { NULL, "V", 0x1, 17, 18, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, 21, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 23, 24, -1, 25, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:);
  methods[1].selector = @selector(createPreprocessorWithNetI2pRouterTunnelHopConfig:);
  methods[2].selector = @selector(createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig:);
  methods[3].selector = @selector(joinOutboundWithNetI2pRouterTunnelTunnelCreatorConfig:);
  methods[4].selector = @selector(joinInboundWithNetI2pRouterTunnelTunnelCreatorConfig:);
  methods[5].selector = @selector(joinParticipantWithNetI2pRouterTunnelHopConfig:);
  methods[6].selector = @selector(joinOutboundEndpointWithNetI2pRouterTunnelHopConfig:);
  methods[7].selector = @selector(joinInboundGatewayWithNetI2pRouterTunnelHopConfig:);
  methods[8].selector = @selector(getParticipatingCount);
  methods[9].selector = @selector(getNewOBGWID);
  methods[10].selector = @selector(getNewIBEPID);
  methods[11].selector = @selector(getNewIBZeroHopID);
  methods[12].selector = @selector(getLastParticipatingExpiration);
  methods[13].selector = @selector(removeWithNetI2pRouterTunnelTunnelCreatorConfig:);
  methods[14].selector = @selector(removeWithNetI2pRouterTunnelHopConfig:);
  methods[15].selector = @selector(dispatchWithNetI2pDataI2npTunnelDataMessage:withNetI2pDataHash:);
  methods[16].selector = @selector(dispatchWithNetI2pDataI2npTunnelGatewayMessage:);
  methods[17].selector = @selector(dispatchOutboundWithNetI2pDataI2npI2NPMessage:withNetI2pDataTunnelId:withNetI2pDataHash:);
  methods[18].selector = @selector(dispatchOutboundWithNetI2pDataI2npI2NPMessage:withNetI2pDataTunnelId:withNetI2pDataTunnelId:withNetI2pDataHash:);
  methods[19].selector = @selector(listParticipatingTunnels);
  methods[20].selector = @selector(updateParticipatingStatsWithInt:);
  methods[21].selector = @selector(shouldDropParticipatingMessageWithNetI2pRouterTunnelTunnelDispatcher_Location:withInt:withInt:);
  methods[22].selector = @selector(startup);
  methods[23].selector = @selector(getShareBandwidthWithNetI2pRouterRouterContext:);
  methods[24].selector = @selector(shutdown);
  methods[25].selector = @selector(restart);
  methods[26].selector = @selector(renderStatusHTMLWithJavaIoWriter:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_context_", "LNetI2pRouterRouterContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_outboundGateways_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 26, -1 },
    { "_outboundEndpoints_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 27, -1 },
    { "_participants_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 28, -1 },
    { "_inboundGateways_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 26, -1 },
    { "_participatingConfig_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 29, -1 },
    { "_lastParticipatingExpiration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_validator_", "LNetI2pRouterTunnelBloomFilterIVValidator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_leaveJob_", "LNetI2pRouterTunnelTunnelDispatcher_LeaveTunnel;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_pumper_", "LNetI2pRouterTunnelTunnelGatewayPumper;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_joinParticipantLock_", "LNSObject;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "RATES", "[J", .constantValue.asLong = 0, 0x1a, -1, 30, -1, -1 },
    { "MAX_FUTURE_EXPIRATION", "J", .constantValue.asLong = NetI2pRouterTunnelTunnelDispatcher_MAX_FUTURE_EXPIRATION, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;", "createPreprocessor", "LNetI2pRouterTunnelHopConfig;", "LNetI2pRouterTunnelTunnelCreatorConfig;", "joinOutbound", "joinInbound", "joinParticipant", "joinOutboundEndpoint", "joinInboundGateway", "remove", "dispatch", "LNetI2pDataI2npTunnelDataMessage;LNetI2pDataHash;", "LNetI2pDataI2npTunnelGatewayMessage;", "dispatchOutbound", "LNetI2pDataI2npI2NPMessage;LNetI2pDataTunnelId;LNetI2pDataHash;", "LNetI2pDataI2npI2NPMessage;LNetI2pDataTunnelId;LNetI2pDataTunnelId;LNetI2pDataHash;", "()Ljava/util/List<Lnet/i2p/router/tunnel/HopConfig;>;", "updateParticipatingStats", "I", "shouldDropParticipatingMessage", "LNetI2pRouterTunnelTunnelDispatcher_Location;II", "getShareBandwidth", "renderStatusHTML", "LJavaIoWriter;", "LJavaIoIOException;", (void *)&NetI2pRouterTunnelTunnelDispatcher__Annotations$0, "Ljava/util/concurrent/ConcurrentHashMap<Lnet/i2p/data/TunnelId;Lnet/i2p/router/tunnel/TunnelGateway;>;", "Ljava/util/concurrent/ConcurrentHashMap<Lnet/i2p/data/TunnelId;Lnet/i2p/router/tunnel/OutboundTunnelEndpoint;>;", "Ljava/util/concurrent/ConcurrentHashMap<Lnet/i2p/data/TunnelId;Lnet/i2p/router/tunnel/TunnelParticipant;>;", "Ljava/util/concurrent/ConcurrentHashMap<Lnet/i2p/data/TunnelId;Lnet/i2p/router/tunnel/HopConfig;>;", &NetI2pRouterTunnelTunnelDispatcher_RATES, "LNetI2pRouterTunnelTunnelDispatcher_Location;LNetI2pRouterTunnelTunnelDispatcher_LeaveTunnel;" };
  static const J2ObjcClassInfo _NetI2pRouterTunnelTunnelDispatcher = { "TunnelDispatcher", "net.i2p.router.tunnel", ptrTable, methods, fields, 7, 0x1, 27, 14, -1, 31, -1, -1, -1 };
  return &_NetI2pRouterTunnelTunnelDispatcher;
}

+ (void)initialize {
  if (self == [NetI2pRouterTunnelTunnelDispatcher class]) {
    JreStrongAssignAndConsume(&NetI2pRouterTunnelTunnelDispatcher_RATES, [IOSLongArray newArrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l, 3 * 60 * 60 * 1000l, 24 * 60 * 60 * 1000 } count:4]);
    J2OBJC_SET_INITIALIZED(NetI2pRouterTunnelTunnelDispatcher)
  }
}

@end

void NetI2pRouterTunnelTunnelDispatcher_initWithNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher *self, NetI2pRouterRouterContext *ctx) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_joinParticipantLock_, new_NSObject_init());
  JreStrongAssign(&self->_context_, ctx);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) logManager])) getLogWithIOSClass:NetI2pRouterTunnelTunnelDispatcher_class_()]);
  JreStrongAssignAndConsume(&self->_outboundGateways_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->_outboundEndpoints_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->_participants_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->_inboundGateways_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->_participatingConfig_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->_pumper_, new_NetI2pRouterTunnelTunnelGatewayPumper_initWithNetI2pRouterRouterContext_(ctx));
  JreStrongAssignAndConsume(&self->_leaveJob_, new_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(self, ctx));
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.participatingTunnels" withNSString:@"Tunnels routed for others" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000l, 60 * 60 * 1000l, 3 * 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:5]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dispatchOutboundPeer" withNSString:@"How many messages we send out a tunnel targetting a peer?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dispatchOutboundTunnel" withNSString:@"How many messages we send out a tunnel targetting a tunnel?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dispatchInbound" withNSString:@"How many messages we send through our tunnel gateway?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dispatchParticipant" withNSString:@"How many messages we send through a tunnel we are participating in?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dispatchEndpoint" withNSString:@"How many messages we receive as the outbound endpoint of a tunnel?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinOutboundGateway" withNSString:@"How many tunnels we join as the outbound gateway?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinOutboundGatewayZeroHop" withNSString:@"How many zero hop tunnels we join as the outbound gateway?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinInboundEndpoint" withNSString:@"How many tunnels we join as the inbound endpoint?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinInboundEndpointZeroHop" withNSString:@"How many zero hop tunnels we join as the inbound endpoint?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinParticipant" withNSString:@"How many tunnels we join as a participant?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinOutboundEndpoint" withNSString:@"How many tunnels we join as the outbound endpoint?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.joinInboundGateway" withNSString:@"How many tunnels we join as the inbound gateway?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.participatingBandwidth" withNSString:@"Participating traffic received (Bytes/sec)" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 10 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.participatingBandwidthOut" withNSString:@"Participating traffic sent (Bytes/sec)" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 10 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.participatingMessageDropped" withNSString:@"Dropped for exceeding share limit" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 10 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.participatingMessageCount" withNSString:@"Number of 1KB participating messages" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 10 * 1000l, 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.participatingMessageCountAvgPerTunnel" withNSString:@"Estimate of participating messages per tunnel lifetime" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.ownedMessageCount" withNSString:@"How many messages are sent through a tunnel we created (period == failures)?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 10 * 60 * 1000l, 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.failedCompletelyMessages" withNSString:@"How many messages are sent through a tunnel that failed prematurely (period == failures)?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 10 * 60 * 1000l, 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.failedPartially" withNSString:@"How many messages are sent through a tunnel that only failed partially (period == failures)?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 10 * 60 * 1000l, 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchMultipleCount" withNSString:@"How many messages are batched into a tunnel message" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchDelay" withNSString:@"How many messages were pending when the batching waited" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchDelaySent" withNSString:@"How many messages were flushed when the batching delay completed" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchCount" withNSString:@"How many groups of messages were flushed together" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchDelayAmount" withNSString:@"How long we should wait before flushing the batch" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchFlushRemaining" withNSString:@"How many messages remain after flushing" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.writeDelay" withNSString:@"How long after a message reaches the gateway is it processed (lifetime is size)" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchSmallFragments" withNSString:@"How many outgoing pad bytes are in small fragments?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchFullFragments" withNSString:@"How many outgoing tunnel messages use the full data area?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000l, 60 * 60 * 1000l } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.batchFragmentation" withNSString:@"Avg. number of fragments per msg" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000 } count:2]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.distributeLookupSuccess" withNSString:@"Was a deferred lookup successful?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dropAtOBEP" withNSString:@"New conn throttle" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.outboundLookupSuccess" withNSString:@"Was a deferred lookup successful?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.inboundLookupSuccess" withNSString:@"Was a deferred lookup successful?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.participantLookupSuccess" withNSString:@"Was a deferred lookup successful?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.buildRequestDup" withNSString:@"How frequently we get dup build request messages" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.buildRequestBadReplyKey" withNSString:@"Build requests with bad reply keys" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.smallFragments" withNSString:@"How many pad bytes are in small fragments?" withNSString:@"Tunnels" withLongArray:NetI2pRouterTunnelTunnelDispatcher_RATES];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.fullFragments" withNSString:@"How many tunnel messages use the full data area?" withNSString:@"Tunnels" withLongArray:NetI2pRouterTunnelTunnelDispatcher_RATES];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.fragmentedComplete" withNSString:@"How many fragments were in a completely received message?" withNSString:@"Tunnels" withLongArray:NetI2pRouterTunnelTunnelDispatcher_RATES];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.fragmentedDropped" withNSString:@"Number of dropped fragments" withNSString:@"Tunnels" withLongArray:NetI2pRouterTunnelTunnelDispatcher_RATES];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"tunnel.corruptMessage" withNSString:@"Corrupt messages received" withNSString:@"Tunnels" withLongArray:NetI2pRouterTunnelTunnelDispatcher_RATES];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dropDangerousClientTunnelMessage" withNSString:@"(lifetime is the I2NP type)" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dropDangerousExplTunnelMessage" withNSString:@"(lifetime is the I2NP type)" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.handleLoadClove" withNSString:@"When do we receive load test cloves" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"tunnel.dropGatewayOverflow" withNSString:@"Dropped message at GW, queue full" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 60 * 1000 } count:1]];
}

NetI2pRouterTunnelTunnelDispatcher *new_NetI2pRouterTunnelTunnelDispatcher_initWithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *ctx) {
  J2OBJC_NEW_IMPL(NetI2pRouterTunnelTunnelDispatcher, initWithNetI2pRouterRouterContext_, ctx)
}

NetI2pRouterTunnelTunnelDispatcher *create_NetI2pRouterTunnelTunnelDispatcher_initWithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *ctx) {
  J2OBJC_CREATE_IMPL(NetI2pRouterTunnelTunnelDispatcher, initWithNetI2pRouterRouterContext_, ctx)
}

id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelHopConfig_(NetI2pRouterTunnelTunnelDispatcher *self, NetI2pRouterTunnelHopConfig *cfg) {
  return create_NetI2pRouterTunnelBatchedRouterPreprocessor_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelHopConfig_(self->_context_, cfg);
}

id<NetI2pRouterTunnelTunnelGateway_QueuePreprocessor> NetI2pRouterTunnelTunnelDispatcher_createPreprocessorWithNetI2pRouterTunnelTunnelCreatorConfig_(NetI2pRouterTunnelTunnelDispatcher *self, NetI2pRouterTunnelTunnelCreatorConfig *cfg) {
  return create_NetI2pRouterTunnelBatchedRouterPreprocessor_initWithNetI2pRouterRouterContext_withNetI2pRouterTunnelTunnelCreatorConfig_(self->_context_, cfg);
}

jint NetI2pRouterTunnelTunnelDispatcher_getShareBandwidthWithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *ctx) {
  NetI2pRouterTunnelTunnelDispatcher_initialize();
  jint irateKBps = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) bandwidthLimiter])) getInboundKBytesPerSecond];
  jint orateKBps = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([ctx bandwidthLimiter])) getOutboundKBytesPerSecond];
  jdouble pct = [((NetI2pRouterRouter *) nil_chk([ctx router])) getSharePercentage];
  return JreFpToInt((pct * JavaLangMath_minWithInt_withInt_(irateKBps, orateKBps)));
}

IOSObjectArray *NetI2pRouterTunnelTunnelDispatcher__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTunnelTunnelDispatcher)

J2OBJC_INITIALIZED_DEFN(NetI2pRouterTunnelTunnelDispatcher_Location)

NetI2pRouterTunnelTunnelDispatcher_Location *NetI2pRouterTunnelTunnelDispatcher_Location_values_[3];

@implementation NetI2pRouterTunnelTunnelDispatcher_Location

+ (NetI2pRouterTunnelTunnelDispatcher_Location *)OBEP {
  return JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, OBEP);
}

+ (NetI2pRouterTunnelTunnelDispatcher_Location *)PARTICIPANT {
  return JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, PARTICIPANT);
}

+ (NetI2pRouterTunnelTunnelDispatcher_Location *)IBGW {
  return JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, IBGW);
}

+ (IOSObjectArray *)values {
  return NetI2pRouterTunnelTunnelDispatcher_Location_values();
}

+ (NetI2pRouterTunnelTunnelDispatcher_Location *)valueOfWithNSString:(NSString *)name {
  return NetI2pRouterTunnelTunnelDispatcher_Location_valueOfWithNSString_(name);
}

- (NetI2pRouterTunnelTunnelDispatcher_Location_Enum)toNSEnum {
  return (NetI2pRouterTunnelTunnelDispatcher_Location_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LNetI2pRouterTunnelTunnelDispatcher_Location;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelTunnelDispatcher_Location;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "OBEP", "LNetI2pRouterTunnelTunnelDispatcher_Location;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "PARTICIPANT", "LNetI2pRouterTunnelTunnelDispatcher_Location;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "IBGW", "LNetI2pRouterTunnelTunnelDispatcher_Location;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, OBEP), &JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, PARTICIPANT), &JreEnum(NetI2pRouterTunnelTunnelDispatcher_Location, IBGW), "LNetI2pRouterTunnelTunnelDispatcher;", "Ljava/lang/Enum<Lnet/i2p/router/tunnel/TunnelDispatcher$Location;>;" };
  static const J2ObjcClassInfo _NetI2pRouterTunnelTunnelDispatcher_Location = { "Location", "net.i2p.router.tunnel", ptrTable, methods, fields, 7, 0x4018, 2, 3, 5, -1, -1, 6, -1 };
  return &_NetI2pRouterTunnelTunnelDispatcher_Location;
}

+ (void)initialize {
  if (self == [NetI2pRouterTunnelTunnelDispatcher_Location class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 3 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    for (jint i = 0; i < 3; i++) {
      ((void)(NetI2pRouterTunnelTunnelDispatcher_Location_values_[i] = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
      NetI2pRouterTunnelTunnelDispatcher_Location_initWithNSString_withInt_(e, JreEnumConstantName(NetI2pRouterTunnelTunnelDispatcher_Location_class_(), i), i);
    }
    J2OBJC_SET_INITIALIZED(NetI2pRouterTunnelTunnelDispatcher_Location)
  }
}

@end

void NetI2pRouterTunnelTunnelDispatcher_Location_initWithNSString_withInt_(NetI2pRouterTunnelTunnelDispatcher_Location *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *NetI2pRouterTunnelTunnelDispatcher_Location_values() {
  NetI2pRouterTunnelTunnelDispatcher_Location_initialize();
  return [IOSObjectArray arrayWithObjects:NetI2pRouterTunnelTunnelDispatcher_Location_values_ count:3 type:NetI2pRouterTunnelTunnelDispatcher_Location_class_()];
}

NetI2pRouterTunnelTunnelDispatcher_Location *NetI2pRouterTunnelTunnelDispatcher_Location_valueOfWithNSString_(NSString *name) {
  NetI2pRouterTunnelTunnelDispatcher_Location_initialize();
  for (int i = 0; i < 3; i++) {
    NetI2pRouterTunnelTunnelDispatcher_Location *e = NetI2pRouterTunnelTunnelDispatcher_Location_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

NetI2pRouterTunnelTunnelDispatcher_Location *NetI2pRouterTunnelTunnelDispatcher_Location_fromOrdinal(NSUInteger ordinal) {
  NetI2pRouterTunnelTunnelDispatcher_Location_initialize();
  if (ordinal >= 3) {
    return nil;
  }
  return NetI2pRouterTunnelTunnelDispatcher_Location_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTunnelTunnelDispatcher_Location)

@implementation NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel

- (instancetype)initWithNetI2pRouterTunnelTunnelDispatcher:(NetI2pRouterTunnelTunnelDispatcher *)outer$
                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx {
  NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(self, outer$, ctx);
  return self;
}

- (void)addWithNetI2pRouterTunnelHopConfig:(NetI2pRouterTunnelHopConfig *)cfg {
  [((JavaUtilConcurrentLinkedBlockingQueue *) nil_chk(_configs_)) offerWithId:cfg];
}

- (void)clear {
  [((JavaUtilConcurrentLinkedBlockingQueue *) nil_chk(_configs_)) clear];
}

- (NSString *)getName {
  return @"Expire participating tunnels";
}

- (void)runJob {
  NetI2pRouterTunnelHopConfig *cur = nil;
  jlong now = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] + NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_LEAVE_BATCH_TIME;
  jlong nextTime = now + 10 * 60 * 1000;
  while ((cur = [((JavaUtilConcurrentLinkedBlockingQueue *) nil_chk(_configs_)) peek]) != nil) {
    jlong exp = [((NetI2pRouterTunnelHopConfig *) nil_chk(cur)) getExpiration] + (2 * NetI2pRouterRouter_CLOCK_FUDGE_FACTOR) + NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_LEAVE_BATCH_TIME;
    if (exp < now) {
      [_configs_ poll];
      if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [this$0_->_log_ infoWithNSString:JreStrcat("$@", @"Expiring ", cur)];
      [this$0_ removeWithNetI2pRouterTunnelHopConfig:cur];
    }
    else {
      if (exp < nextTime) nextTime = exp;
      break;
    }
  }
  [((NetI2pRouterJobTiming *) nil_chk([self getTiming])) setStartAfterWithLong:nextTime];
  [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) jobQueue])) addJobWithNetI2pRouterJob:self];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(_configs_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterTunnelTunnelDispatcher:withNetI2pRouterRouterContext:);
  methods[1].selector = @selector(addWithNetI2pRouterTunnelHopConfig:);
  methods[2].selector = @selector(clear);
  methods[3].selector = @selector(getName);
  methods[4].selector = @selector(runJob);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterTunnelTunnelDispatcher;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "_configs_", "LJavaUtilConcurrentLinkedBlockingQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 3, -1 },
    { "LEAVE_BATCH_TIME", "I", .constantValue.asInt = NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_LEAVE_BATCH_TIME, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;", "add", "LNetI2pRouterTunnelHopConfig;", "Ljava/util/concurrent/LinkedBlockingQueue<Lnet/i2p/router/tunnel/HopConfig;>;", "LNetI2pRouterTunnelTunnelDispatcher;" };
  static const J2ObjcClassInfo _NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel = { "LeaveTunnel", "net.i2p.router.tunnel", ptrTable, methods, fields, 7, 0x2, 5, 3, 4, -1, -1, -1, -1 };
  return &_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel;
}

@end

void NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *self, NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, ctx);
  JreStrongAssignAndConsume(&self->_configs_, new_JavaUtilConcurrentLinkedBlockingQueue_init());
  [((NetI2pRouterJobTiming *) nil_chk([self getTiming])) setStartAfterWithLong:[((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) clock])) now] + 20 * 60 * 1000];
  [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) jobQueue])) addJobWithNetI2pRouterJob:self];
}

NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *new_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx) {
  J2OBJC_NEW_IMPL(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel, initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_, outer$, ctx)
}

NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel *create_NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel_initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_(NetI2pRouterTunnelTunnelDispatcher *outer$, NetI2pRouterRouterContext *ctx) {
  J2OBJC_CREATE_IMPL(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel, initWithNetI2pRouterTunnelTunnelDispatcher_withNetI2pRouterRouterContext_, outer$, ctx)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTunnelTunnelDispatcher_LeaveTunnel)
