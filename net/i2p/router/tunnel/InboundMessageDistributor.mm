//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/tunnel/InboundMessageDistributor.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Exception.h"
#include "net/i2p/data/DatabaseEntry.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/Payload.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/data/i2np/DataMessage.h"
#include "net/i2p/data/i2np/DatabaseSearchReplyMessage.h"
#include "net/i2p/data/i2np/DatabaseStoreMessage.h"
#include "net/i2p/data/i2np/DeliveryInstructions.h"
#include "net/i2p/data/i2np/DeliveryStatusMessage.h"
#include "net/i2p/data/i2np/GarlicMessage.h"
#include "net/i2p/data/i2np/I2NPMessage.h"
#include "net/i2p/data/i2np/TunnelBuildReplyMessage.h"
#include "net/i2p/data/i2np/VariableTunnelBuildReplyMessage.h"
#include "net/i2p/data/router/RouterIdentity.h"
#include "net/i2p/data/router/RouterInfo.h"
#include "net/i2p/router/ClientManagerFacade.h"
#include "net/i2p/router/ClientMessage.h"
#include "net/i2p/router/InNetMessagePool.h"
#include "net/i2p/router/NetworkDatabaseFacade.h"
#include "net/i2p/router/PeerManagerFacade.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/TunnelInfo.h"
#include "net/i2p/router/TunnelManagerFacade.h"
#include "net/i2p/router/TunnelPoolSettings.h"
#include "net/i2p/router/message/GarlicMessageReceiver.h"
#include "net/i2p/router/networkdb/kademlia/FloodfillNetworkDatabaseFacade.h"
#include "net/i2p/router/tunnel/InboundMessageDistributor.h"
#include "net/i2p/router/tunnel/TunnelDispatcher.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"

@interface NetI2pRouterTunnelInboundMessageDistributor () {
 @public
  NetI2pRouterRouterContext *_context_;
  NetI2pUtilLog *_log_;
  NetI2pDataHash *_client_;
  NetI2pRouterMessageGarlicMessageReceiver *_receiver_;
}

@end

J2OBJC_FIELD_SETTER(NetI2pRouterTunnelInboundMessageDistributor, _context_, NetI2pRouterRouterContext *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelInboundMessageDistributor, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelInboundMessageDistributor, _client_, NetI2pDataHash *)
J2OBJC_FIELD_SETTER(NetI2pRouterTunnelInboundMessageDistributor, _receiver_, NetI2pRouterMessageGarlicMessageReceiver *)

@implementation NetI2pRouterTunnelInboundMessageDistributor

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                               withNetI2pDataHash:(NetI2pDataHash *)client {
  NetI2pRouterTunnelInboundMessageDistributor_initWithNetI2pRouterRouterContext_withNetI2pDataHash_(self, ctx, client);
  return self;
}

- (void)distributeWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg
                             withNetI2pDataHash:(NetI2pDataHash *)target {
  [self distributeWithNetI2pDataI2npI2NPMessage:msg withNetI2pDataHash:target withNetI2pDataTunnelId:nil];
}

- (void)distributeWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg
                             withNetI2pDataHash:(NetI2pDataHash *)target
                         withNetI2pDataTunnelId:(NetI2pDataTunnelId *)tunnel {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@$@$@$@", @"IBMD for ", _client_, @" to ", target, @" / ", tunnel, @" : ", msg)];
  jint type = [((id<NetI2pDataI2npI2NPMessage>) nil_chk(msg)) getType];
  if (_client_ != nil) {
    {
      NetI2pDataI2npDatabaseStoreMessage *dsm;
      switch (type) {
        case NetI2pDataI2npDatabaseSearchReplyMessage_MESSAGE_TYPE:
        break;
        case NetI2pDataI2npDatabaseStoreMessage_MESSAGE_TYPE:
        dsm = (NetI2pDataI2npDatabaseStoreMessage *) cast_chk(msg, [NetI2pDataI2npDatabaseStoreMessage class]);
        if ([((NetI2pDataDatabaseEntry *) nil_chk([dsm getEntry])) getType] == NetI2pDataDatabaseEntry_KEY_TYPE_ROUTERINFO) {
          if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@$@", @"Dropping DSM down a tunnel for ", _client_, @": ", msg)];
          NetI2pDataHash *key = [dsm getKey];
          if ([((NetI2pDataHash *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) routerHash])) isEqual:key]) return;
          NetI2pDataRouterRouterInfo *ri = (NetI2pDataRouterRouterInfo *) cast_chk([dsm getEntry], [NetI2pDataRouterRouterInfo class]);
          if (![((NetI2pDataHash *) nil_chk(key)) isEqual:[((NetI2pDataRouterRouterIdentity *) nil_chk([((NetI2pDataRouterRouterInfo *) nil_chk(ri)) getIdentity])) getHash]]) return;
          if (![ri isValid]) return;
          NetI2pDataRouterRouterInfo *oldri = [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([_context_ netDb])) lookupRouterInfoLocallyWithNetI2pDataHash:key];
          if (oldri != nil && [oldri getPublished] < [ri getPublished] && !NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_isFloodfillWithNetI2pDataRouterRouterInfo_(ri)) {
            if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@$$$$C", @"Updating caps for RI ", key, @" from \"", [oldri getCapabilities], @"\" to \"", [ri getCapabilities], '"')];
            [((id<NetI2pRouterPeerManagerFacade>) nil_chk([_context_ peerManager])) setCapabilitiesWithNetI2pDataHash:key withNSString:[ri getCapabilities]];
          }
          return;
        }
        else if ([dsm getReplyToken] != 0) {
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousClientTunnelMessage" withLong:1 withLong:type];
          [_log_ errorWithNSString:JreStrcat("$@$@", @"Dropping LS DSM w/ reply token down a tunnel for ", _client_, @": ", msg)];
          return;
        }
        else {
          [((NetI2pDataLeaseSet *) nil_chk(((NetI2pDataLeaseSet *) cast_chk([dsm getEntry], [NetI2pDataLeaseSet class])))) setReceivedAsReply];
        }
        break;
        case NetI2pDataI2npDeliveryStatusMessage_MESSAGE_TYPE:
        case NetI2pDataI2npGarlicMessage_MESSAGE_TYPE:
        case NetI2pDataI2npTunnelBuildReplyMessage_MESSAGE_TYPE:
        case NetI2pDataI2npVariableTunnelBuildReplyMessage_MESSAGE_TYPE:
        break;
        default:
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousClientTunnelMessage" withLong:1 withLong:type];
        [_log_ errorWithNSString:JreStrcat("$@$@", @"Dropped dangerous message down a tunnel for ", _client_, @": ", msg) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
        return;
      }
    }
  }
  else {
    {
      NetI2pDataI2npDatabaseStoreMessage *dsm;
      switch (type) {
        case NetI2pDataI2npDatabaseStoreMessage_MESSAGE_TYPE:
        dsm = (NetI2pDataI2npDatabaseStoreMessage *) cast_chk(msg, [NetI2pDataI2npDatabaseStoreMessage class]);
        if ([dsm getReplyToken] != 0) {
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousExplTunnelMessage" withLong:1 withLong:type];
          [_log_ errorWithNSString:JreStrcat("$@", @"Dropping DSM w/ reply token down a expl. tunnel: ", msg)];
          return;
        }
        if ([((NetI2pDataDatabaseEntry *) nil_chk([dsm getEntry])) getType] == NetI2pDataDatabaseEntry_KEY_TYPE_LEASESET) [((NetI2pDataLeaseSet *) nil_chk(((NetI2pDataLeaseSet *) cast_chk([dsm getEntry], [NetI2pDataLeaseSet class])))) setReceivedAsReply];
        break;
        case NetI2pDataI2npDatabaseSearchReplyMessage_MESSAGE_TYPE:
        case NetI2pDataI2npDeliveryStatusMessage_MESSAGE_TYPE:
        case NetI2pDataI2npGarlicMessage_MESSAGE_TYPE:
        case NetI2pDataI2npTunnelBuildReplyMessage_MESSAGE_TYPE:
        case NetI2pDataI2npVariableTunnelBuildReplyMessage_MESSAGE_TYPE:
        break;
        default:
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousExplTunnelMessage" withLong:1 withLong:type];
        [_log_ errorWithNSString:JreStrcat("$@", @"Dropped dangerous message down expl tunnel: ", msg) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
        return;
      }
    }
  }
  if ((target == nil) || ((tunnel == nil) && ([((NetI2pDataHash *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) routerHash])) isEqual:target]))) {
    if (type == NetI2pDataI2npGarlicMessage_MESSAGE_TYPE) {
      [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) handleRepliesWithNetI2pDataI2npI2NPMessage:msg];
      [((NetI2pRouterMessageGarlicMessageReceiver *) nil_chk(_receiver_)) receiveWithNetI2pDataI2npGarlicMessage:(NetI2pDataI2npGarlicMessage *) cast_chk(msg, [NetI2pDataI2npGarlicMessage class])];
    }
    else {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"distributing inbound tunnel message into our inNetMessagePool: ", msg)];
      [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) addWithNetI2pDataI2npI2NPMessage:msg withNetI2pDataRouterRouterIdentity:nil withNetI2pDataHash:nil];
    }
  }
  else {
    id<NetI2pRouterTunnelInfo> out = [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) tunnelManager])) selectOutboundTunnelWithNetI2pDataHash:_client_ withNetI2pDataHash:target];
    if (out == nil) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@$@", @"no outbound tunnel to send the client message for ", _client_, @": ", msg)];
      return;
    }
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$I$@$@", @"distributing IB tunnel msg type ", type, @" back out ", out, @" targetting ", target)];
    NetI2pDataTunnelId *outId = [out getSendTunnelIdWithInt:0];
    if (outId == nil) {
      if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$@$@", @"strange? outbound tunnel has no outboundId? ", out, @" failing to distribute ", msg)];
      return;
    }
    jlong exp = [((NetI2pUtilClock *) nil_chk([_context_ clock])) now] + 20 * 1000;
    if ([msg getMessageExpiration] < exp) [msg setMessageExpirationWithLong:exp];
    [((NetI2pRouterTunnelTunnelDispatcher *) nil_chk([_context_ tunnelDispatcher])) dispatchOutboundWithNetI2pDataI2npI2NPMessage:msg withNetI2pDataTunnelId:outId withNetI2pDataTunnelId:tunnel withNetI2pDataHash:target];
  }
}

- (void)handleCloveWithNetI2pDataI2npDeliveryInstructions:(NetI2pDataI2npDeliveryInstructions *)instructions
                            withNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)data {
  jint type = [((id<NetI2pDataI2npI2NPMessage>) nil_chk(data)) getType];
  {
    NetI2pDataHash *to;
    switch ([((NetI2pDataI2npDeliveryInstructions *) nil_chk(instructions)) getDeliveryMode]) {
      case NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_LOCAL:
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$$", @"local delivery instructions for clove: ", [[data java_getClass] getSimpleName])];
      if (type == NetI2pDataI2npGarlicMessage_MESSAGE_TYPE) {
        [((NetI2pRouterMessageGarlicMessageReceiver *) nil_chk(_receiver_)) receiveWithNetI2pDataI2npGarlicMessage:(NetI2pDataI2npGarlicMessage *) cast_chk(data, [NetI2pDataI2npGarlicMessage class])];
      }
      else if (type == NetI2pDataI2npDatabaseStoreMessage_MESSAGE_TYPE) {
        NetI2pDataI2npDatabaseStoreMessage *dsm = (NetI2pDataI2npDatabaseStoreMessage *) cast_chk(data, [NetI2pDataI2npDatabaseStoreMessage class]);
        [dsm setReplyTokenWithLong:0];
        [dsm setReplyTunnelWithNetI2pDataTunnelId:nil];
        [dsm setReplyGatewayWithNetI2pDataHash:nil];
        if ([((NetI2pDataDatabaseEntry *) nil_chk([dsm getEntry])) getType] == NetI2pDataDatabaseEntry_KEY_TYPE_LEASESET) {
          [((NetI2pDataLeaseSet *) nil_chk(((NetI2pDataLeaseSet *) cast_chk([dsm getEntry], [NetI2pDataLeaseSet class])))) setReceivedAsReply];
          if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@$@", @"Storing garlic LS down tunnel for: ", [dsm getKey], @" sent to: ", _client_)];
          [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) addWithNetI2pDataI2npI2NPMessage:dsm withNetI2pDataRouterRouterIdentity:nil withNetI2pDataHash:nil];
        }
        else {
          if (_client_ != nil) {
            [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousClientTunnelMessage" withLong:1 withLong:NetI2pDataI2npDatabaseStoreMessage_MESSAGE_TYPE];
            [_log_ errorWithNSString:JreStrcat("$@$@", @"Dropped dangerous message down a tunnel for ", _client_, @": ", dsm) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
            return;
          }
          if ([_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@$@", @"Storing garlic RI down tunnel for: ", [dsm getKey], @" sent to: ", _client_)];
          [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) addWithNetI2pDataI2npI2NPMessage:dsm withNetI2pDataRouterRouterIdentity:nil withNetI2pDataHash:nil];
        }
      }
      else if (_client_ != nil && type == NetI2pDataI2npDatabaseSearchReplyMessage_MESSAGE_TYPE) {
        NetI2pDataI2npDatabaseSearchReplyMessage *orig = (NetI2pDataI2npDatabaseSearchReplyMessage *) cast_chk(data, [NetI2pDataI2npDatabaseSearchReplyMessage class]);
        [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) addWithNetI2pDataI2npI2NPMessage:orig withNetI2pDataRouterRouterIdentity:nil withNetI2pDataHash:nil];
      }
      else if (type == NetI2pDataI2npDataMessage_MESSAGE_TYPE) {
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.handleLoadClove" withLong:1];
        data = nil;
      }
      else if (_client_ != nil && type != NetI2pDataI2npDeliveryStatusMessage_MESSAGE_TYPE) {
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"tunnel.dropDangerousClientTunnelMessage" withLong:1 withLong:[data getType]];
        [_log_ errorWithNSString:JreStrcat("$@$@", @"Dropped dangerous message down a tunnel for ", _client_, @": ", data) withJavaLangThrowable:create_JavaLangException_initWithNSString_(@"cause")];
      }
      else {
        [((NetI2pRouterInNetMessagePool *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) inNetMessagePool])) addWithNetI2pDataI2npI2NPMessage:data withNetI2pDataRouterRouterIdentity:nil withNetI2pDataHash:nil];
      }
      return;
      case NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_DESTINATION:
      to = [instructions getDestination];
      if (type != NetI2pDataI2npDataMessage_MESSAGE_TYPE) {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$$$", @"cant send a ", [[data java_getClass] getSimpleName], @" to a destination")];
      }
      else if (_client_ != nil && [_client_ isEqual:to]) {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@", @"data message came down a tunnel for ", _client_)];
        NetI2pDataI2npDataMessage *dm = (NetI2pDataI2npDataMessage *) cast_chk(data, [NetI2pDataI2npDataMessage class]);
        NetI2pDataPayload *payload = create_NetI2pDataPayload_init();
        [payload setEncryptedDataWithByteArray:[dm getData]];
        NetI2pRouterClientMessage *m = create_NetI2pRouterClientMessage_initWithNetI2pDataHash_withNetI2pDataPayload_(_client_, payload);
        [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) clientManager])) messageReceivedWithNetI2pRouterClientMessage:m];
      }
      else if (_client_ != nil) {
        NetI2pRouterTunnelPoolSettings *tgt = [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) tunnelManager])) getInboundSettingsWithNetI2pDataHash:to];
        if (tgt != nil && [_client_ isEqual:[tgt getAliasOf]]) {
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@$@", @"data message came down a tunnel for ", _client_, @" targeting shared ", to)];
          NetI2pDataI2npDataMessage *dm = (NetI2pDataI2npDataMessage *) cast_chk(data, [NetI2pDataI2npDataMessage class]);
          NetI2pDataPayload *payload = create_NetI2pDataPayload_init();
          [payload setEncryptedDataWithByteArray:[dm getData]];
          NetI2pRouterClientMessage *m = create_NetI2pRouterClientMessage_initWithNetI2pDataHash_withNetI2pDataPayload_(to, payload);
          [((NetI2pRouterClientManagerFacade *) nil_chk([_context_ clientManager])) messageReceivedWithNetI2pRouterClientMessage:m];
        }
        else {
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$@$@", @"Data message came down a tunnel for ", _client_, @" but targetted ", to)];
        }
      }
      else {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$@", @"Data message came down an exploratory tunnel targeting ", to)];
      }
      return;
      case NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_ROUTER:
      case NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_TUNNEL:
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@C@$", @"clove targetted ", [instructions getRouter], ':', [instructions getTunnelId], @", treat recursively to prevent leakage")];
      [self distributeWithNetI2pDataI2npI2NPMessage:data withNetI2pDataHash:[instructions getRouter] withNetI2pDataTunnelId:[instructions getTunnelId]];
      return;
      default:
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$I$@", @"Unknown instruction ", [instructions getDeliveryMode], @": ", instructions)];
      return;
    }
  }
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_log_);
  RELEASE_(_client_);
  RELEASE_(_receiver_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:withNetI2pDataHash:);
  methods[1].selector = @selector(distributeWithNetI2pDataI2npI2NPMessage:withNetI2pDataHash:);
  methods[2].selector = @selector(distributeWithNetI2pDataI2npI2NPMessage:withNetI2pDataHash:withNetI2pDataTunnelId:);
  methods[3].selector = @selector(handleCloveWithNetI2pDataI2npDeliveryInstructions:withNetI2pDataI2npI2NPMessage:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_context_", "LNetI2pRouterRouterContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_client_", "LNetI2pDataHash;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_receiver_", "LNetI2pRouterMessageGarlicMessageReceiver;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pDataHash;", "distribute", "LNetI2pDataI2npI2NPMessage;LNetI2pDataHash;", "LNetI2pDataI2npI2NPMessage;LNetI2pDataHash;LNetI2pDataTunnelId;", "handleClove", "LNetI2pDataI2npDeliveryInstructions;LNetI2pDataI2npI2NPMessage;" };
  static const J2ObjcClassInfo _NetI2pRouterTunnelInboundMessageDistributor = { "InboundMessageDistributor", "net.i2p.router.tunnel", ptrTable, methods, fields, 7, 0x0, 4, 4, -1, -1, -1, -1, -1 };
  return &_NetI2pRouterTunnelInboundMessageDistributor;
}

@end

void NetI2pRouterTunnelInboundMessageDistributor_initWithNetI2pRouterRouterContext_withNetI2pDataHash_(NetI2pRouterTunnelInboundMessageDistributor *self, NetI2pRouterRouterContext *ctx, NetI2pDataHash *client) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, ctx);
  JreStrongAssign(&self->_client_, client);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) logManager])) getLogWithIOSClass:NetI2pRouterTunnelInboundMessageDistributor_class_()]);
  JreStrongAssignAndConsume(&self->_receiver_, new_NetI2pRouterMessageGarlicMessageReceiver_initWithNetI2pRouterRouterContext_withNetI2pRouterMessageGarlicMessageReceiver_CloveReceiver_withNetI2pDataHash_(ctx, self, client));
}

NetI2pRouterTunnelInboundMessageDistributor *new_NetI2pRouterTunnelInboundMessageDistributor_initWithNetI2pRouterRouterContext_withNetI2pDataHash_(NetI2pRouterRouterContext *ctx, NetI2pDataHash *client) {
  J2OBJC_NEW_IMPL(NetI2pRouterTunnelInboundMessageDistributor, initWithNetI2pRouterRouterContext_withNetI2pDataHash_, ctx, client)
}

NetI2pRouterTunnelInboundMessageDistributor *create_NetI2pRouterTunnelInboundMessageDistributor_initWithNetI2pRouterRouterContext_withNetI2pDataHash_(NetI2pRouterRouterContext *ctx, NetI2pDataHash *client) {
  J2OBJC_CREATE_IMPL(NetI2pRouterTunnelInboundMessageDistributor, initWithNetI2pRouterRouterContext_withNetI2pDataHash_, ctx, client)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTunnelInboundMessageDistributor)
