//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/transport/ntcp/EventPumper.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InternalError.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/net/Inet6Address.h"
#include "java/net/InetAddress.h"
#include "java/net/InetSocketAddress.h"
#include "java/net/Socket.h"
#include "java/nio/Buffer.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/channels/CancelledKeyException.h"
#include "java/nio/channels/ClosedChannelException.h"
#include "java/nio/channels/ClosedSelectorException.h"
#include "java/nio/channels/NoConnectionPendingException.h"
#include "java/nio/channels/NotYetConnectedException.h"
#include "java/nio/channels/SelectableChannel.h"
#include "java/nio/channels/SelectionKey.h"
#include "java/nio/channels/Selector.h"
#include "java/nio/channels/ServerSocketChannel.h"
#include "java/nio/channels/SocketChannel.h"
#include "java/nio/channels/UnresolvedAddressException.h"
#include "java/util/Iterator.h"
#include "java/util/Queue.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentLinkedQueue.h"
#include "net/i2p/I2PAppContext.h"
#include "net/i2p/data/ByteArray.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/router/RouterAddress.h"
#include "net/i2p/data/router/RouterIdentity.h"
#include "net/i2p/router/Blocklist.h"
#include "net/i2p/router/CommSystemFacade.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/transport/FIFOBandwidthLimiter.h"
#include "net/i2p/router/transport/ntcp/EventPumper.h"
#include "net/i2p/router/transport/ntcp/NTCPConnection.h"
#include "net/i2p/router/transport/ntcp/NTCPTransport.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Addresses.h"
#include "net/i2p/util/ConcurrentHashSet.h"
#include "net/i2p/util/I2PThread.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/ObjectCounter.h"
#include "net/i2p/util/SystemVersion.h"
#include "net/i2p/util/TryCache.h"

@interface NetI2pRouterTransportNtcpEventPumper () {
 @public
  NetI2pRouterRouterContext *_context_;
  NetI2pUtilLog *_log_;
  volatile_jboolean _alive_;
  JavaNioChannelsSelector *_selector_;
  id<JavaUtilSet> _wantsWrite_;
  id<JavaUtilQueue> _wantsRead_;
  id<JavaUtilQueue> _wantsRegister_;
  id<JavaUtilQueue> _wantsConRegister_;
  NetI2pRouterTransportNtcpNTCPTransport *_transport_;
  NetI2pUtilObjectCounter *_blockedIPs_;
  jlong _expireIdleWriteTime_;
  jlong _lastExpired_;
}

- (void)processKeysWithJavaUtilSet:(id<JavaUtilSet>)selected;

- (JavaNioByteBuffer *)acquireBuf;

- (void)processAcceptWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key;

- (void)processConnectWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key;

- (jboolean)shouldSetKeepAliveWithJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)chan;

- (void)processReadWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key;

- (void)processWriteWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key;

- (void)runDelayedEvents;

- (void)expireTimedOut;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _context_, NetI2pRouterRouterContext *)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _selector_, JavaNioChannelsSelector *)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _wantsWrite_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _wantsRead_, id<JavaUtilQueue>)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _wantsRegister_, id<JavaUtilQueue>)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _wantsConRegister_, id<JavaUtilQueue>)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _transport_, NetI2pRouterTransportNtcpNTCPTransport *)
J2OBJC_FIELD_SETTER(NetI2pRouterTransportNtcpEventPumper, _blockedIPs_, NetI2pUtilObjectCounter *)

inline jboolean NetI2pRouterTransportNtcpEventPumper_get__useDirect(void);
#define NetI2pRouterTransportNtcpEventPumper__useDirect false
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, _useDirect, jboolean)

inline jint NetI2pRouterTransportNtcpEventPumper_get_BUF_SIZE(void);
#define NetI2pRouterTransportNtcpEventPumper_BUF_SIZE 8192
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, BUF_SIZE, jint)

inline jint NetI2pRouterTransportNtcpEventPumper_get_MAX_CACHE_SIZE(void);
#define NetI2pRouterTransportNtcpEventPumper_MAX_CACHE_SIZE 64
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MAX_CACHE_SIZE, jint)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_FAILSAFE_ITERATION_FREQ(void);
#define NetI2pRouterTransportNtcpEventPumper_FAILSAFE_ITERATION_FREQ 2000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, FAILSAFE_ITERATION_FREQ, jlong)

inline jint NetI2pRouterTransportNtcpEventPumper_get_FAILSAFE_LOOP_COUNT(void);
#define NetI2pRouterTransportNtcpEventPumper_FAILSAFE_LOOP_COUNT 512
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, FAILSAFE_LOOP_COUNT, jint)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_SELECTOR_LOOP_DELAY(void);
#define NetI2pRouterTransportNtcpEventPumper_SELECTOR_LOOP_DELAY 200LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, SELECTOR_LOOP_DELAY, jlong)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_BLOCKED_IP_FREQ(void);
#define NetI2pRouterTransportNtcpEventPumper_BLOCKED_IP_FREQ 180000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, BLOCKED_IP_FREQ, jlong)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_MIN_EXPIRE_IDLE_TIME(void);
#define NetI2pRouterTransportNtcpEventPumper_MIN_EXPIRE_IDLE_TIME 120000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MIN_EXPIRE_IDLE_TIME, jlong)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_MAX_EXPIRE_IDLE_TIME(void);
#define NetI2pRouterTransportNtcpEventPumper_MAX_EXPIRE_IDLE_TIME 660000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MAX_EXPIRE_IDLE_TIME, jlong)

inline jlong NetI2pRouterTransportNtcpEventPumper_get_MAY_DISCON_TIMEOUT(void);
#define NetI2pRouterTransportNtcpEventPumper_MAY_DISCON_TIMEOUT 10000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MAY_DISCON_TIMEOUT, jlong)

inline jint NetI2pRouterTransportNtcpEventPumper_get_MIN_MINB(void);
#define NetI2pRouterTransportNtcpEventPumper_MIN_MINB 4
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MIN_MINB, jint)

inline jint NetI2pRouterTransportNtcpEventPumper_get_MAX_MINB(void);
#define NetI2pRouterTransportNtcpEventPumper_MAX_MINB 12
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterTransportNtcpEventPumper, MAX_MINB, jint)

inline jint NetI2pRouterTransportNtcpEventPumper_get_MIN_BUFS(void);
static jint NetI2pRouterTransportNtcpEventPumper_MIN_BUFS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(NetI2pRouterTransportNtcpEventPumper, MIN_BUFS, jint)

inline NetI2pUtilTryCache *NetI2pRouterTransportNtcpEventPumper_get__bufferCache(void);
static NetI2pUtilTryCache *NetI2pRouterTransportNtcpEventPumper__bufferCache;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterTransportNtcpEventPumper, _bufferCache, NetI2pUtilTryCache *)

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_processKeysWithJavaUtilSet_(NetI2pRouterTransportNtcpEventPumper *self, id<JavaUtilSet> selected);

__attribute__((unused)) static JavaNioByteBuffer *NetI2pRouterTransportNtcpEventPumper_acquireBuf(NetI2pRouterTransportNtcpEventPumper *self);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_processAcceptWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_processConnectWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key);

__attribute__((unused)) static jboolean NetI2pRouterTransportNtcpEventPumper_shouldSetKeepAliveWithJavaNioChannelsSocketChannel_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSocketChannel *chan);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_processReadWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_processWriteWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_runDelayedEvents(NetI2pRouterTransportNtcpEventPumper *self);

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_expireTimedOut(NetI2pRouterTransportNtcpEventPumper *self);

@interface NetI2pRouterTransportNtcpEventPumper_BufferFactory : NSObject < NetI2pUtilTryCache_ObjectFactory >

- (instancetype)init;

- (JavaNioByteBuffer *)newInstance OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterTransportNtcpEventPumper_BufferFactory)

__attribute__((unused)) static void NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(NetI2pRouterTransportNtcpEventPumper_BufferFactory *self);

__attribute__((unused)) static NetI2pRouterTransportNtcpEventPumper_BufferFactory *new_NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterTransportNtcpEventPumper_BufferFactory *create_NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(void);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterTransportNtcpEventPumper_BufferFactory)

J2OBJC_INITIALIZED_DEFN(NetI2pRouterTransportNtcpEventPumper)

@implementation NetI2pRouterTransportNtcpEventPumper

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
       withNetI2pRouterTransportNtcpNTCPTransport:(NetI2pRouterTransportNtcpNTCPTransport *)transport {
  NetI2pRouterTransportNtcpEventPumper_initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_(self, ctx, transport);
  return self;
}

- (void)startPumping {
  @synchronized(self) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:@"Starting pumper"];
    @try {
      JreStrongAssign(&_selector_, JavaNioChannelsSelector_open());
      JreAssignVolatileBoolean(&_alive_, true);
      [create_NetI2pUtilI2PThread_initWithJavaLangRunnable_withNSString_withBoolean_(self, @"NTCP Pumper", true) start];
    }
    @catch (JavaIoIOException *ioe) {
      [_log_ logWithInt:NetI2pUtilLog_CRIT withNSString:@"Error opening the NTCP selector" withJavaLangThrowable:ioe];
    }
    @catch (JavaLangInternalError *jlie) {
      [_log_ logWithInt:NetI2pUtilLog_CRIT withNSString:@"Error opening the NTCP selector" withJavaLangThrowable:jlie];
    }
  }
}

- (void)stopPumping {
  @synchronized(self) {
    JreAssignVolatileBoolean(&_alive_, false);
    if (_selector_ != nil && [_selector_ isOpen]) [_selector_ wakeup];
  }
}

- (jboolean)isAlive {
  return JreLoadVolatileBoolean(&_alive_) || (_selector_ != nil && [_selector_ isOpen]);
}

- (void)register__WithJavaNioChannelsServerSocketChannel:(JavaNioChannelsServerSocketChannel *)chan {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:@"Registering server socket channel"];
  [((id<JavaUtilQueue>) nil_chk(_wantsRegister_)) offerWithId:chan];
  [((JavaNioChannelsSelector *) nil_chk(_selector_)) wakeup];
}

- (void)registerConnectWithNetI2pRouterTransportNtcpNTCPConnection:(NetI2pRouterTransportNtcpNTCPConnection *)con {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@", @"Registering ", con)];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"ntcp.registerConnect" withLong:1];
  [((id<JavaUtilQueue>) nil_chk(_wantsConRegister_)) offerWithId:con];
  [((JavaNioChannelsSelector *) nil_chk(_selector_)) wakeup];
}

- (void)run {
  jint loopCount = 0;
  jint failsafeLoopCount = NetI2pRouterTransportNtcpEventPumper_FAILSAFE_LOOP_COUNT;
  jlong lastFailsafeIteration = JavaLangSystem_currentTimeMillis();
  jlong lastBlockedIPClear = lastFailsafeIteration;
  while (JreLoadVolatileBoolean(&_alive_) && [((JavaNioChannelsSelector *) nil_chk(_selector_)) isOpen]) {
    @try {
      loopCount++;
      @try {
        jint count = [((JavaNioChannelsSelector *) nil_chk(_selector_)) selectWithLong:NetI2pRouterTransportNtcpEventPumper_SELECTOR_LOOP_DELAY];
        if (count > 0) {
          id<JavaUtilSet> selected = [((JavaNioChannelsSelector *) nil_chk(_selector_)) selectedKeys];
          NetI2pRouterTransportNtcpEventPumper_processKeysWithJavaUtilSet_(self, selected);
          [((id<JavaUtilSet>) nil_chk(selected)) clear];
        }
        NetI2pRouterTransportNtcpEventPumper_runDelayedEvents(self);
      }
      @catch (JavaNioChannelsClosedSelectorException *cse) {
        continue;
      }
      @catch (JavaIoIOException *ioe) {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Error selecting" withJavaLangThrowable:ioe];
      }
      @catch (JavaNioChannelsCancelledKeyException *cke) {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Error selecting" withJavaLangThrowable:cke];
        continue;
      }
      jlong now = JavaLangSystem_currentTimeMillis();
      if (lastFailsafeIteration + NetI2pRouterTransportNtcpEventPumper_FAILSAFE_ITERATION_FREQ < now) {
        lastFailsafeIteration = now;
        @try {
          id<JavaUtilSet> all = [((JavaNioChannelsSelector *) nil_chk(_selector_)) keys];
          jint lastKeySetSize = [((id<JavaUtilSet>) nil_chk(all)) size];
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"ntcp.pumperKeySetSize" withLong:lastKeySetSize];
          [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"ntcp.pumperLoopsPerSecond" withLong:loopCount / (NetI2pRouterTransportNtcpEventPumper_FAILSAFE_ITERATION_FREQ / 1000)];
          loopCount = 0;
          failsafeLoopCount = JavaLangMath_maxWithInt_withInt_(NetI2pRouterTransportNtcpEventPumper_FAILSAFE_LOOP_COUNT, 2 * lastKeySetSize);
          jint failsafeWrites = 0;
          jint failsafeCloses = 0;
          jint failsafeInvalid = 0;
          jboolean haveCap = [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(_transport_)) haveCapacityWithInt:33];
          if (haveCap) _expireIdleWriteTime_ = JavaLangMath_minWithLong_withLong_(_expireIdleWriteTime_ + 1000, NetI2pRouterTransportNtcpEventPumper_MAX_EXPIRE_IDLE_TIME);
          else _expireIdleWriteTime_ = JavaLangMath_maxWithLong_withLong_(_expireIdleWriteTime_ - 3000, NetI2pRouterTransportNtcpEventPumper_MIN_EXPIRE_IDLE_TIME);
          for (JavaNioChannelsSelectionKey * __strong key in all) {
            @try {
              id att = [((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment];
              if (!([att isKindOfClass:[NetI2pRouterTransportNtcpNTCPConnection class]])) continue;
              NetI2pRouterTransportNtcpNTCPConnection *con = (NetI2pRouterTransportNtcpNTCPConnection *) cast_chk(att, [NetI2pRouterTransportNtcpNTCPConnection class]);
              if ((![key isValid]) && (![((JavaNioChannelsSocketChannel *) nil_chk(((JavaNioChannelsSocketChannel *) cast_chk([key channel], [JavaNioChannelsSocketChannel class])))) isConnectionPending]) && [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getTimeSinceCreated] > 2 * NetI2pRouterTransportNtcpNTCPTransport_ESTABLISH_TIMEOUT) {
                if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Removing invalid key for ", con)];
                [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) close];
                failsafeInvalid++;
                continue;
              }
              if ((![((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) isWriteBufEmpty]) && (([key interestOps] & JavaNioChannelsSelectionKey_OP_WRITE) == 0)) {
                if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"Failsafe write for ", con)];
                [key interestOpsWithInt:JavaNioChannelsSelectionKey_OP_WRITE | [key interestOps]];
                failsafeWrites++;
              }
              jlong expire;
              if ((!haveCap || ![con isInbound]) && [con getMayDisconnect] && [con getMessagesReceived] <= 2 && [con getMessagesSent] <= 1) {
                expire = NetI2pRouterTransportNtcpEventPumper_MAY_DISCON_TIMEOUT;
                if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldInfo]) [_log_ infoWithNSString:JreStrcat("$@", @"Possible early disconnect for ", con)];
              }
              else {
                expire = _expireIdleWriteTime_;
              }
              if ([con getTimeSinceSend] > expire && [con getTimeSinceReceive] > expire) {
                [con sendTerminationAndClose];
                if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldInfo]) [_log_ infoWithNSString:JreStrcat("$@", @"Failsafe or expire close for ", con)];
                failsafeCloses++;
              }
            }
            @catch (JavaNioChannelsCancelledKeyException *cke) {
            }
          }
          if (failsafeWrites > 0) [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"ntcp.failsafeWrites" withLong:failsafeWrites];
          if (failsafeCloses > 0) [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"ntcp.failsafeCloses" withLong:failsafeCloses];
          if (failsafeInvalid > 0) [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"ntcp.failsafeInvalid" withLong:failsafeInvalid];
        }
        @catch (JavaNioChannelsClosedSelectorException *cse) {
          continue;
        }
      }
      else {
        if ((loopCount % failsafeLoopCount) == failsafeLoopCount - 1) {
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$I$J$", @"EventPumper throttle ", loopCount, @" loops in ", (now - lastFailsafeIteration), @" ms")];
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) addRateDataWithNSString:@"ntcp.failsafeThrottle" withLong:1];
          @try {
            JavaLangThread_sleepWithLong_(25);
          }
          @catch (JavaLangInterruptedException *ie) {
          }
        }
      }
      if (lastBlockedIPClear + NetI2pRouterTransportNtcpEventPumper_BLOCKED_IP_FREQ < now) {
        [((NetI2pUtilObjectCounter *) nil_chk(_blockedIPs_)) clear];
        lastBlockedIPClear = now;
      }
    }
    @catch (JavaLangRuntimeException *re) {
      [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:@"Error in the event pumper" withJavaLangThrowable:re];
    }
  }
  @try {
    if ([((JavaNioChannelsSelector *) nil_chk(_selector_)) isOpen]) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:@"Closing down the event pumper with selection keys remaining"];
      id<JavaUtilSet> keys = [((JavaNioChannelsSelector *) nil_chk(_selector_)) keys];
      for (JavaNioChannelsSelectionKey * __strong key in nil_chk(keys)) {
        @try {
          id att = [((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment];
          if ([att isKindOfClass:[JavaNioChannelsServerSocketChannel class]]) {
            JavaNioChannelsServerSocketChannel *chan = (JavaNioChannelsServerSocketChannel *) cast_chk(att, [JavaNioChannelsServerSocketChannel class]);
            [((JavaNioChannelsServerSocketChannel *) nil_chk(chan)) close];
            [key cancel];
          }
          else if ([att isKindOfClass:[NetI2pRouterTransportNtcpNTCPConnection class]]) {
            NetI2pRouterTransportNtcpNTCPConnection *con = (NetI2pRouterTransportNtcpNTCPConnection *) cast_chk(att, [NetI2pRouterTransportNtcpNTCPConnection class]);
            [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) close];
            [key cancel];
          }
        }
        @catch (JavaIoIOException *ke) {
          [_log_ errorWithNSString:JreStrcat("$@$", @"Error closing key ", key, @" on pumper shutdown") withJavaLangThrowable:ke];
        }
      }
      [((JavaNioChannelsSelector *) nil_chk(_selector_)) close];
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:@"Closing down the event pumper with no selection keys remaining"];
    }
  }
  @catch (JavaIoIOException *e) {
    [((NetI2pUtilLog *) nil_chk(_log_)) errorWithNSString:@"Error closing keys on pumper shutdown" withJavaLangThrowable:e];
  }
  [((id<JavaUtilQueue>) nil_chk(_wantsConRegister_)) clear];
  [((id<JavaUtilQueue>) nil_chk(_wantsRead_)) clear];
  [((id<JavaUtilQueue>) nil_chk(_wantsRegister_)) clear];
  [((id<JavaUtilSet>) nil_chk(_wantsWrite_)) clear];
}

- (void)processKeysWithJavaUtilSet:(id<JavaUtilSet>)selected {
  NetI2pRouterTransportNtcpEventPumper_processKeysWithJavaUtilSet_(self, selected);
}

- (void)wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:(NetI2pRouterTransportNtcpNTCPConnection *)con
                                                withByteArray:(IOSByteArray *)data {
  [self wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:con withByteArray:data withInt:0 withInt:((IOSByteArray *) nil_chk(data))->size_];
}

- (void)wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:(NetI2pRouterTransportNtcpNTCPConnection *)con
                                                withByteArray:(IOSByteArray *)data
                                                      withInt:(jint)off
                                                      withInt:(jint)len {
  JavaNioByteBuffer *buf = JavaNioByteBuffer_wrapWithByteArray_withInt_withInt_(data, off, len);
  id<NetI2pRouterTransportFIFOBandwidthLimiter_Request> req = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) bandwidthLimiter])) requestOutboundWithInt:len withInt:0 withNSString:@"NTCP write"];
  if ([((id<NetI2pRouterTransportFIFOBandwidthLimiter_Request>) nil_chk(req)) getPendingRequested] > 0) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@$I", @"queued write on ", con, @" for ", len)];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"ntcp.wantsQueuedWrite" withLong:1];
    [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) queuedWriteWithJavaNioByteBuffer:buf withNetI2pRouterTransportFIFOBandwidthLimiter_Request:req];
  }
  else {
    [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) writeWithJavaNioByteBuffer:buf];
  }
}

- (void)wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:(NetI2pRouterTransportNtcpNTCPConnection *)con {
  if ([((id<JavaUtilSet>) nil_chk(_wantsWrite_)) addWithId:con]) {
    [((JavaNioChannelsSelector *) nil_chk(_selector_)) wakeup];
  }
}

- (void)wantsReadWithNetI2pRouterTransportNtcpNTCPConnection:(NetI2pRouterTransportNtcpNTCPConnection *)con {
  [((id<JavaUtilQueue>) nil_chk(_wantsRead_)) offerWithId:con];
  [((JavaNioChannelsSelector *) nil_chk(_selector_)) wakeup];
}

- (JavaNioByteBuffer *)acquireBuf {
  return NetI2pRouterTransportNtcpEventPumper_acquireBuf(self);
}

+ (void)releaseBufWithJavaNioByteBuffer:(JavaNioByteBuffer *)buf {
  NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
}

- (void)processAcceptWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key {
  NetI2pRouterTransportNtcpEventPumper_processAcceptWithJavaNioChannelsSelectionKey_(self, key);
}

- (void)processConnectWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key {
  NetI2pRouterTransportNtcpEventPumper_processConnectWithJavaNioChannelsSelectionKey_(self, key);
}

- (jboolean)shouldSetKeepAliveWithJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)chan {
  return NetI2pRouterTransportNtcpEventPumper_shouldSetKeepAliveWithJavaNioChannelsSocketChannel_(self, chan);
}

- (void)processReadWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key {
  NetI2pRouterTransportNtcpEventPumper_processReadWithJavaNioChannelsSelectionKey_(self, key);
}

- (void)processWriteWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key {
  NetI2pRouterTransportNtcpEventPumper_processWriteWithJavaNioChannelsSelectionKey_(self, key);
}

- (void)runDelayedEvents {
  NetI2pRouterTransportNtcpEventPumper_runDelayedEvents(self);
}

- (void)expireTimedOut {
  NetI2pRouterTransportNtcpEventPumper_expireTimedOut(self);
}

- (jlong)getIdleTimeout {
  return _expireIdleWriteTime_;
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_log_);
  RELEASE_(_selector_);
  RELEASE_(_wantsWrite_);
  RELEASE_(_wantsRead_);
  RELEASE_(_wantsRegister_);
  RELEASE_(_wantsConRegister_);
  RELEASE_(_transport_);
  RELEASE_(_blockedIPs_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 5, 6, -1, 7, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 4, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 12, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 14, 15, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 16, 15, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 17, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 19, 15, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 15, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:withNetI2pRouterTransportNtcpNTCPTransport:);
  methods[1].selector = @selector(startPumping);
  methods[2].selector = @selector(stopPumping);
  methods[3].selector = @selector(isAlive);
  methods[4].selector = @selector(register__WithJavaNioChannelsServerSocketChannel:);
  methods[5].selector = @selector(registerConnectWithNetI2pRouterTransportNtcpNTCPConnection:);
  methods[6].selector = @selector(run);
  methods[7].selector = @selector(processKeysWithJavaUtilSet:);
  methods[8].selector = @selector(wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:withByteArray:);
  methods[9].selector = @selector(wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:withByteArray:withInt:withInt:);
  methods[10].selector = @selector(wantsWriteWithNetI2pRouterTransportNtcpNTCPConnection:);
  methods[11].selector = @selector(wantsReadWithNetI2pRouterTransportNtcpNTCPConnection:);
  methods[12].selector = @selector(acquireBuf);
  methods[13].selector = @selector(releaseBufWithJavaNioByteBuffer:);
  methods[14].selector = @selector(processAcceptWithJavaNioChannelsSelectionKey:);
  methods[15].selector = @selector(processConnectWithJavaNioChannelsSelectionKey:);
  methods[16].selector = @selector(shouldSetKeepAliveWithJavaNioChannelsSocketChannel:);
  methods[17].selector = @selector(processReadWithJavaNioChannelsSelectionKey:);
  methods[18].selector = @selector(processWriteWithJavaNioChannelsSelectionKey:);
  methods[19].selector = @selector(runDelayedEvents);
  methods[20].selector = @selector(expireTimedOut);
  methods[21].selector = @selector(getIdleTimeout);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_context_", "LNetI2pRouterRouterContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_alive_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "_selector_", "LJavaNioChannelsSelector;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_wantsWrite_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x12, -1, -1, 21, -1 },
    { "_wantsRead_", "LJavaUtilQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 22, -1 },
    { "_wantsRegister_", "LJavaUtilQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 23, -1 },
    { "_wantsConRegister_", "LJavaUtilQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 22, -1 },
    { "_transport_", "LNetI2pRouterTransportNtcpNTCPTransport;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_blockedIPs_", "LNetI2pUtilObjectCounter;", .constantValue.asLong = 0, 0x12, -1, -1, 24, -1 },
    { "_expireIdleWriteTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_useDirect", "Z", .constantValue.asBOOL = NetI2pRouterTransportNtcpEventPumper__useDirect, 0x1a, -1, -1, -1, -1 },
    { "BUF_SIZE", "I", .constantValue.asInt = NetI2pRouterTransportNtcpEventPumper_BUF_SIZE, 0x1a, -1, -1, -1, -1 },
    { "MAX_CACHE_SIZE", "I", .constantValue.asInt = NetI2pRouterTransportNtcpEventPumper_MAX_CACHE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "FAILSAFE_ITERATION_FREQ", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_FAILSAFE_ITERATION_FREQ, 0x1a, -1, -1, -1, -1 },
    { "FAILSAFE_LOOP_COUNT", "I", .constantValue.asInt = NetI2pRouterTransportNtcpEventPumper_FAILSAFE_LOOP_COUNT, 0x1a, -1, -1, -1, -1 },
    { "SELECTOR_LOOP_DELAY", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_SELECTOR_LOOP_DELAY, 0x1a, -1, -1, -1, -1 },
    { "BLOCKED_IP_FREQ", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_BLOCKED_IP_FREQ, 0x1a, -1, -1, -1, -1 },
    { "MIN_EXPIRE_IDLE_TIME", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_MIN_EXPIRE_IDLE_TIME, 0x1a, -1, -1, -1, -1 },
    { "MAX_EXPIRE_IDLE_TIME", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_MAX_EXPIRE_IDLE_TIME, 0x1a, -1, -1, -1, -1 },
    { "MAY_DISCON_TIMEOUT", "J", .constantValue.asLong = NetI2pRouterTransportNtcpEventPumper_MAY_DISCON_TIMEOUT, 0x1a, -1, -1, -1, -1 },
    { "MIN_MINB", "I", .constantValue.asInt = NetI2pRouterTransportNtcpEventPumper_MIN_MINB, 0x1a, -1, -1, -1, -1 },
    { "MAX_MINB", "I", .constantValue.asInt = NetI2pRouterTransportNtcpEventPumper_MAX_MINB, 0x1a, -1, -1, -1, -1 },
    { "MIN_BUFS", "I", .constantValue.asLong = 0, 0x1a, -1, 25, -1, -1 },
    { "_bufferCache", "LNetI2pUtilTryCache;", .constantValue.asLong = 0, 0x1a, -1, 26, 27, -1 },
    { "_lastExpired_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pRouterTransportNtcpNTCPTransport;", "register", "LJavaNioChannelsServerSocketChannel;", "registerConnect", "LNetI2pRouterTransportNtcpNTCPConnection;", "processKeys", "LJavaUtilSet;", "(Ljava/util/Set<Ljava/nio/channels/SelectionKey;>;)V", "wantsWrite", "LNetI2pRouterTransportNtcpNTCPConnection;[B", "LNetI2pRouterTransportNtcpNTCPConnection;[BII", "wantsRead", "releaseBuf", "LJavaNioByteBuffer;", "processAccept", "LJavaNioChannelsSelectionKey;", "processConnect", "shouldSetKeepAlive", "LJavaNioChannelsSocketChannel;", "processRead", "processWrite", "Ljava/util/Set<Lnet/i2p/router/transport/ntcp/NTCPConnection;>;", "Ljava/util/Queue<Lnet/i2p/router/transport/ntcp/NTCPConnection;>;", "Ljava/util/Queue<Ljava/nio/channels/ServerSocketChannel;>;", "Lnet/i2p/util/ObjectCounter<Lnet/i2p/data/ByteArray;>;", &NetI2pRouterTransportNtcpEventPumper_MIN_BUFS, &NetI2pRouterTransportNtcpEventPumper__bufferCache, "Lnet/i2p/util/TryCache<Ljava/nio/ByteBuffer;>;", "LNetI2pRouterTransportNtcpEventPumper_BufferFactory;" };
  static const J2ObjcClassInfo _NetI2pRouterTransportNtcpEventPumper = { "EventPumper", "net.i2p.router.transport.ntcp", ptrTable, methods, fields, 7, 0x0, 22, 26, -1, 28, -1, -1, -1 };
  return &_NetI2pRouterTransportNtcpEventPumper;
}

+ (void)initialize {
  if (self == [NetI2pRouterTransportNtcpEventPumper class]) {
    {
      jlong maxMemory = NetI2pUtilSystemVersion_getMaxMemory();
      NetI2pRouterTransportNtcpEventPumper_MIN_BUFS = (jint) JavaLangMath_maxWithLong_withLong_(NetI2pRouterTransportNtcpEventPumper_MIN_MINB, JavaLangMath_minWithLong_withLong_(NetI2pRouterTransportNtcpEventPumper_MAX_MINB, 1 + (maxMemory / (16 * 1024 * 1024))));
    }
    JreStrongAssignAndConsume(&NetI2pRouterTransportNtcpEventPumper__bufferCache, new_NetI2pUtilTryCache_initWithNetI2pUtilTryCache_ObjectFactory_withInt_(create_NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(), NetI2pRouterTransportNtcpEventPumper_MIN_BUFS));
    J2OBJC_SET_INITIALIZED(NetI2pRouterTransportNtcpEventPumper)
  }
}

@end

void NetI2pRouterTransportNtcpEventPumper_initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_(NetI2pRouterTransportNtcpEventPumper *self, NetI2pRouterRouterContext *ctx, NetI2pRouterTransportNtcpNTCPTransport *transport) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_wantsWrite_, new_NetI2pUtilConcurrentHashSet_initWithInt_(32));
  JreStrongAssignAndConsume(&self->_wantsRead_, new_JavaUtilConcurrentConcurrentLinkedQueue_init());
  JreStrongAssignAndConsume(&self->_wantsRegister_, new_JavaUtilConcurrentConcurrentLinkedQueue_init());
  JreStrongAssignAndConsume(&self->_wantsConRegister_, new_JavaUtilConcurrentConcurrentLinkedQueue_init());
  JreStrongAssign(&self->_context_, ctx);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) logManager])) getLogWithIOSClass:[self java_getClass]]);
  JreStrongAssign(&self->_transport_, transport);
  self->_expireIdleWriteTime_ = NetI2pRouterTransportNtcpEventPumper_MAX_EXPIRE_IDLE_TIME;
  JreStrongAssignAndConsume(&self->_blockedIPs_, new_NetI2pUtilObjectCounter_init());
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) createRateStatWithNSString:@"ntcp.pumperKeySetSize" withNSString:@"" withNSString:@"ntcp" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"ntcp.pumperLoopsPerSecond" withNSString:@"" withNSString:@"ntcp" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"ntcp.zeroRead" withNSString:@"" withNSString:@"ntcp" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"ntcp.zeroReadDrop" withNSString:@"" withNSString:@"ntcp" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000 } count:1]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"ntcp.dropInboundNoMessage" withNSString:@"" withNSString:@"ntcp" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000 } count:1]];
}

NetI2pRouterTransportNtcpEventPumper *new_NetI2pRouterTransportNtcpEventPumper_initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_(NetI2pRouterRouterContext *ctx, NetI2pRouterTransportNtcpNTCPTransport *transport) {
  J2OBJC_NEW_IMPL(NetI2pRouterTransportNtcpEventPumper, initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_, ctx, transport)
}

NetI2pRouterTransportNtcpEventPumper *create_NetI2pRouterTransportNtcpEventPumper_initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_(NetI2pRouterRouterContext *ctx, NetI2pRouterTransportNtcpNTCPTransport *transport) {
  J2OBJC_CREATE_IMPL(NetI2pRouterTransportNtcpEventPumper, initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_, ctx, transport)
}

void NetI2pRouterTransportNtcpEventPumper_processKeysWithJavaUtilSet_(NetI2pRouterTransportNtcpEventPumper *self, id<JavaUtilSet> selected) {
  for (JavaNioChannelsSelectionKey * __strong key in nil_chk(selected)) {
    @try {
      jint ops = [((JavaNioChannelsSelectionKey *) nil_chk(key)) readyOps];
      jboolean accept = (ops & JavaNioChannelsSelectionKey_OP_ACCEPT) != 0;
      jboolean connect = (ops & JavaNioChannelsSelectionKey_OP_CONNECT) != 0;
      jboolean read = (ops & JavaNioChannelsSelectionKey_OP_READ) != 0;
      jboolean write = (ops & JavaNioChannelsSelectionKey_OP_WRITE) != 0;
      if (accept) {
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.accept" withLong:1];
        NetI2pRouterTransportNtcpEventPumper_processAcceptWithJavaNioChannelsSelectionKey_(self, key);
      }
      if (connect) {
        [key interestOpsWithInt:[key interestOps] & ~JavaNioChannelsSelectionKey_OP_CONNECT];
        NetI2pRouterTransportNtcpEventPumper_processConnectWithJavaNioChannelsSelectionKey_(self, key);
      }
      if (read) {
        NetI2pRouterTransportNtcpEventPumper_processReadWithJavaNioChannelsSelectionKey_(self, key);
      }
      if (write) {
        NetI2pRouterTransportNtcpEventPumper_processWriteWithJavaNioChannelsSelectionKey_(self, key);
      }
    }
    @catch (JavaNioChannelsCancelledKeyException *cke) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:@"key cancelled"];
    }
  }
}

JavaNioByteBuffer *NetI2pRouterTransportNtcpEventPumper_acquireBuf(NetI2pRouterTransportNtcpEventPumper *self) {
  return [((NetI2pUtilTryCache *) nil_chk(NetI2pRouterTransportNtcpEventPumper__bufferCache)) acquire];
}

void NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(JavaNioByteBuffer *buf) {
  NetI2pRouterTransportNtcpEventPumper_initialize();
  if ([((JavaNioByteBuffer *) nil_chk(buf)) capacity] < NetI2pRouterTransportNtcpEventPumper_BUF_SIZE) {
    [((NetI2pUtilLog *) nil_chk([((NetI2pUtilLogManager *) nil_chk([((NetI2pI2PAppContext *) nil_chk(NetI2pI2PAppContext_getGlobalContext())) logManager])) getLogWithIOSClass:NetI2pRouterTransportNtcpEventPumper_class_()])) errorWithNSString:JreStrcat("$I", @"Bad size ", [buf capacity]) withJavaLangThrowable:create_JavaLangException_init()];
    return;
  }
  [buf clear];
  [((NetI2pUtilTryCache *) nil_chk(NetI2pRouterTransportNtcpEventPumper__bufferCache)) release__WithId:buf];
}

void NetI2pRouterTransportNtcpEventPumper_processAcceptWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key) {
  JavaNioChannelsServerSocketChannel *servChan = (JavaNioChannelsServerSocketChannel *) cast_chk([((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment], [JavaNioChannelsServerSocketChannel class]);
  @try {
    JavaNioChannelsSocketChannel *chan = [((JavaNioChannelsServerSocketChannel *) nil_chk(servChan)) accept];
    if (chan == nil) return;
    [chan configureBlockingWithBoolean:false];
    if (![((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) allowConnection]) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"Receive session request but at connection limit: ", [((JavaNetSocket *) nil_chk([chan socket])) getInetAddress])];
      @try {
        [chan close];
      }
      @catch (JavaIoIOException *ioe) {
      }
      return;
    }
    IOSByteArray *ip = [((JavaNetInetAddress *) nil_chk([((JavaNetSocket *) nil_chk([chan socket])) getInetAddress])) getAddress];
    if ([((NetI2pRouterBlocklist *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) blocklist])) isBlocklistedWithByteArray:ip]) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"Receive session request from blocklisted IP: ", [((JavaNetSocket *) nil_chk([chan socket])) getInetAddress])];
      @try {
        [chan close];
      }
      @catch (JavaIoIOException *ioe) {
      }
      return;
    }
    NetI2pDataByteArray *ba = create_NetI2pDataByteArray_initWithByteArray_(ip);
    jint count = [((NetI2pUtilObjectCounter *) nil_chk(self->_blockedIPs_)) countWithId:ba];
    if (count > 0) {
      count = [self->_blockedIPs_ incrementWithId:ba];
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$I$$", @"Blocking accept of IP with count ", count, @": ", NetI2pUtilAddresses_toStringWithByteArray_(ip))];
      [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"ntcp.dropInboundNoMessage" withLong:count];
      @try {
        [chan close];
      }
      @catch (JavaIoIOException *ioe) {
      }
      return;
    }
    if (NetI2pRouterTransportNtcpEventPumper_shouldSetKeepAliveWithJavaNioChannelsSocketChannel_(self, chan)) [((JavaNetSocket *) nil_chk([chan socket])) setKeepAliveWithBoolean:true];
    JavaNioChannelsSelectionKey *ckey = [chan register__WithJavaNioChannelsSelector:self->_selector_ withInt:JavaNioChannelsSelectionKey_OP_READ];
    NetI2pRouterTransportNtcpNTCPConnection *con = create_NetI2pRouterTransportNtcpNTCPConnection_initWithNetI2pRouterRouterContext_withNetI2pRouterTransportNtcpNTCPTransport_withJavaNioChannelsSocketChannel_withJavaNioChannelsSelectionKey_(self->_context_, self->_transport_, chan, ckey);
    [((JavaNioChannelsSelectionKey *) nil_chk(ckey)) attachWithId:con];
    [self->_transport_ establishingWithNetI2pRouterTransportNtcpNTCPConnection:con];
  }
  @catch (JavaIoIOException *ioe) {
    [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:@"Error accepting" withJavaLangThrowable:ioe];
  }
}

void NetI2pRouterTransportNtcpEventPumper_processConnectWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key) {
  NetI2pRouterTransportNtcpNTCPConnection *con = (NetI2pRouterTransportNtcpNTCPConnection *) cast_chk([((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment], [NetI2pRouterTransportNtcpNTCPConnection class]);
  @try {
    JavaNioChannelsSocketChannel *chan = [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getChannel];
    jboolean connected = [((JavaNioChannelsSocketChannel *) nil_chk(chan)) finishConnect];
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$@$Z", @"processing connect for ", con, @": connected? ", connected)];
    if (connected) {
      if (NetI2pRouterTransportNtcpEventPumper_shouldSetKeepAliveWithJavaNioChannelsSocketChannel_(self, chan)) [((JavaNetSocket *) nil_chk([chan socket])) setKeepAliveWithBoolean:true];
      [con setKeyWithJavaNioChannelsSelectionKey:key];
      [con outboundConnected];
      [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectSuccessful" withLong:1];
    }
    else {
      [con closeOnTimeoutWithNSString:@"connect failed" withJavaLangException:nil];
      [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) markUnreachableWithNetI2pDataHash:[((NetI2pDataRouterRouterIdentity *) nil_chk([con getRemotePeer])) calculateHash]];
      [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectFailedTimeout" withLong:1];
    }
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$@", @"Failed outbound ", con) withJavaLangThrowable:ioe];
    [con closeOnTimeoutWithNSString:@"connect failed" withJavaLangException:ioe];
    [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) markUnreachableWithNetI2pDataHash:[((NetI2pDataRouterRouterIdentity *) nil_chk([con getRemotePeer])) calculateHash]];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectFailedTimeoutIOE" withLong:1];
  }
  @catch (JavaNioChannelsNoConnectionPendingException *ncpe) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"error connecting on ", con) withJavaLangThrowable:ncpe];
  }
}

jboolean NetI2pRouterTransportNtcpEventPumper_shouldSetKeepAliveWithJavaNioChannelsSocketChannel_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSocketChannel *chan) {
  if ([[((JavaNetSocket *) nil_chk([((JavaNioChannelsSocketChannel *) nil_chk(chan)) socket])) getInetAddress] isKindOfClass:[JavaNetInet6Address class]]) return false;
  NetI2pRouterCommSystemFacade_Status *status = [((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) commSystem])) getStatus];
  if (status == JreLoadEnum(NetI2pRouterCommSystemFacade_Status, OK) || status == JreLoadEnum(NetI2pRouterCommSystemFacade_Status, IPV4_OK_IPV6_UNKNOWN) || status == JreLoadEnum(NetI2pRouterCommSystemFacade_Status, IPV4_OK_IPV6_FIREWALLED)) return false;
  return true;
}

void NetI2pRouterTransportNtcpEventPumper_processReadWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key) {
  NetI2pRouterTransportNtcpNTCPConnection *con = (NetI2pRouterTransportNtcpNTCPConnection *) cast_chk([((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment], [NetI2pRouterTransportNtcpNTCPConnection class]);
  JavaNioByteBuffer *buf = nil;
  @try {
    while (true) {
      buf = NetI2pRouterTransportNtcpEventPumper_acquireBuf(self);
      jint read = 0;
      jint readThisTime;
      jint readCount = 0;
      while ((readThisTime = [((JavaNioChannelsSocketChannel *) nil_chk([((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getChannel])) readWithJavaNioByteBuffer:buf]) > 0) {
        read += readThisTime;
        readCount++;
      }
      if (readThisTime < 0 && read == 0) read = readThisTime;
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldDebug]) [self->_log_ debugWithNSString:JreStrcat("$I$I$@", @"Read ", read, @" bytes total in ", readCount, @" times from ", con)];
      if (read < 0) {
        if ([con isInbound] && [con getMessagesReceived] <= 0) {
          JavaNetInetAddress *addr = [((JavaNetSocket *) nil_chk([((JavaNioChannelsSocketChannel *) nil_chk([con getChannel])) socket])) getInetAddress];
          jint count;
          if (addr != nil) {
            IOSByteArray *ip = [addr getAddress];
            NetI2pDataByteArray *ba = create_NetI2pDataByteArray_initWithByteArray_(ip);
            count = [((NetI2pUtilObjectCounter *) nil_chk(self->_blockedIPs_)) incrementWithId:ba];
            if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$$I$@", @"EOF on inbound before receiving any, blocking IP ", NetI2pUtilAddresses_toStringWithByteArray_(ip), @" with count ", count, @": ", con)];
          }
          else {
            count = 1;
            if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"EOF on inbound before receiving any: ", con)];
          }
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.dropInboundNoMessage" withLong:count];
        }
        else {
          if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$@", @"EOF on ", con)];
        }
        [con close];
        NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
        break;
      }
      if (read == 0) {
        NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
        jint consec = [con gotZeroRead];
        if (consec >= 5) {
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.zeroReadDrop" withLong:1];
          if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"Fail safe zero read close ", con)];
          [con close];
        }
        else {
          [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.zeroRead" withLong:consec];
          if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$@$", @"nothing to read for ", con, @", but stay interested")];
        }
        break;
      }
      [con clearZeroRead];
      jboolean keepReading = ![((JavaNioByteBuffer *) nil_chk(buf)) hasRemaining];
      [buf flip];
      id<NetI2pRouterTransportFIFOBandwidthLimiter_Request> req = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) bandwidthLimiter])) requestInboundWithInt:read withNSString:@"NTCP read"];
      if ([((id<NetI2pRouterTransportFIFOBandwidthLimiter_Request>) nil_chk(req)) getPendingRequested] > 0) {
        [key interestOpsWithInt:[key interestOps] & ~JavaNioChannelsSelectionKey_OP_READ];
        [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"ntcp.queuedRecv" withLong:read];
        [con queuedRecvWithJavaNioByteBuffer:buf withNetI2pRouterTransportFIFOBandwidthLimiter_Request:req];
        break;
      }
      else {
        [con recvWithJavaNioByteBuffer:buf];
        [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"ntcp.read" withLong:read];
        if (readThisTime < 0) {
          [con close];
          break;
        }
        if (!keepReading) break;
      }
    }
  }
  @catch (JavaNioChannelsCancelledKeyException *cke) {
    if (buf != nil) NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"error reading on ", con) withJavaLangThrowable:cke];
    [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) close];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.readError" withLong:1];
  }
  @catch (JavaIoIOException *ioe) {
    if (buf != nil) NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
    if ([((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) isInbound] && [con getMessagesReceived] <= 0) {
      JavaNetInetAddress *addr = [((JavaNetSocket *) nil_chk([((JavaNioChannelsSocketChannel *) nil_chk([con getChannel])) socket])) getInetAddress];
      jint count;
      if (addr != nil) {
        IOSByteArray *ip = [addr getAddress];
        NetI2pDataByteArray *ba = create_NetI2pDataByteArray_initWithByteArray_(ip);
        count = [((NetI2pUtilObjectCounter *) nil_chk(self->_blockedIPs_)) incrementWithId:ba];
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$$I$@", @"Blocking IP ", NetI2pUtilAddresses_toStringWithByteArray_(ip), @" with count ", count, @": ", con) withJavaLangThrowable:ioe];
      }
      else {
        count = 1;
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"IOE on inbound before receiving any: ", con) withJavaLangThrowable:ioe];
      }
      [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.dropInboundNoMessage" withLong:count];
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$@", @"error reading on ", con) withJavaLangThrowable:ioe];
    }
    if ([con isEstablished]) {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.readError" withLong:1];
    }
    else {
      [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectFailedTimeoutIOE" withLong:1];
      NetI2pDataRouterRouterIdentity *rem = [con getRemotePeer];
      if (rem != nil && ![con isInbound]) [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) markUnreachableWithNetI2pDataHash:[rem calculateHash]];
    }
    [con close];
  }
  @catch (JavaNioChannelsNotYetConnectedException *nyce) {
    if (buf != nil) NetI2pRouterTransportNtcpEventPumper_releaseBufWithJavaNioByteBuffer_(buf);
    [key interestOpsWithInt:[key interestOps] & ~JavaNioChannelsSelectionKey_OP_READ];
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"error reading on ", con) withJavaLangThrowable:nyce];
  }
}

void NetI2pRouterTransportNtcpEventPumper_processWriteWithJavaNioChannelsSelectionKey_(NetI2pRouterTransportNtcpEventPumper *self, JavaNioChannelsSelectionKey *key) {
  NetI2pRouterTransportNtcpNTCPConnection *con = (NetI2pRouterTransportNtcpNTCPConnection *) cast_chk([((JavaNioChannelsSelectionKey *) nil_chk(key)) attachment], [NetI2pRouterTransportNtcpNTCPConnection class]);
  @try {
    while (true) {
      JavaNioByteBuffer *buf = [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getNextWriteBuf];
      if (buf != nil) {
        if ([buf remaining] <= 0) {
          [con removeWriteBufWithJavaNioByteBuffer:buf];
          continue;
        }
        jint written = [((JavaNioChannelsSocketChannel *) nil_chk([con getChannel])) writeWithJavaNioByteBuffer:buf];
        if (written == 0) {
          if (([buf remaining] > 0) || (![con isWriteBufEmpty])) {
          }
          else {
            [key interestOpsWithInt:[key interestOps] & ~JavaNioChannelsSelectionKey_OP_WRITE];
          }
          break;
        }
        else if ([buf remaining] > 0) {
          break;
        }
        else {
          [con removeWriteBufWithJavaNioByteBuffer:buf];
        }
      }
      else {
        if ([key isValid]) [key interestOpsWithInt:[key interestOps] & ~JavaNioChannelsSelectionKey_OP_WRITE];
        break;
      }
    }
  }
  @catch (JavaNioChannelsCancelledKeyException *cke) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"error writing on ", con) withJavaLangThrowable:cke];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.writeError" withLong:1];
    [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) close];
  }
  @catch (JavaIoIOException *ioe) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@", @"error writing on ", con) withJavaLangThrowable:ioe];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.writeError" withLong:1];
    [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) close];
  }
}

void NetI2pRouterTransportNtcpEventPumper_runDelayedEvents(NetI2pRouterTransportNtcpEventPumper *self) {
  NetI2pRouterTransportNtcpNTCPConnection *con;
  while ((con = [((id<JavaUtilQueue>) nil_chk(self->_wantsRead_)) poll]) != nil) {
    JavaNioChannelsSelectionKey *key = [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getKey];
    @try {
      [((JavaNioChannelsSelectionKey *) nil_chk(key)) interestOpsWithInt:[key interestOps] | JavaNioChannelsSelectionKey_OP_READ];
    }
    @catch (JavaNioChannelsCancelledKeyException *cke) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"RDE CKE 1" withJavaLangThrowable:cke];
    }
    @catch (JavaLangIllegalArgumentException *iae) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"gnu?" withJavaLangThrowable:iae];
    }
  }
  if (![((id<JavaUtilSet>) nil_chk(self->_wantsWrite_)) isEmpty]) {
    for (id<JavaUtilIterator> iter = [self->_wantsWrite_ iterator]; [((id<JavaUtilIterator>) nil_chk(iter)) hasNext]; ) {
      con = [iter next];
      JavaNioChannelsSelectionKey *key = [((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getKey];
      if (key == nil) continue;
      [iter remove];
      @try {
        [key interestOpsWithInt:[key interestOps] | JavaNioChannelsSelectionKey_OP_WRITE];
      }
      @catch (JavaNioChannelsCancelledKeyException *cke) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"RDE CKE 2" withJavaLangThrowable:cke];
      }
      @catch (JavaLangIllegalArgumentException *iae) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"gnu?" withJavaLangThrowable:iae];
      }
    }
  }
  JavaNioChannelsServerSocketChannel *chan;
  while ((chan = [((id<JavaUtilQueue>) nil_chk(self->_wantsRegister_)) poll]) != nil) {
    @try {
      JavaNioChannelsSelectionKey *key = [((JavaNioChannelsServerSocketChannel *) nil_chk(chan)) register__WithJavaNioChannelsSelector:self->_selector_ withInt:JavaNioChannelsSelectionKey_OP_ACCEPT];
      [((JavaNioChannelsSelectionKey *) nil_chk(key)) attachWithId:chan];
    }
    @catch (JavaNioChannelsClosedChannelException *cce) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"Error registering" withJavaLangThrowable:cce];
    }
  }
  while ((con = [((id<JavaUtilQueue>) nil_chk(self->_wantsConRegister_)) poll]) != nil) {
    @try {
      JavaNioChannelsSelectionKey *key = [((JavaNioChannelsSocketChannel *) nil_chk([((NetI2pRouterTransportNtcpNTCPConnection *) nil_chk(con)) getChannel])) register__WithJavaNioChannelsSelector:self->_selector_ withInt:JavaNioChannelsSelectionKey_OP_CONNECT];
      [((JavaNioChannelsSelectionKey *) nil_chk(key)) attachWithId:con];
      [con setKeyWithJavaNioChannelsSelectionKey:key];
      NetI2pDataRouterRouterAddress *naddr = [con getRemoteAddress];
      @try {
        jint port = [((NetI2pDataRouterRouterAddress *) nil_chk(naddr)) getPort];
        IOSByteArray *ip = [naddr getIP];
        if (port <= 0 || ip == nil) @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"Invalid NTCP address: ", naddr));
        JavaNetInetSocketAddress *saddr = create_JavaNetInetSocketAddress_initWithJavaNetInetAddress_withInt_(JavaNetInetAddress_getByAddressWithByteArray_(ip), port);
        jboolean connected = [((JavaNioChannelsSocketChannel *) nil_chk([con getChannel])) connectWithJavaNetSocketAddress:saddr];
        if (connected) {
          [key interestOpsWithInt:JavaNioChannelsSelectionKey_OP_READ];
          NetI2pRouterTransportNtcpEventPumper_processConnectWithJavaNioChannelsSelectionKey_(self, key);
        }
      }
      @catch (JavaIoIOException *ioe) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$", @"error connecting to ", NetI2pUtilAddresses_toStringWithByteArray_withInt_([naddr getIP], [naddr getPort])) withJavaLangThrowable:ioe];
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectFailedIOE" withLong:1];
        [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) markUnreachableWithNetI2pDataHash:[((NetI2pDataRouterRouterIdentity *) nil_chk([con getRemotePeer])) calculateHash]];
        [con closeWithBoolean:true];
      }
      @catch (JavaNioChannelsUnresolvedAddressException *uae) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"unresolved address connecting" withJavaLangThrowable:uae];
        [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) statManager])) addRateDataWithNSString:@"ntcp.connectFailedUnresolved" withLong:1];
        [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) markUnreachableWithNetI2pDataHash:[((NetI2pDataRouterRouterIdentity *) nil_chk([con getRemotePeer])) calculateHash]];
        [con closeWithBoolean:true];
      }
      @catch (JavaNioChannelsCancelledKeyException *cke) {
        [con closeWithBoolean:false];
      }
    }
    @catch (JavaNioChannelsClosedChannelException *cce) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"Error registering" withJavaLangThrowable:cce];
    }
  }
  jlong now = JavaLangSystem_currentTimeMillis();
  if (self->_lastExpired_ + 1000 <= now) {
    NetI2pRouterTransportNtcpEventPumper_expireTimedOut(self);
    self->_lastExpired_ = now;
  }
}

void NetI2pRouterTransportNtcpEventPumper_expireTimedOut(NetI2pRouterTransportNtcpEventPumper *self) {
  [((NetI2pRouterTransportNtcpNTCPTransport *) nil_chk(self->_transport_)) expireTimedOut];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTransportNtcpEventPumper)

@implementation NetI2pRouterTransportNtcpEventPumper_BufferFactory

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (JavaNioByteBuffer *)newInstance {
  return JavaNioByteBuffer_allocateWithInt_(NetI2pRouterTransportNtcpEventPumper_BUF_SIZE);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(newInstance);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LNetI2pRouterTransportNtcpEventPumper;", "Ljava/lang/Object;Lnet/i2p/util/TryCache$ObjectFactory<Ljava/nio/ByteBuffer;>;" };
  static const J2ObjcClassInfo _NetI2pRouterTransportNtcpEventPumper_BufferFactory = { "BufferFactory", "net.i2p.router.transport.ntcp", ptrTable, methods, NULL, 7, 0xa, 2, 0, 0, -1, -1, 1, -1 };
  return &_NetI2pRouterTransportNtcpEventPumper_BufferFactory;
}

@end

void NetI2pRouterTransportNtcpEventPumper_BufferFactory_init(NetI2pRouterTransportNtcpEventPumper_BufferFactory *self) {
  NSObject_init(self);
}

NetI2pRouterTransportNtcpEventPumper_BufferFactory *new_NetI2pRouterTransportNtcpEventPumper_BufferFactory_init() {
  J2OBJC_NEW_IMPL(NetI2pRouterTransportNtcpEventPumper_BufferFactory, init)
}

NetI2pRouterTransportNtcpEventPumper_BufferFactory *create_NetI2pRouterTransportNtcpEventPumper_BufferFactory_init() {
  J2OBJC_CREATE_IMPL(NetI2pRouterTransportNtcpEventPumper_BufferFactory, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterTransportNtcpEventPumper_BufferFactory)
