//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/message/OutboundClientMessageJobHelper.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/util/Set.h"
#include "net/i2p/crypto/SessionKeyManager.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/Payload.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/data/i2np/DataMessage.h"
#include "net/i2p/data/i2np/DatabaseStoreMessage.h"
#include "net/i2p/data/i2np/DeliveryInstructions.h"
#include "net/i2p/data/i2np/DeliveryStatusMessage.h"
#include "net/i2p/data/i2np/GarlicMessage.h"
#include "net/i2p/data/i2np/I2NPMessage.h"
#include "net/i2p/router/ClientManagerFacade.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/TunnelInfo.h"
#include "net/i2p/router/message/GarlicConfig.h"
#include "net/i2p/router/message/GarlicMessageBuilder.h"
#include "net/i2p/router/message/OutboundClientMessageJobHelper.h"
#include "net/i2p/router/message/PayloadGarlicConfig.h"
#include "net/i2p/router/networkdb/kademlia/MessageWrapper.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"

@interface NetI2pRouterMessageOutboundClientMessageJobHelper ()

+ (NetI2pRouterMessageGarlicConfig *)createGarlicConfigWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                            withLong:(jlong)replyToken
                                                                            withLong:(jlong)expiration
                                                             withNetI2pDataPublicKey:(NetI2pDataPublicKey *)recipientPK
                                          withNetI2pRouterMessagePayloadGarlicConfig:(NetI2pRouterMessagePayloadGarlicConfig *)dataClove
                                                                  withNetI2pDataHash:(NetI2pDataHash *)from
                                                           withNetI2pDataDestination:(NetI2pDataDestination *)dest
                                                          withNetI2pRouterTunnelInfo:(id<NetI2pRouterTunnelInfo>)replyTunnel
                                                                         withBoolean:(jboolean)requireAck
                                                              withNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)bundledReplyLeaseSet
                                                   withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm;

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildAckCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                    withNetI2pDataHash:(NetI2pDataHash *)from
                                                            withNetI2pRouterTunnelInfo:(id<NetI2pRouterTunnelInfo>)replyToTunnel
                                                                              withLong:(jlong)replyToken
                                                                              withLong:(jlong)expiration
                                                     withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm;

+ (NetI2pDataI2npDeliveryStatusMessage *)buildDSMWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                      withLong:(jlong)replyToken;

+ (NetI2pDataI2npGarlicMessage *)wrapDSMWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                    withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm
                              withNetI2pDataI2npDeliveryStatusMessage:(NetI2pDataI2npDeliveryStatusMessage *)dsm;

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildDataCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                  withNetI2pDataPayload:(NetI2pDataPayload *)data
                                                              withNetI2pDataDestination:(NetI2pDataDestination *)dest
                                                                               withLong:(jlong)expiration;

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildLeaseSetCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                                   withLong:(jlong)expiration
                                                                     withNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)replyLeaseSet;

@end

inline jlong NetI2pRouterMessageOutboundClientMessageJobHelper_get_ACK_EXTRA_EXPIRATION(void);
#define NetI2pRouterMessageOutboundClientMessageJobHelper_ACK_EXTRA_EXPIRATION 60000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageJobHelper, ACK_EXTRA_EXPIRATION, jlong)

__attribute__((unused)) static NetI2pRouterMessageGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicConfigWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withBoolean_withNetI2pDataLeaseSet_withNetI2pCryptoSessionKeyManager_(NetI2pRouterRouterContext *ctx, jlong replyToken, jlong expiration, NetI2pDataPublicKey *recipientPK, NetI2pRouterMessagePayloadGarlicConfig *dataClove, NetI2pDataHash *from, NetI2pDataDestination *dest, id<NetI2pRouterTunnelInfo> replyTunnel, jboolean requireAck, NetI2pDataLeaseSet *bundledReplyLeaseSet, NetI2pCryptoSessionKeyManager *skm);

__attribute__((unused)) static NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildAckCloveWithNetI2pRouterRouterContext_withNetI2pDataHash_withNetI2pRouterTunnelInfo_withLong_withLong_withNetI2pCryptoSessionKeyManager_(NetI2pRouterRouterContext *ctx, NetI2pDataHash *from, id<NetI2pRouterTunnelInfo> replyToTunnel, jlong replyToken, jlong expiration, NetI2pCryptoSessionKeyManager *skm);

__attribute__((unused)) static NetI2pDataI2npDeliveryStatusMessage *NetI2pRouterMessageOutboundClientMessageJobHelper_buildDSMWithNetI2pRouterRouterContext_withLong_(NetI2pRouterRouterContext *ctx, jlong replyToken);

__attribute__((unused)) static NetI2pDataI2npGarlicMessage *NetI2pRouterMessageOutboundClientMessageJobHelper_wrapDSMWithNetI2pRouterRouterContext_withNetI2pCryptoSessionKeyManager_withNetI2pDataI2npDeliveryStatusMessage_(NetI2pRouterRouterContext *ctx, NetI2pCryptoSessionKeyManager *skm, NetI2pDataI2npDeliveryStatusMessage *dsm);

__attribute__((unused)) static NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildDataCloveWithNetI2pRouterRouterContext_withNetI2pDataPayload_withNetI2pDataDestination_withLong_(NetI2pRouterRouterContext *ctx, NetI2pDataPayload *data, NetI2pDataDestination *dest, jlong expiration);

__attribute__((unused)) static NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildLeaseSetCloveWithNetI2pRouterRouterContext_withLong_withNetI2pDataLeaseSet_(NetI2pRouterRouterContext *ctx, jlong expiration, NetI2pDataLeaseSet *replyLeaseSet);

@implementation NetI2pRouterMessageOutboundClientMessageJobHelper

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  NetI2pRouterMessageOutboundClientMessageJobHelper_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (NetI2pDataI2npGarlicMessage *)createGarlicMessageWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                         withLong:(jlong)replyToken
                                                                         withLong:(jlong)expiration
                                                          withNetI2pDataPublicKey:(NetI2pDataPublicKey *)recipientPK
                                       withNetI2pRouterMessagePayloadGarlicConfig:(NetI2pRouterMessagePayloadGarlicConfig *)dataClove
                                                               withNetI2pDataHash:(NetI2pDataHash *)from
                                                        withNetI2pDataDestination:(NetI2pDataDestination *)dest
                                                       withNetI2pRouterTunnelInfo:(id<NetI2pRouterTunnelInfo>)replyTunnel
                                                                          withInt:(jint)tagsToSendOverride
                                                                          withInt:(jint)lowTagsOverride
                                                         withNetI2pDataSessionKey:(NetI2pDataSessionKey *)wrappedKey
                                                                  withJavaUtilSet:(id<JavaUtilSet>)wrappedTags
                                                                      withBoolean:(jboolean)requireAck
                                                           withNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)bundledReplyLeaseSet {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicMessageWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withInt_withInt_withNetI2pDataSessionKey_withJavaUtilSet_withBoolean_withNetI2pDataLeaseSet_(ctx, replyToken, expiration, recipientPK, dataClove, from, dest, replyTunnel, tagsToSendOverride, lowTagsOverride, wrappedKey, wrappedTags, requireAck, bundledReplyLeaseSet);
}

+ (NetI2pRouterMessageGarlicConfig *)createGarlicConfigWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                            withLong:(jlong)replyToken
                                                                            withLong:(jlong)expiration
                                                             withNetI2pDataPublicKey:(NetI2pDataPublicKey *)recipientPK
                                          withNetI2pRouterMessagePayloadGarlicConfig:(NetI2pRouterMessagePayloadGarlicConfig *)dataClove
                                                                  withNetI2pDataHash:(NetI2pDataHash *)from
                                                           withNetI2pDataDestination:(NetI2pDataDestination *)dest
                                                          withNetI2pRouterTunnelInfo:(id<NetI2pRouterTunnelInfo>)replyTunnel
                                                                         withBoolean:(jboolean)requireAck
                                                              withNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)bundledReplyLeaseSet
                                                   withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicConfigWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withBoolean_withNetI2pDataLeaseSet_withNetI2pCryptoSessionKeyManager_(ctx, replyToken, expiration, recipientPK, dataClove, from, dest, replyTunnel, requireAck, bundledReplyLeaseSet, skm);
}

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildAckCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                    withNetI2pDataHash:(NetI2pDataHash *)from
                                                            withNetI2pRouterTunnelInfo:(id<NetI2pRouterTunnelInfo>)replyToTunnel
                                                                              withLong:(jlong)replyToken
                                                                              withLong:(jlong)expiration
                                                     withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_buildAckCloveWithNetI2pRouterRouterContext_withNetI2pDataHash_withNetI2pRouterTunnelInfo_withLong_withLong_withNetI2pCryptoSessionKeyManager_(ctx, from, replyToTunnel, replyToken, expiration, skm);
}

+ (NetI2pDataI2npDeliveryStatusMessage *)buildDSMWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                      withLong:(jlong)replyToken {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_buildDSMWithNetI2pRouterRouterContext_withLong_(ctx, replyToken);
}

+ (NetI2pDataI2npGarlicMessage *)wrapDSMWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                    withNetI2pCryptoSessionKeyManager:(NetI2pCryptoSessionKeyManager *)skm
                              withNetI2pDataI2npDeliveryStatusMessage:(NetI2pDataI2npDeliveryStatusMessage *)dsm {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_wrapDSMWithNetI2pRouterRouterContext_withNetI2pCryptoSessionKeyManager_withNetI2pDataI2npDeliveryStatusMessage_(ctx, skm, dsm);
}

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildDataCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                  withNetI2pDataPayload:(NetI2pDataPayload *)data
                                                              withNetI2pDataDestination:(NetI2pDataDestination *)dest
                                                                               withLong:(jlong)expiration {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_buildDataCloveWithNetI2pRouterRouterContext_withNetI2pDataPayload_withNetI2pDataDestination_withLong_(ctx, data, dest, expiration);
}

+ (NetI2pRouterMessagePayloadGarlicConfig *)buildLeaseSetCloveWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                                                                   withLong:(jlong)expiration
                                                                     withNetI2pDataLeaseSet:(NetI2pDataLeaseSet *)replyLeaseSet {
  return NetI2pRouterMessageOutboundClientMessageJobHelper_buildLeaseSetCloveWithNetI2pRouterRouterContext_withLong_withNetI2pDataLeaseSet_(ctx, expiration, replyLeaseSet);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataI2npGarlicMessage;", 0x8, 0, 1, -1, 2, -1, -1 },
    { NULL, "LNetI2pRouterMessageGarlicConfig;", 0xa, 3, 4, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterMessagePayloadGarlicConfig;", 0xa, 5, 6, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataI2npDeliveryStatusMessage;", 0xa, 7, 8, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataI2npGarlicMessage;", 0xa, 9, 10, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterMessagePayloadGarlicConfig;", 0xa, 11, 12, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterMessagePayloadGarlicConfig;", 0xa, 13, 14, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(createGarlicMessageWithNetI2pRouterRouterContext:withLong:withLong:withNetI2pDataPublicKey:withNetI2pRouterMessagePayloadGarlicConfig:withNetI2pDataHash:withNetI2pDataDestination:withNetI2pRouterTunnelInfo:withInt:withInt:withNetI2pDataSessionKey:withJavaUtilSet:withBoolean:withNetI2pDataLeaseSet:);
  methods[2].selector = @selector(createGarlicConfigWithNetI2pRouterRouterContext:withLong:withLong:withNetI2pDataPublicKey:withNetI2pRouterMessagePayloadGarlicConfig:withNetI2pDataHash:withNetI2pDataDestination:withNetI2pRouterTunnelInfo:withBoolean:withNetI2pDataLeaseSet:withNetI2pCryptoSessionKeyManager:);
  methods[3].selector = @selector(buildAckCloveWithNetI2pRouterRouterContext:withNetI2pDataHash:withNetI2pRouterTunnelInfo:withLong:withLong:withNetI2pCryptoSessionKeyManager:);
  methods[4].selector = @selector(buildDSMWithNetI2pRouterRouterContext:withLong:);
  methods[5].selector = @selector(wrapDSMWithNetI2pRouterRouterContext:withNetI2pCryptoSessionKeyManager:withNetI2pDataI2npDeliveryStatusMessage:);
  methods[6].selector = @selector(buildDataCloveWithNetI2pRouterRouterContext:withNetI2pDataPayload:withNetI2pDataDestination:withLong:);
  methods[7].selector = @selector(buildLeaseSetCloveWithNetI2pRouterRouterContext:withLong:withNetI2pDataLeaseSet:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ACK_EXTRA_EXPIRATION", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageJobHelper_ACK_EXTRA_EXPIRATION, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "createGarlicMessage", "LNetI2pRouterRouterContext;JJLNetI2pDataPublicKey;LNetI2pRouterMessagePayloadGarlicConfig;LNetI2pDataHash;LNetI2pDataDestination;LNetI2pRouterTunnelInfo;IILNetI2pDataSessionKey;LJavaUtilSet;ZLNetI2pDataLeaseSet;", "(Lnet/i2p/router/RouterContext;JJLnet/i2p/data/PublicKey;Lnet/i2p/router/message/PayloadGarlicConfig;Lnet/i2p/data/Hash;Lnet/i2p/data/Destination;Lnet/i2p/router/TunnelInfo;IILnet/i2p/data/SessionKey;Ljava/util/Set<Lnet/i2p/data/SessionTag;>;ZLnet/i2p/data/LeaseSet;)Lnet/i2p/data/i2np/GarlicMessage;", "createGarlicConfig", "LNetI2pRouterRouterContext;JJLNetI2pDataPublicKey;LNetI2pRouterMessagePayloadGarlicConfig;LNetI2pDataHash;LNetI2pDataDestination;LNetI2pRouterTunnelInfo;ZLNetI2pDataLeaseSet;LNetI2pCryptoSessionKeyManager;", "buildAckClove", "LNetI2pRouterRouterContext;LNetI2pDataHash;LNetI2pRouterTunnelInfo;JJLNetI2pCryptoSessionKeyManager;", "buildDSM", "LNetI2pRouterRouterContext;J", "wrapDSM", "LNetI2pRouterRouterContext;LNetI2pCryptoSessionKeyManager;LNetI2pDataI2npDeliveryStatusMessage;", "buildDataClove", "LNetI2pRouterRouterContext;LNetI2pDataPayload;LNetI2pDataDestination;J", "buildLeaseSetClove", "LNetI2pRouterRouterContext;JLNetI2pDataLeaseSet;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageJobHelper = { "OutboundClientMessageJobHelper", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x0, 8, 1, -1, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageJobHelper;
}

@end

void NetI2pRouterMessageOutboundClientMessageJobHelper_init(NetI2pRouterMessageOutboundClientMessageJobHelper *self) {
  NSObject_init(self);
}

NetI2pRouterMessageOutboundClientMessageJobHelper *new_NetI2pRouterMessageOutboundClientMessageJobHelper_init() {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageJobHelper, init)
}

NetI2pRouterMessageOutboundClientMessageJobHelper *create_NetI2pRouterMessageOutboundClientMessageJobHelper_init() {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageJobHelper, init)
}

NetI2pDataI2npGarlicMessage *NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicMessageWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withInt_withInt_withNetI2pDataSessionKey_withJavaUtilSet_withBoolean_withNetI2pDataLeaseSet_(NetI2pRouterRouterContext *ctx, jlong replyToken, jlong expiration, NetI2pDataPublicKey *recipientPK, NetI2pRouterMessagePayloadGarlicConfig *dataClove, NetI2pDataHash *from, NetI2pDataDestination *dest, id<NetI2pRouterTunnelInfo> replyTunnel, jint tagsToSendOverride, jint lowTagsOverride, NetI2pDataSessionKey *wrappedKey, id<JavaUtilSet> wrappedTags, jboolean requireAck, NetI2pDataLeaseSet *bundledReplyLeaseSet) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pCryptoSessionKeyManager *skm = [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) clientManager])) getClientSessionKeyManagerWithNetI2pDataHash:from];
  if (skm == nil) return nil;
  NetI2pRouterMessageGarlicConfig *config = NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicConfigWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withBoolean_withNetI2pDataLeaseSet_withNetI2pCryptoSessionKeyManager_(ctx, replyToken, expiration, recipientPK, dataClove, from, dest, replyTunnel, requireAck, bundledReplyLeaseSet, skm);
  if (config == nil) return nil;
  jint tagsToSend = replyToken >= 0 ? (tagsToSendOverride > 0 ? tagsToSendOverride : [skm getTagsToSend]) : 0;
  jint lowThreshold = lowTagsOverride > 0 ? lowTagsOverride : [skm getLowThreshold];
  NetI2pDataI2npGarlicMessage *msg = NetI2pRouterMessageGarlicMessageBuilder_buildMessageWithNetI2pRouterRouterContext_withNetI2pRouterMessageGarlicConfig_withNetI2pDataSessionKey_withJavaUtilSet_withInt_withInt_withNetI2pCryptoSessionKeyManager_(ctx, config, wrappedKey, wrappedTags, tagsToSend, lowThreshold, skm);
  return msg;
}

NetI2pRouterMessageGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicConfigWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withBoolean_withNetI2pDataLeaseSet_withNetI2pCryptoSessionKeyManager_(NetI2pRouterRouterContext *ctx, jlong replyToken, jlong expiration, NetI2pDataPublicKey *recipientPK, NetI2pRouterMessagePayloadGarlicConfig *dataClove, NetI2pDataHash *from, NetI2pDataDestination *dest, id<NetI2pRouterTunnelInfo> replyTunnel, jboolean requireAck, NetI2pDataLeaseSet *bundledReplyLeaseSet, NetI2pCryptoSessionKeyManager *skm) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) logManager])) getLogWithIOSClass:NetI2pRouterMessageOutboundClientMessageJobHelper_class_()];
  if (replyToken >= 0 && [((NetI2pUtilLog *) nil_chk(log)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [((NetI2pUtilLog *) nil_chk(log)) debugWithNSString:JreStrcat("$J", @"Reply token: ", replyToken)];
  NetI2pRouterMessageGarlicConfig *config = create_NetI2pRouterMessageGarlicConfig_init();
  if (requireAck) {
    NetI2pRouterMessagePayloadGarlicConfig *ackClove = NetI2pRouterMessageOutboundClientMessageJobHelper_buildAckCloveWithNetI2pRouterRouterContext_withNetI2pDataHash_withNetI2pRouterTunnelInfo_withLong_withLong_withNetI2pCryptoSessionKeyManager_(ctx, from, replyTunnel, replyToken, expiration + NetI2pRouterMessageOutboundClientMessageJobHelper_ACK_EXTRA_EXPIRATION, skm);
    if (ackClove == nil) return nil;
    [config addCloveWithNetI2pRouterMessageGarlicConfig:ackClove];
  }
  if (bundledReplyLeaseSet != nil) {
    NetI2pRouterMessagePayloadGarlicConfig *leaseSetClove = NetI2pRouterMessageOutboundClientMessageJobHelper_buildLeaseSetCloveWithNetI2pRouterRouterContext_withLong_withNetI2pDataLeaseSet_(ctx, expiration, bundledReplyLeaseSet);
    [config addCloveWithNetI2pRouterMessageGarlicConfig:leaseSetClove];
  }
  [config addCloveWithNetI2pRouterMessageGarlicConfig:dataClove];
  [config setCertificateWithNetI2pDataCertificate:JreLoadStatic(NetI2pDataCertificate, NULL_CERT)];
  [config setDeliveryInstructionsWithNetI2pDataI2npDeliveryInstructions:JreLoadStatic(NetI2pDataI2npDeliveryInstructions, LOCAL)];
  [config setIdWithLong:[((NetI2pUtilRandomSource *) nil_chk([ctx random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE]];
  [config setExpirationWithLong:expiration];
  [config setRecipientPublicKeyWithNetI2pDataPublicKey:recipientPK];
  if ([((NetI2pUtilLog *) nil_chk(log)) shouldLogWithInt:NetI2pUtilLog_INFO]) [log infoWithNSString:JreStrcat("$@$$", @"Creating garlic config to be encrypted to ", recipientPK, @" for destination ", [((NetI2pDataHash *) nil_chk([((NetI2pDataDestination *) nil_chk(dest)) calculateHash])) toBase64])];
  return config;
}

NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildAckCloveWithNetI2pRouterRouterContext_withNetI2pDataHash_withNetI2pRouterTunnelInfo_withLong_withLong_withNetI2pCryptoSessionKeyManager_(NetI2pRouterRouterContext *ctx, NetI2pDataHash *from, id<NetI2pRouterTunnelInfo> replyToTunnel, jlong replyToken, jlong expiration, NetI2pCryptoSessionKeyManager *skm) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pUtilLog *log = [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) logManager])) getLogWithIOSClass:NetI2pRouterMessageOutboundClientMessageJobHelper_class_()];
  if (replyToTunnel == nil) {
    if ([((NetI2pUtilLog *) nil_chk(log)) shouldLogWithInt:NetI2pUtilLog_WARN]) [log warnWithNSString:JreStrcat("$$$", @"Unable to send client message from ", [((NetI2pDataHash *) nil_chk(from)) toBase64], @", as there are no inbound tunnels available")];
    return nil;
  }
  NetI2pDataTunnelId *replyToTunnelId = [replyToTunnel getReceiveTunnelIdWithInt:0];
  NetI2pDataHash *replyToTunnelRouter = [replyToTunnel getPeerWithInt:0];
  if ([((NetI2pUtilLog *) nil_chk(log)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [log debugWithNSString:JreStrcat("$@$@", @"Ack for the data message will come back along tunnel ", replyToTunnelId, @": ", replyToTunnel)];
  NetI2pDataI2npDeliveryInstructions *ackInstructions = create_NetI2pDataI2npDeliveryInstructions_init();
  [ackInstructions setDeliveryModeWithInt:NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_TUNNEL];
  [ackInstructions setRouterWithNetI2pDataHash:replyToTunnelRouter];
  [ackInstructions setTunnelIdWithNetI2pDataTunnelId:replyToTunnelId];
  NetI2pRouterMessagePayloadGarlicConfig *ackClove = create_NetI2pRouterMessagePayloadGarlicConfig_init();
  [ackClove setCertificateWithNetI2pDataCertificate:JreLoadStatic(NetI2pDataCertificate, NULL_CERT)];
  [ackClove setDeliveryInstructionsWithNetI2pDataI2npDeliveryInstructions:ackInstructions];
  [ackClove setExpirationWithLong:expiration];
  [ackClove setIdWithLong:[((NetI2pUtilRandomSource *) nil_chk([ctx random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE]];
  NetI2pDataI2npDeliveryStatusMessage *dsm = NetI2pRouterMessageOutboundClientMessageJobHelper_buildDSMWithNetI2pRouterRouterContext_withLong_(ctx, replyToken);
  NetI2pDataI2npGarlicMessage *msg = NetI2pRouterMessageOutboundClientMessageJobHelper_wrapDSMWithNetI2pRouterRouterContext_withNetI2pCryptoSessionKeyManager_withNetI2pDataI2npDeliveryStatusMessage_(ctx, skm, dsm);
  if (msg == nil) {
    if ([log shouldLogWithInt:NetI2pUtilLog_WARN]) [log warnWithNSString:@"Failed to wrap ack clove"];
    return nil;
  }
  [ackClove setPayloadWithNetI2pDataI2npI2NPMessage:msg];
  return ackClove;
}

NetI2pDataI2npDeliveryStatusMessage *NetI2pRouterMessageOutboundClientMessageJobHelper_buildDSMWithNetI2pRouterRouterContext_withLong_(NetI2pRouterRouterContext *ctx, jlong replyToken) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pDataI2npDeliveryStatusMessage *msg = create_NetI2pDataI2npDeliveryStatusMessage_initWithNetI2pI2PAppContext_(ctx);
  [msg setArrivalWithLong:[((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) clock])) now]];
  [msg setMessageIdWithLong:replyToken];
  return msg;
}

NetI2pDataI2npGarlicMessage *NetI2pRouterMessageOutboundClientMessageJobHelper_wrapDSMWithNetI2pRouterRouterContext_withNetI2pCryptoSessionKeyManager_withNetI2pDataI2npDeliveryStatusMessage_(NetI2pRouterRouterContext *ctx, NetI2pCryptoSessionKeyManager *skm, NetI2pDataI2npDeliveryStatusMessage *dsm) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pRouterNetworkdbKademliaMessageWrapper_OneTimeSession *sess = NetI2pRouterNetworkdbKademliaMessageWrapper_generateSessionWithNetI2pRouterRouterContext_withNetI2pCryptoSessionKeyManager_(ctx, skm);
  NetI2pDataI2npGarlicMessage *msg = NetI2pRouterNetworkdbKademliaMessageWrapper_wrapWithNetI2pRouterRouterContext_withNetI2pDataI2npI2NPMessage_withNetI2pRouterNetworkdbKademliaMessageWrapper_OneTimeSession_(ctx, dsm, sess);
  return msg;
}

NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildDataCloveWithNetI2pRouterRouterContext_withNetI2pDataPayload_withNetI2pDataDestination_withLong_(NetI2pRouterRouterContext *ctx, NetI2pDataPayload *data, NetI2pDataDestination *dest, jlong expiration) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pDataI2npDeliveryInstructions *instructions = create_NetI2pDataI2npDeliveryInstructions_init();
  [instructions setDeliveryModeWithInt:NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_DESTINATION];
  [instructions setDestinationWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(dest)) calculateHash]];
  NetI2pRouterMessagePayloadGarlicConfig *clove = create_NetI2pRouterMessagePayloadGarlicConfig_init();
  [clove setCertificateWithNetI2pDataCertificate:JreLoadStatic(NetI2pDataCertificate, NULL_CERT)];
  [clove setDeliveryInstructionsWithNetI2pDataI2npDeliveryInstructions:instructions];
  [clove setExpirationWithLong:expiration];
  [clove setIdWithLong:[((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE]];
  NetI2pDataI2npDataMessage *msg = create_NetI2pDataI2npDataMessage_initWithNetI2pI2PAppContext_(ctx);
  [msg setDataWithByteArray:[((NetI2pDataPayload *) nil_chk(data)) getEncryptedData]];
  [clove setPayloadWithNetI2pDataI2npI2NPMessage:msg];
  return clove;
}

NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageJobHelper_buildLeaseSetCloveWithNetI2pRouterRouterContext_withLong_withNetI2pDataLeaseSet_(NetI2pRouterRouterContext *ctx, jlong expiration, NetI2pDataLeaseSet *replyLeaseSet) {
  NetI2pRouterMessageOutboundClientMessageJobHelper_initialize();
  NetI2pRouterMessagePayloadGarlicConfig *clove = create_NetI2pRouterMessagePayloadGarlicConfig_init();
  [clove setCertificateWithNetI2pDataCertificate:JreLoadStatic(NetI2pDataCertificate, NULL_CERT)];
  [clove setDeliveryInstructionsWithNetI2pDataI2npDeliveryInstructions:JreLoadStatic(NetI2pDataI2npDeliveryInstructions, LOCAL)];
  [clove setExpirationWithLong:expiration];
  [clove setIdWithLong:[((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE]];
  NetI2pDataI2npDatabaseStoreMessage *msg = create_NetI2pDataI2npDatabaseStoreMessage_initWithNetI2pI2PAppContext_(ctx);
  [msg setEntryWithNetI2pDataDatabaseEntry:replyLeaseSet];
  [msg setMessageExpirationWithLong:expiration];
  [clove setPayloadWithNetI2pDataI2npI2NPMessage:msg];
  return clove;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageJobHelper)
