//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/message/OutboundClientMessageOneShotJob.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/NumberFormatException.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/Date.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Properties.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "net/i2p/client/SendMessageOptions.h"
#include "net/i2p/crypto/SessionKeyManager.h"
#include "net/i2p/crypto/TagSetHandle.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/Lease.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/Payload.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/SessionKey.h"
#include "net/i2p/data/TunnelId.h"
#include "net/i2p/data/i2cp/MessageId.h"
#include "net/i2p/data/i2cp/MessageStatusMessage.h"
#include "net/i2p/data/i2cp/SessionConfig.h"
#include "net/i2p/data/i2np/DataMessage.h"
#include "net/i2p/data/i2np/DeliveryInstructions.h"
#include "net/i2p/data/i2np/DeliveryStatusMessage.h"
#include "net/i2p/data/i2np/GarlicMessage.h"
#include "net/i2p/data/i2np/I2NPMessage.h"
#include "net/i2p/data/router/RouterInfo.h"
#include "net/i2p/router/ClientManagerFacade.h"
#include "net/i2p/router/ClientMessage.h"
#include "net/i2p/router/CommSystemFacade.h"
#include "net/i2p/router/JobImpl.h"
#include "net/i2p/router/JobQueue.h"
#include "net/i2p/router/JobTiming.h"
#include "net/i2p/router/MessageHistory.h"
#include "net/i2p/router/MessageSelector.h"
#include "net/i2p/router/NetworkDatabaseFacade.h"
#include "net/i2p/router/OutNetMessage.h"
#include "net/i2p/router/ProfileManager.h"
#include "net/i2p/router/ReplyJob.h"
#include "net/i2p/router/Router.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/RouterThrottle.h"
#include "net/i2p/router/TunnelInfo.h"
#include "net/i2p/router/TunnelManagerFacade.h"
#include "net/i2p/router/message/GarlicMessageBuilder.h"
#include "net/i2p/router/message/OutboundCache.h"
#include "net/i2p/router/message/OutboundClientMessageJobHelper.h"
#include "net/i2p/router/message/OutboundClientMessageOneShotJob.h"
#include "net/i2p/router/message/PayloadGarlicConfig.h"
#include "net/i2p/router/transport/OutboundMessageRegistry.h"
#include "net/i2p/router/tunnel/TunnelDispatcher.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"

@class NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector;
@class NetI2pRouterMessageOutboundClientMessageOneShotJob_Result;
@class NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob;
@class NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob;

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob () {
 @public
  NetI2pUtilLog *_log_;
  NetI2pRouterMessageOutboundCache *_cache_;
  jlong _overallExpiration_;
  NetI2pRouterClientMessage *_clientMessage_;
  NetI2pDataI2cpMessageId *_clientMessageId_;
  jint _clientMessageSize_;
  NetI2pDataDestination *_from_;
  NetI2pDataDestination *_to_;
  NSString *_toString_;
  NetI2pDataLeaseSet *_leaseSet_;
  NetI2pDataLease *_lease_;
  jlong _start_;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *_finished_;
  jlong _leaseSetLookupBegin_;
  id<NetI2pRouterTunnelInfo> _outTunnel_;
  id<NetI2pRouterTunnelInfo> _inTunnel_;
  jboolean _wantACK_;
  NetI2pRouterMessageOutboundCache_HashPair *_hashPair_;
}

- (NetI2pDataLeaseSet *)getReplyLeaseSetWithBoolean:(jboolean)force;

- (jboolean)getNextLease;

- (void)send;

- (void)clearCaches;

- (id<NetI2pRouterTunnelInfo>)selectOutboundTunnelWithNetI2pDataDestination:(NetI2pDataDestination *)to;

- (id<NetI2pRouterTunnelInfo>)selectOutboundTunnel;

- (id<NetI2pRouterTunnelInfo>)selectInboundTunnel;

- (void)dieFatalWithInt:(jint)status;

- (NetI2pRouterMessagePayloadGarlicConfig *)buildClove;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _cache_, NetI2pRouterMessageOutboundCache *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _clientMessage_, NetI2pRouterClientMessage *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _clientMessageId_, NetI2pDataI2cpMessageId *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _from_, NetI2pDataDestination *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _to_, NetI2pDataDestination *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _toString_, NSString *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _leaseSet_, NetI2pDataLeaseSet *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _lease_, NetI2pDataLease *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _finished_, NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _outTunnel_, id<NetI2pRouterTunnelInfo>)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _inTunnel_, id<NetI2pRouterTunnelInfo>)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob, _hashPair_, NetI2pRouterMessageOutboundCache_HashPair *)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_OVERALL_TIMEOUT_MS_DEFAULT(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT 60000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, OVERALL_TIMEOUT_MS_DEFAULT, jlong)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_OVERALL_TIMEOUT_MS_MIN(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MIN 8000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, OVERALL_TIMEOUT_MS_MIN, jlong)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_OVERALL_TIMEOUT_MS_MAX(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MAX 90000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, OVERALL_TIMEOUT_MS_MAX, jlong)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_LS_LOOKUP_TIMEOUT(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_LS_LOOKUP_TIMEOUT 15000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, LS_LOOKUP_TIMEOUT, jlong)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_OVERALL_TIMEOUT_NOLS_MIN(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_NOLS_MIN 23000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, OVERALL_TIMEOUT_NOLS_MIN, jlong)

inline jlong NetI2pRouterMessageOutboundClientMessageOneShotJob_get_REPLY_TIMEOUT_MS_MIN(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_TIMEOUT_MS_MIN 55000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, REPLY_TIMEOUT_MS_MIN, jlong)

inline jint NetI2pRouterMessageOutboundClientMessageOneShotJob_get_REPLY_REQUEST_INTERVAL(void);
#define NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_REQUEST_INTERVAL 60000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob, REPLY_REQUEST_INTERVAL, jint)

__attribute__((unused)) static NetI2pDataLeaseSet *NetI2pRouterMessageOutboundClientMessageOneShotJob_getReplyLeaseSetWithBoolean_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, jboolean force);

__attribute__((unused)) static jboolean NetI2pRouterMessageOutboundClientMessageOneShotJob_getNextLease(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_send(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_clearCaches(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

__attribute__((unused)) static id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnelWithNetI2pDataDestination_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, NetI2pDataDestination *to);

__attribute__((unused)) static id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnel(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

__attribute__((unused)) static id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectInboundTunnel(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, jint status);

__attribute__((unused)) static NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageOneShotJob_buildClove(NetI2pRouterMessageOutboundClientMessageOneShotJob *self);

typedef NS_ENUM(NSUInteger, NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum) {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum_NONE = 0,
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum_FAIL = 1,
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum_SUCCESS = 2,
};

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_Result : JavaLangEnum

@property (readonly, class, nonnull) NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NONE NS_SWIFT_NAME(NONE);
@property (readonly, class, nonnull) NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *FAIL NS_SWIFT_NAME(FAIL);
@property (readonly, class, nonnull) NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *SUCCESS NS_SWIFT_NAME(SUCCESS);
+ (IOSObjectArray *)values;

+ (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)valueOfWithNSString:(NSString *)name;

- (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_[];

inline NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_get_NONE(void);
J2OBJC_ENUM_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE)

inline NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_get_FAIL(void);
J2OBJC_ENUM_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, FAIL)

inline NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_get_SUCCESS(void);
J2OBJC_ENUM_CONSTANT(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initWithNSString_withInt_(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *self, NSString *__name, jint __ordinal);

__attribute__((unused)) static IOSObjectArray *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values(void);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob : NetI2pRouterJobImpl {
 @public
  NetI2pRouterMessageOutboundClientMessageOneShotJob *this$0_;
}

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext;

- (NSString *)getName;

- (void)runJob;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob : NetI2pRouterJobImpl {
 @public
  NetI2pRouterMessageOutboundClientMessageOneShotJob *this$0_;
}

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext;

- (NSString *)getName;

- (void)runJob;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob : NetI2pRouterJobImpl {
 @public
  NetI2pRouterMessageOutboundClientMessageOneShotJob *this$0_;
  NetI2pDataI2npGarlicMessage *_msg_;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *_selector_;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *_replyFound_;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *_replyTimeout_;
}

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                           withNetI2pDataI2npGarlicMessage:(NetI2pDataI2npGarlicMessage *)msg
      withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector:(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *)sel
     withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *)success
     withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *)timeout;

- (NSString *)getName;

- (void)runJob;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob)

J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, _msg_, NetI2pDataI2npGarlicMessage *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, _selector_, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, _replyFound_, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, _replyTimeout_, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector : NSObject < NetI2pRouterMessageSelector > {
 @public
  jlong _pendingToken_;
  jlong _expiration_;
}

- (instancetype)initWithLong:(jlong)token
                    withLong:(jlong)expiration;

- (jboolean)continueMatching;

- (jlong)getExpiration;

- (jboolean)isMatchWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)inMsg;

- (NSString *)description;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *self, jlong token, jlong expiration);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(jlong token, jlong expiration) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(jlong token, jlong expiration);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob : NetI2pRouterJobImpl < NetI2pRouterReplyJob > {
 @public
  NetI2pRouterMessageOutboundClientMessageOneShotJob *this$0_;
  NetI2pDataSessionKey *_key_;
  id<NetI2pCryptoTagSetHandle> _tags_;
}

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext
                                                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                              withNetI2pCryptoTagSetHandle:(id<NetI2pCryptoTagSetHandle>)tags;

- (NSString *)getName;

- (void)runJob;

- (void)setMessageWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob)

J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob, _key_, NetI2pDataSessionKey *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob, _tags_, id<NetI2pCryptoTagSetHandle>)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob)

@interface NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob : NetI2pRouterJobImpl {
 @public
  NetI2pRouterMessageOutboundClientMessageOneShotJob *this$0_;
  NetI2pDataSessionKey *_key_;
  id<NetI2pCryptoTagSetHandle> _tags_;
}

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext
                                                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                              withNetI2pCryptoTagSetHandle:(id<NetI2pCryptoTagSetHandle>)tags;

- (NSString *)getName;

- (void)runJob;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob)

J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob, _key_, NetI2pDataSessionKey *)
J2OBJC_FIELD_SETTER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob, _tags_, id<NetI2pCryptoTagSetHandle>)

__attribute__((unused)) static void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags);

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob)

NSString *NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_PARAM = @"clientMessageTimeout";
NSString *NetI2pRouterMessageOutboundClientMessageOneShotJob_BUNDLE_REPLY_LEASESET = @"shouldBundleReplyInfo";

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob

+ (NSString *)OVERALL_TIMEOUT_MS_PARAM {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_PARAM;
}

+ (NSString *)BUNDLE_REPLY_LEASESET {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_BUNDLE_REPLY_LEASESET;
}

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
             withNetI2pRouterMessageOutboundCache:(NetI2pRouterMessageOutboundCache *)cache
                    withNetI2pRouterClientMessage:(NetI2pRouterClientMessage *)msg {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_(self, ctx, cache, msg);
  return self;
}

+ (void)init__WithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_init__WithNetI2pRouterRouterContext_(ctx);
}

- (NSString *)getName {
  return @"Outbound client message";
}

- (void)runJob {
  jlong now = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now];
  if (now >= _overallExpiration_) {
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_EXPIRED);
    return;
  }
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *success = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(self, [self getContext]);
  if (_leaseSet_ != nil) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("J$$", [self getJobId], @": Send outbound client message - leaseSet found locally for ", _toString_)];
    if (![((NetI2pDataLeaseSet *) nil_chk(_leaseSet_)) isCurrentWithLong:NetI2pRouterRouter_CLOCK_FUDGE_FACTOR / 4]) {
      if ([_log_ shouldWarn]) {
        jlong exp = now - [((NetI2pDataLeaseSet *) nil_chk(_leaseSet_)) getLatestLeaseDate];
        [_log_ warnWithNSString:JreStrcat("J$$$$", [self getJobId], @": leaseSet expired ", NetI2pDataDataHelper_formatDurationWithLong_(exp), @" ago, firing search: ", [((NetI2pDataHash *) nil_chk([((NetI2pDataLeaseSet *) nil_chk(_leaseSet_)) getHash])) toBase32])];
      }
      [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) lookupLeaseSetRemotelyWithNetI2pDataHash:[((NetI2pDataLeaseSet *) nil_chk(_leaseSet_)) getHash] withNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(_from_)) calculateHash]];
    }
    [success runJob];
  }
  else {
    _leaseSetLookupBegin_ = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now];
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("J$$", [self getJobId], @": Send outbound client message - sending off leaseSet lookup job for ", _toString_)];
    NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *failed = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(self, [self getContext]);
    NetI2pDataHash *key = [((NetI2pDataDestination *) nil_chk(_to_)) calculateHash];
    [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) lookupLeaseSetWithNetI2pDataHash:key withNetI2pRouterJob:success withNetI2pRouterJob:failed withLong:NetI2pRouterMessageOutboundClientMessageOneShotJob_LS_LOOKUP_TIMEOUT withNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(_from_)) calculateHash]];
  }
}

- (NetI2pDataLeaseSet *)getReplyLeaseSetWithBoolean:(jboolean)force {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_getReplyLeaseSetWithBoolean_(self, force);
}

- (jboolean)getNextLease {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_getNextLease(self);
}

- (void)send {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_send(self);
}

- (void)clearCaches {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_clearCaches(self);
}

- (id<NetI2pRouterTunnelInfo>)selectOutboundTunnelWithNetI2pDataDestination:(NetI2pDataDestination *)to {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnelWithNetI2pDataDestination_(self, to);
}

- (id<NetI2pRouterTunnelInfo>)selectOutboundTunnel {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnel(self);
}

- (id<NetI2pRouterTunnelInfo>)selectInboundTunnel {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_selectInboundTunnel(self);
}

- (void)dieFatalWithInt:(jint)status {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, status);
}

- (NetI2pRouterMessagePayloadGarlicConfig *)buildClove {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_buildClove(self);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_cache_);
  RELEASE_(_clientMessage_);
  RELEASE_(_clientMessageId_);
  RELEASE_(_from_);
  RELEASE_(_to_);
  RELEASE_(_toString_);
  RELEASE_(_leaseSet_);
  RELEASE_(_lease_);
  RELEASE_(_finished_);
  RELEASE_(_outTunnel_);
  RELEASE_(_inTunnel_);
  RELEASE_(_hashPair_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pDataLeaseSet;", 0x2, 3, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelInfo;", 0x2, 5, 6, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelInfo;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterTunnelInfo;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 8, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterMessagePayloadGarlicConfig;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:withNetI2pRouterMessageOutboundCache:withNetI2pRouterClientMessage:);
  methods[1].selector = @selector(init__WithNetI2pRouterRouterContext:);
  methods[2].selector = @selector(getName);
  methods[3].selector = @selector(runJob);
  methods[4].selector = @selector(getReplyLeaseSetWithBoolean:);
  methods[5].selector = @selector(getNextLease);
  methods[6].selector = @selector(send);
  methods[7].selector = @selector(clearCaches);
  methods[8].selector = @selector(selectOutboundTunnelWithNetI2pDataDestination:);
  methods[9].selector = @selector(selectOutboundTunnel);
  methods[10].selector = @selector(selectInboundTunnel);
  methods[11].selector = @selector(dieFatalWithInt:);
  methods[12].selector = @selector(buildClove);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_cache_", "LNetI2pRouterMessageOutboundCache;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_overallExpiration_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_clientMessage_", "LNetI2pRouterClientMessage;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_clientMessageId_", "LNetI2pDataI2cpMessageId;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_clientMessageSize_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_from_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_to_", "LNetI2pDataDestination;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_toString_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_leaseSet_", "LNetI2pDataLeaseSet;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_lease_", "LNetI2pDataLease;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_start_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_finished_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_leaseSetLookupBegin_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_outTunnel_", "LNetI2pRouterTunnelInfo;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_inTunnel_", "LNetI2pRouterTunnelInfo;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_wantACK_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_hashPair_", "LNetI2pRouterMessageOutboundCache_HashPair;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "OVERALL_TIMEOUT_MS_PARAM", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 9, -1, -1 },
    { "OVERALL_TIMEOUT_MS_DEFAULT", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT, 0x1a, -1, -1, -1, -1 },
    { "OVERALL_TIMEOUT_MS_MIN", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MIN, 0x1a, -1, -1, -1, -1 },
    { "OVERALL_TIMEOUT_MS_MAX", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MAX, 0x1a, -1, -1, -1, -1 },
    { "LS_LOOKUP_TIMEOUT", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_LS_LOOKUP_TIMEOUT, 0x1a, -1, -1, -1, -1 },
    { "OVERALL_TIMEOUT_NOLS_MIN", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_NOLS_MIN, 0x1a, -1, -1, -1, -1 },
    { "REPLY_TIMEOUT_MS_MIN", "J", .constantValue.asLong = NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_TIMEOUT_MS_MIN, 0x1a, -1, -1, -1, -1 },
    { "BUNDLE_REPLY_LEASESET", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 10, -1, -1 },
    { "REPLY_REQUEST_INTERVAL", "I", .constantValue.asInt = NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_REQUEST_INTERVAL, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pRouterMessageOutboundCache;LNetI2pRouterClientMessage;", "init", "LNetI2pRouterRouterContext;", "getReplyLeaseSet", "Z", "selectOutboundTunnel", "LNetI2pDataDestination;", "dieFatal", "I", &NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_PARAM, &NetI2pRouterMessageOutboundClientMessageOneShotJob_BUNDLE_REPLY_LEASESET, "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob;LNetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob;LNetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob;LNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector;LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob;LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob = { "OutboundClientMessageOneShotJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x1, 13, 27, -1, 11, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, NetI2pRouterRouterContext *ctx, NetI2pRouterMessageOutboundCache *cache, NetI2pRouterClientMessage *msg) {
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, ctx);
  JreStrongAssign(&self->_finished_, JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE));
  self->_start_ = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) clock])) now];
  JreStrongAssign(&self->_cache_, cache);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([ctx logManager])) getLogWithIOSClass:NetI2pRouterMessageOutboundClientMessageOneShotJob_class_()]);
  jlong timeoutMs = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT;
  JreStrongAssign(&self->_clientMessage_, msg);
  JreStrongAssign(&self->_clientMessageId_, [((NetI2pRouterClientMessage *) nil_chk(msg)) getMessageId]);
  self->_clientMessageSize_ = [((NetI2pDataPayload *) nil_chk([msg getPayload])) getSize];
  JreStrongAssign(&self->_from_, [msg getFromDestination]);
  JreStrongAssign(&self->_to_, [msg getDestination]);
  NetI2pDataHash *toHash = [((NetI2pDataDestination *) nil_chk(self->_to_)) calculateHash];
  JreStrongAssignAndConsume(&self->_hashPair_, new_NetI2pRouterMessageOutboundCache_HashPair_initWithNetI2pDataHash_withNetI2pDataHash_([((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash], toHash));
  JreStrongAssign(&self->_toString_, [((NSString *) nil_chk([((NetI2pDataHash *) nil_chk(toHash)) toBase64])) java_substring:0 endIndex:4]);
  JreStrongAssign(&self->_leaseSet_, [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([ctx netDb])) lookupLeaseSetLocallyWithNetI2pDataHash:toHash]);
  jlong overallExpiration = [msg getExpiration];
  if (overallExpiration > 0) {
    if (overallExpiration < 24 * 60 * 60 * 1000l) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$J", @"Client bug - interval instead of timestamp ", overallExpiration)];
      overallExpiration += self->_start_;
    }
    if (overallExpiration > self->_start_) {
      jlong minTimeout = self->_leaseSet_ != nil ? NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MIN : NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_NOLS_MIN;
      overallExpiration = JavaLangMath_maxWithLong_withLong_(overallExpiration, self->_start_ + minTimeout);
      overallExpiration = JavaLangMath_minWithLong_withLong_(overallExpiration, self->_start_ + NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_MAX);
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$J", [self getJobId], @": Message Expiration (ms): ", (overallExpiration - self->_start_))];
    }
    else {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$", [self getJobId], @": Expired before we got to it")];
    }
  }
  else {
    NSString *param = [((JavaUtilProperties *) nil_chk([((NetI2pDataI2cpSessionConfig *) nil_chk([msg getSenderConfig])) getOptions])) getPropertyWithNSString:NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_PARAM];
    if (param == nil) param = [((NetI2pRouterRouter *) nil_chk([ctx router])) getConfigSettingWithNSString:NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_PARAM];
    if (param != nil) {
      @try {
        timeoutMs = JavaLangLong_parseLongWithNSString_(param);
      }
      @catch (JavaLangNumberFormatException *nfe) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$$$J", @"Invalid client message timeout specified [", param, @"], defaulting to ", NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT) withJavaLangThrowable:nfe];
        timeoutMs = NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT;
      }
    }
    overallExpiration = timeoutMs + self->_start_;
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("J$J", [self getJobId], @" Default Expiration (ms): ", timeoutMs)];
  }
  self->_overallExpiration_ = overallExpiration;
}

NetI2pRouterMessageOutboundClientMessageOneShotJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_(NetI2pRouterRouterContext *ctx, NetI2pRouterMessageOutboundCache *cache, NetI2pRouterClientMessage *msg) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob, initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_, ctx, cache, msg)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_(NetI2pRouterRouterContext *ctx, NetI2pRouterMessageOutboundCache *cache, NetI2pRouterClientMessage *msg) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob, initWithNetI2pRouterRouterContext_withNetI2pRouterMessageOutboundCache_withNetI2pRouterClientMessage_, ctx, cache, msg)
}

void NetI2pRouterMessageOutboundClientMessageOneShotJob_init__WithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *ctx) {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_initialize();
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(ctx)) statManager])) createFrequencyStatWithNSString:@"client.sendMessageFailFrequency" withNSString:@"How often does a client fail to send a message?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.sendMessageSize" withNSString:@"How large are messages sent by the client?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRequiredRateStatWithNSString:@"client.sendAckTime" withNSString:@"Message round trip time (ms)" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:4]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.timeoutCongestionTunnel" withNSString:@"How lagged our tunnels are when a send times out?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:4]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.timeoutCongestionMessage" withNSString:@"How fast we process messages locally when a send times out?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.timeoutCongestionInbound" withNSString:@"How much faster we are receiving data than our average bps when a send times out?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.leaseSetFoundRemoteTime" withNSString:@"How long we tried to look for a remote leaseSet (when we succeeded)?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.leaseSetFailedRemoteTime" withNSString:@"How long we tried to look for a remote leaseSet (when we failed)?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.dispatchPrepareTime" withNSString:@"How long until we've queued up the dispatch job (since we started)?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.dispatchTime" withNSString:@"How long until we've dispatched the message (since we started)?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.dispatchSendTime" withNSString:@"How long the actual dispatching takes?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.dispatchNoTunnels" withNSString:@"How long after start do we run out of tunnels to send/receive with?" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"client.dispatchNoACK" withNSString:@"Repeated message sends to a peer (no ack required)" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000l, 5 * 60 * 1000l, 60 * 60 * 1000l } count:3]];
  [((NetI2pStatStatManager *) nil_chk([ctx statManager])) createRateStatWithNSString:@"crypto.garlic.decryptFail" withNSString:@"How often garlic messages are undecryptable" withNSString:@"Encryption" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 5 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
}

NetI2pDataLeaseSet *NetI2pRouterMessageOutboundClientMessageOneShotJob_getReplyLeaseSetWithBoolean_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, jboolean force) {
  NetI2pDataLeaseSet *newLS = [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) lookupLeaseSetLocallyWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash]];
  if (newLS == nil) return nil;
  NetI2pDataLeaseSet *ls = [((id<JavaUtilMap>) nil_chk(((NetI2pRouterMessageOutboundCache *) nil_chk(self->_cache_))->leaseSetCache_)) putWithId:self->_hashPair_ withId:newLS];
  if (!force) {
    if (ls != nil) {
      if ([ls isEqual:newLS]) {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Found in cache - NOT including reply leaseset for ", self->_toString_)];
        return nil;
      }
      else {
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Expired from cache - reply leaseset for ", self->_toString_)];
      }
    }
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Added to cache - reply leaseset for ", self->_toString_)];
  return newLS;
}

jboolean NetI2pRouterMessageOutboundClientMessageOneShotJob_getNextLease(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  if (self->_leaseSet_ == nil) {
    JreStrongAssign(&self->_leaseSet_, [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) lookupLeaseSetLocallyWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_to_)) calculateHash]]);
    if (self->_leaseSet_ == nil) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$$", [self getJobId], @": Lookup locally didn't find the leaseSet for ", self->_toString_)];
      return false;
    }
  }
  JreStrongAssign(&self->_lease_, [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(((NetI2pRouterMessageOutboundCache *) nil_chk(self->_cache_))->leaseCache_)) getWithId:self->_hashPair_]);
  if (self->_lease_ != nil) {
    if (![self->_lease_ isExpiredWithLong:NetI2pRouterRouter_CLOCK_FUDGE_FACTOR / 4]) {
      for (jint i = 0; i < [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseCount]; i++) {
        NetI2pDataLease *lease = [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseWithInt:i];
        if ([((NetI2pDataTunnelId *) nil_chk([((NetI2pDataLease *) nil_chk(self->_lease_)) getTunnelId])) isEqual:[((NetI2pDataLease *) nil_chk(lease)) getTunnelId]] && [((NetI2pDataHash *) nil_chk([((NetI2pDataLease *) nil_chk(self->_lease_)) getGateway])) isEqual:[lease getGateway]]) {
          if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Found in cache - lease for ", self->_toString_)];
          return true;
        }
      }
    }
    [self->_cache_->leaseCache_ removeWithId:self->_hashPair_ withId:self->_lease_];
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Expired from cache - lease for ", self->_toString_)];
  }
  id<JavaUtilList> leases = create_JavaUtilArrayList_initWithInt_([((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseCount]);
  for (jint i = 0; i < [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseCount]; i++) {
    NetI2pDataLease *lease = [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseWithInt:i];
    if (![((NetI2pDataLease *) nil_chk(lease)) isExpiredWithLong:NetI2pRouterRouter_CLOCK_FUDGE_FACTOR / 4]) [leases addWithId:lease];
  }
  if ([leases isEmpty]) {
    for (jint i = 0; i < [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseCount]; i++) {
      NetI2pDataLease *lease = [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getLeaseWithInt:i];
      if (![((NetI2pDataLease *) nil_chk(lease)) isExpiredWithLong:NetI2pRouterRouter_CLOCK_FUDGE_FACTOR]) [leases addWithId:lease];
    }
  }
  if ([leases isEmpty]) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$@", [self getJobId], @": No leases found from: ", self->_leaseSet_)];
    return false;
  }
  JavaUtilCollections_shuffleWithJavaUtilList_withJavaUtilRandom_(leases, [((NetI2pRouterRouterContext *) nil_chk([self getContext])) random]);
  for (jint i = 0; i < [leases size]; i++) {
    NetI2pDataLease *l = [leases getWithInt:i];
    NetI2pDataRouterRouterInfo *ri = [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) lookupRouterInfoLocallyWithNetI2pDataHash:[((NetI2pDataLease *) nil_chk(l)) getGateway]];
    if (ri == nil || [((NSString *) nil_chk([ri getCapabilities])) java_indexOf:NetI2pRouterRouter_CAPABILITY_UNREACHABLE] < 0) {
      JreStrongAssign(&self->_lease_, l);
      break;
    }
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$@$$", [self getJobId], @": Skipping unreachable gateway ", [l getGateway], @" for ", self->_toString_)];
  }
  if (self->_lease_ == nil) {
    JreStrongAssign(&self->_lease_, [leases getWithInt:0]);
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$$", [self getJobId], @": All leases are unreachable for ", self->_toString_)];
  }
  [self->_cache_->leaseCache_ putWithId:self->_hashPair_ withId:self->_lease_];
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("J$$", [self getJobId], @": Added to cache - lease for ", self->_toString_)];
  self->_wantACK_ = true;
  return true;
}

void NetI2pRouterMessageOutboundClientMessageOneShotJob_send(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  @synchronized(self) {
    if (self->_finished_ != JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE)) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$@", [self getJobId], @": SEND-AFTER-", self->_finished_)];
      return;
    }
  }
  jlong now = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now];
  if (now >= self->_overallExpiration_) {
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_EXPIRED);
    return;
  }
  JreStrongAssign(&self->_outTunnel_, NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnelWithNetI2pDataDestination_(self, self->_to_));
  if (self->_outTunnel_ == nil) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$", [self getJobId], @": Could not find any outbound tunnels to send the payload through... this might take a while")];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchNoTunnels" withLong:now - self->_start_];
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_NO_TUNNELS);
    return;
  }
  JavaLangLong *lastReplyRequestSent = [((id<JavaUtilMap>) nil_chk(((NetI2pRouterMessageOutboundCache *) nil_chk(self->_cache_))->lastReplyRequestCache_)) getWithId:self->_hashPair_];
  jboolean shouldRequestReply = lastReplyRequestSent == nil || [lastReplyRequestSent longLongValue] < now - NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_REQUEST_INTERVAL;
  jint sendFlags = [((NetI2pRouterClientMessage *) nil_chk(self->_clientMessage_)) getFlags];
  jint tagsRequired = NetI2pClientSendMessageOptions_getTagThresholdWithInt_(sendFlags);
  jboolean wantACK = self->_wantACK_ || shouldRequestReply || NetI2pRouterMessageGarlicMessageBuilder_needsTagsWithNetI2pRouterRouterContext_withNetI2pDataPublicKey_withNetI2pDataHash_withInt_([self getContext], [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getEncryptionKey], [((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash], tagsRequired);
  NetI2pDataLeaseSet *replyLeaseSet;
  NSString *allow = [((JavaUtilProperties *) nil_chk([((NetI2pDataI2cpSessionConfig *) nil_chk([self->_clientMessage_ getSenderConfig])) getOptions])) getPropertyWithNSString:NetI2pRouterMessageOutboundClientMessageOneShotJob_BUNDLE_REPLY_LEASESET];
  jboolean allowLeaseBundle = NetI2pClientSendMessageOptions_getSendLeaseSetWithInt_(sendFlags) && (allow == nil || JavaLangBoolean_parseBooleanWithNSString_(allow));
  if (allowLeaseBundle) {
    replyLeaseSet = NetI2pRouterMessageOutboundClientMessageOneShotJob_getReplyLeaseSetWithBoolean_(self, false);
    if (replyLeaseSet != nil) wantACK = true;
  }
  else {
    replyLeaseSet = nil;
  }
  jlong token;
  if (wantACK) {
    [self->_cache_->lastReplyRequestCache_ putWithId:self->_hashPair_ withId:JavaLangLong_valueOfWithLong_(now)];
    token = [((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE];
    JreStrongAssign(&self->_inTunnel_, NetI2pRouterMessageOutboundClientMessageOneShotJob_selectInboundTunnel(self));
  }
  else {
    token = -1;
  }
  NetI2pRouterMessagePayloadGarlicConfig *clove = NetI2pRouterMessageOutboundClientMessageOneShotJob_buildClove(self);
  if (clove == nil) {
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_UNSUPPORTED_ENCRYPTION);
    return;
  }
  NetI2pDataPublicKey *key = [((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getEncryptionKey];
  NetI2pDataSessionKey *sessKey = create_NetI2pDataSessionKey_init();
  id<JavaUtilSet> tags = create_JavaUtilHashSet_init();
  jint tagsToSend = NetI2pClientSendMessageOptions_getTagsToSendWithInt_(sendFlags);
  NetI2pDataI2npGarlicMessage *msg = NetI2pRouterMessageOutboundClientMessageJobHelper_createGarlicMessageWithNetI2pRouterRouterContext_withLong_withLong_withNetI2pDataPublicKey_withNetI2pRouterMessagePayloadGarlicConfig_withNetI2pDataHash_withNetI2pDataDestination_withNetI2pRouterTunnelInfo_withInt_withInt_withNetI2pDataSessionKey_withJavaUtilSet_withBoolean_withNetI2pDataLeaseSet_([self getContext], token, self->_overallExpiration_, key, clove, [((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash], self->_to_, self->_inTunnel_, tagsToSend, tagsRequired, sessKey, tags, wantACK, replyLeaseSet);
  if (msg == nil) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$$", [self getJobId], @": Unable to create the garlic message (no tunnels left or too lagged) to ", self->_toString_)];
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchNoTunnels" withLong:now - self->_start_];
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(self, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_NO_TUNNELS);
    return;
  }
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *onReply = nil;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *onFail = nil;
  NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *selector = nil;
  if (wantACK) {
    id<NetI2pCryptoTagSetHandle> tsh = nil;
    if (![tags isEmpty]) {
      NetI2pCryptoSessionKeyManager *skm = [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clientManager])) getClientSessionKeyManagerWithNetI2pDataHash:[self->_from_ calculateHash]];
      if (skm != nil) tsh = [skm tagsDeliveredWithNetI2pDataPublicKey:[((NetI2pDataLeaseSet *) nil_chk(self->_leaseSet_)) getEncryptionKey] withNetI2pDataSessionKey:sessKey withJavaUtilSet:tags];
    }
    onReply = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(self, [self getContext], sessKey, tsh);
    onFail = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(self, [self getContext], sessKey, tsh);
    jlong expiration = JavaLangMath_maxWithLong_withLong_(self->_overallExpiration_, self->_start_ + NetI2pRouterMessageOutboundClientMessageOneShotJob_REPLY_TIMEOUT_MS_MIN);
    selector = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(token, expiration);
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("J$@$$$@$@", [self getJobId], @": Sending msg out ", [((id<NetI2pRouterTunnelInfo>) nil_chk(self->_outTunnel_)) getSendTunnelIdWithInt:0], @" to ", self->_toString_, @" at ", [((NetI2pDataLease *) nil_chk(self->_lease_)) getTunnelId], @" on ", [((NetI2pDataLease *) nil_chk(self->_lease_)) getGateway])];
  NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *dispatchJob = create_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(self, [self getContext], msg, selector, onReply, onFail);
  [dispatchJob runJob];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchPrepareTime" withLong:now - self->_start_];
  if (!wantACK) [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchNoACK" withLong:1];
}

void NetI2pRouterMessageOutboundClientMessageOneShotJob_clearCaches(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  [((NetI2pRouterMessageOutboundCache *) nil_chk(self->_cache_)) clearCachesWithNetI2pRouterMessageOutboundCache_HashPair:self->_hashPair_ withNetI2pDataLease:self->_lease_ withNetI2pRouterTunnelInfo:self->_inTunnel_ withNetI2pRouterTunnelInfo:self->_outTunnel_];
}

id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnelWithNetI2pDataDestination_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, NetI2pDataDestination *to) {
  id<NetI2pRouterTunnelInfo> tunnel;
  @synchronized(((NetI2pRouterMessageOutboundCache *) nil_chk(self->_cache_))->tunnelCache_) {
    tunnel = JreRetainedLocalValue([((id<JavaUtilMap>) nil_chk(self->_cache_->backloggedTunnelCache_)) getWithId:self->_hashPair_]);
    if (tunnel != nil) {
      if ([((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelManager])) isValidTunnelWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash] withNetI2pRouterTunnelInfo:tunnel]) {
        if (![((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) isBackloggedWithNetI2pDataHash:[tunnel getPeerWithInt:1]]) {
          if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@$$", @"Switching back to tunnel ", tunnel, @" for ", self->_toString_)];
          [self->_cache_->backloggedTunnelCache_ removeWithId:self->_hashPair_];
          [((id<JavaUtilMap>) nil_chk(self->_cache_->tunnelCache_)) putWithId:self->_hashPair_ withId:tunnel];
          self->_wantACK_ = true;
          return JreRetainedLocalValue(tunnel);
        }
      }
      else [self->_cache_->backloggedTunnelCache_ removeWithId:self->_hashPair_];
    }
    tunnel = JreRetainedLocalValue([((id<JavaUtilMap>) nil_chk(self->_cache_->tunnelCache_)) getWithId:self->_hashPair_]);
    if (tunnel != nil) {
      if ([((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelManager])) isValidTunnelWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash] withNetI2pRouterTunnelInfo:tunnel]) {
        if ([tunnel getLength] <= 1 || ![((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) isBackloggedWithNetI2pDataHash:[tunnel getPeerWithInt:1]]) return JreRetainedLocalValue(tunnel);
        if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$@$$", @"Switching from backlogged ", tunnel, @" for ", self->_toString_)];
        [self->_cache_->backloggedTunnelCache_ putWithId:self->_hashPair_ withId:tunnel];
      }
      [self->_cache_->tunnelCache_ removeWithId:self->_hashPair_];
    }
    tunnel = JreRetainedLocalValue(NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnel(self));
    if (tunnel != nil) [self->_cache_->tunnelCache_ putWithId:self->_hashPair_ withId:tunnel];
    self->_wantACK_ = true;
  }
  return tunnel;
}

id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectOutboundTunnel(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  return [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelManager])) selectOutboundTunnelWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash]];
}

id<NetI2pRouterTunnelInfo> NetI2pRouterMessageOutboundClientMessageOneShotJob_selectInboundTunnel(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  return [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelManager])) selectInboundTunnelWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_from_)) calculateHash] withNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_to_)) calculateHash]];
}

void NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(NetI2pRouterMessageOutboundClientMessageOneShotJob *self, jint status) {
  @synchronized(self) {
    if (self->_finished_ != JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE)) {
      if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$@", [self getJobId], @": FAIL-AFTER-", self->_finished_)];
      return;
    }
    JreStrongAssign(&self->_finished_, JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, FAIL));
  }
  jlong sendTime = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - self->_start_;
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("J$I$@$$$@$@$@$J$", [self getJobId], @": Send failed (cause: ", status, @") ", self->_clientMessageId_, @" to ", self->_toString_, @" out ", self->_outTunnel_, @" in ", self->_lease_, @" ack ", self->_inTunnel_, @" after ", sendTime, @"ms")];
  jlong messageDelay = [((id<NetI2pRouterRouterThrottle>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) throttle])) getMessageDelay];
  jlong tunnelLag = [((id<NetI2pRouterRouterThrottle>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) throttle])) getTunnelLag];
  jlong inboundDelta = JreFpToLong([((id<NetI2pRouterRouterThrottle>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) throttle])) getInboundRateDelta]);
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.timeoutCongestionTunnel" withLong:tunnelLag withLong:1];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.timeoutCongestionMessage" withLong:messageDelay withLong:1];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.timeoutCongestionInbound" withLong:inboundDelta withLong:1];
  NetI2pRouterMessageOutboundClientMessageOneShotJob_clearCaches(self);
  [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) messageHistory])) sendPayloadMessageWithLong:[((NetI2pDataI2cpMessageId *) nil_chk(self->_clientMessageId_)) getMessageId] withBoolean:false withLong:sendTime];
  [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clientManager])) messageDeliveryStatusUpdateWithNetI2pDataDestination:self->_from_ withNetI2pDataI2cpMessageId:self->_clientMessageId_ withLong:[((NetI2pRouterClientMessage *) nil_chk(self->_clientMessage_)) getMessageNonce] withInt:status];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) updateFrequencyWithNSString:@"client.sendMessageFailFrequency"];
}

NetI2pRouterMessagePayloadGarlicConfig *NetI2pRouterMessageOutboundClientMessageOneShotJob_buildClove(NetI2pRouterMessageOutboundClientMessageOneShotJob *self) {
  NetI2pRouterMessagePayloadGarlicConfig *clove = create_NetI2pRouterMessagePayloadGarlicConfig_init();
  NetI2pDataI2npDeliveryInstructions *instructions = create_NetI2pDataI2npDeliveryInstructions_init();
  [instructions setDeliveryModeWithInt:NetI2pDataI2npDeliveryInstructions_DELIVERY_MODE_DESTINATION];
  [instructions setDestinationWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(self->_to_)) calculateHash]];
  [clove setCertificateWithNetI2pDataCertificate:JreLoadStatic(NetI2pDataCertificate, NULL_CERT)];
  [clove setDeliveryInstructionsWithNetI2pDataI2npDeliveryInstructions:instructions];
  [clove setExpirationWithLong:NetI2pRouterMessageOutboundClientMessageOneShotJob_OVERALL_TIMEOUT_MS_DEFAULT + [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now]];
  [clove setIdWithLong:[((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) random])) nextLongWithLong:NetI2pDataI2npI2NPMessage_MAX_ID_VALUE]];
  NetI2pDataI2npDataMessage *msg = create_NetI2pDataI2npDataMessage_initWithNetI2pI2PAppContext_([self getContext]);
  NetI2pDataPayload *p = [((NetI2pRouterClientMessage *) nil_chk(self->_clientMessage_)) getPayload];
  if (p == nil) return nil;
  IOSByteArray *d = [p getEncryptedData];
  if (d == nil) return nil;
  [msg setDataWithByteArray:d];
  [msg setMessageExpirationWithLong:[clove getExpiration]];
  [clove setPayloadWithNetI2pDataI2npI2NPMessage:msg];
  return clove;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob)

J2OBJC_INITIALIZED_DEFN(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result)

NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_[3];

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_Result

+ (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)NONE {
  return JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE);
}

+ (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)FAIL {
  return JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, FAIL);
}

+ (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)SUCCESS {
  return JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS);
}

+ (IOSObjectArray *)values {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values();
}

+ (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *)valueOfWithNSString:(NSString *)name {
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_valueOfWithNSString_(name);
}

- (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum)toNSEnum {
  return (NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NONE", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "FAIL", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "SUCCESS", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_Result;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE), &JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, FAIL), &JreEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS), "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", "Ljava/lang/Enum<Lnet/i2p/router/message/OutboundClientMessageOneShotJob$Result;>;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_Result = { "Result", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x401a, 2, 3, 5, -1, -1, 6, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_Result;
}

+ (void)initialize {
  if (self == [NetI2pRouterMessageOutboundClientMessageOneShotJob_Result class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 3 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    for (jint i = 0; i < 3; i++) {
      ((void)(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_[i] = e = objc_constructInstance(self, (void *)ptr)), ptr += objSize);
      NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initWithNSString_withInt_(e, JreEnumConstantName(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_class_(), i), i);
    }
    J2OBJC_SET_INITIALIZED(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result)
  }
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initWithNSString_withInt_(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values() {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initialize();
  return [IOSObjectArray arrayWithObjects:NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_ count:3 type:NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_class_()];
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_valueOfWithNSString_(NSString *name) {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initialize();
  for (int i = 0; i < 3; i++) {
    NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *e = NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_fromOrdinal(NSUInteger ordinal) {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_initialize();
  if (ordinal >= 3) {
    return nil;
  }
  return NetI2pRouterMessageOutboundClientMessageOneShotJob_Result_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(self, outer$, enclosingContext);
  return self;
}

- (NSString *)getName {
  return @"Outbound client message delayed send";
}

- (void)runJob {
  if (this$0_->_leaseSetLookupBegin_ > 0) {
    jlong lookupTime = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - this$0_->_leaseSetLookupBegin_;
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.leaseSetFoundRemoteTime" withLong:lookupTime];
  }
  this$0_->_wantACK_ = false;
  jboolean ok = NetI2pRouterMessageOutboundClientMessageOneShotJob_getNextLease(this$0_);
  if (ok) {
    NetI2pRouterMessageOutboundClientMessageOneShotJob_send(this$0_);
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [this$0_->_log_ warnWithNSString:JreStrcat("$$C", @"Unable to send on a random lease, as getNext returned null (to=", this$0_->_toString_, ')')];
    NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(this$0_, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_NO_LEASESET);
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:withNetI2pRouterRouterContext:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob = { "SendJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x2, 3, 1, 1, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, enclosingContext);
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_, outer$, enclosingContext)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_, outer$, enclosingContext)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendJob)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(self, outer$, enclosingContext);
  return self;
}

- (NSString *)getName {
  return @"Outbound client message lease lookup failed";
}

- (void)runJob {
  if (this$0_->_leaseSetLookupBegin_ > 0) {
    jlong lookupTime = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - this$0_->_leaseSetLookupBegin_;
    [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.leaseSetFailedRemoteTime" withLong:lookupTime];
  }
  jint cause;
  if ([((NetI2pRouterNetworkDatabaseFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) netDb])) isNegativeCachedForeverWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(this$0_->_to_)) calculateHash]]) {
    if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [this$0_->_log_ warnWithNSString:JreStrcat("$$$", @"Unable to send to ", this$0_->_toString_, @" because the sig type is unsupported")];
    cause = NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_UNSUPPORTED_ENCRYPTION;
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [this$0_->_log_ warnWithNSString:JreStrcat("$$$", @"Unable to send to ", this$0_->_toString_, @" because we couldn't find their leaseSet")];
    cause = NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_NO_LEASESET;
  }
  NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(this$0_, cause);
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:withNetI2pRouterRouterContext:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob = { "LookupLeaseSetFailedJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x2, 3, 1, 1, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, enclosingContext);
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_, outer$, enclosingContext)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_, outer$, enclosingContext)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_LookupLeaseSetFailedJob)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)ctx
                                           withNetI2pDataI2npGarlicMessage:(NetI2pDataI2npGarlicMessage *)msg
      withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector:(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *)sel
     withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *)success
     withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *)timeout {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(self, outer$, ctx, msg, sel, success, timeout);
  return self;
}

- (NSString *)getName {
  return @"Outbound client message dispatch";
}

- (void)runJob {
  if (_selector_ != nil) {
    if (this$0_->_overallExpiration_ >= [_selector_ getExpiration]) {
      [((NetI2pRouterTransportOutboundMessageRegistry *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) messageRegistry])) registerPendingWithNetI2pRouterMessageSelector:_selector_ withNetI2pRouterReplyJob:_replyFound_ withNetI2pRouterJob:_replyTimeout_];
      if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [this$0_->_log_ infoWithNSString:JreStrcat("J$$$", [this$0_ getJobId], @": Reply selector expires ", NetI2pDataDataHelper_formatDurationWithLong_(this$0_->_overallExpiration_ - [_selector_ getExpiration]), @" before message, using selector only")];
    }
    else {
      [((NetI2pRouterTransportOutboundMessageRegistry *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) messageRegistry])) registerPendingWithNetI2pRouterMessageSelector:_selector_ withNetI2pRouterReplyJob:_replyFound_ withNetI2pRouterJob:nil];
      [((NetI2pRouterJobTiming *) nil_chk([((NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *) nil_chk(_replyTimeout_)) getTiming])) setStartAfterWithLong:this$0_->_overallExpiration_];
      [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) jobQueue])) addJobWithNetI2pRouterJob:_replyTimeout_];
      if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [this$0_->_log_ infoWithNSString:JreStrcat("J$$$", [this$0_ getJobId], @": Reply selector expires ", NetI2pDataDataHelper_formatDurationWithLong_([_selector_ getExpiration] - this$0_->_overallExpiration_), @" after message, queueing separate timeout job")];
    }
  }
  if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [this$0_->_log_ infoWithNSString:JreStrcat("J$$$@", [this$0_ getJobId], @": Dispatching message to ", this$0_->_toString_, @": ", _msg_)];
  jlong before = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now];
  [((NetI2pRouterTunnelTunnelDispatcher *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelDispatcher])) dispatchOutboundWithNetI2pDataI2npI2NPMessage:_msg_ withNetI2pDataTunnelId:[((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_outTunnel_)) getSendTunnelIdWithInt:0] withNetI2pDataTunnelId:[((NetI2pDataLease *) nil_chk(this$0_->_lease_)) getTunnelId] withNetI2pDataHash:[((NetI2pDataLease *) nil_chk(this$0_->_lease_)) getGateway]];
  jlong dispatchSendTime = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - before;
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchTime" withLong:[((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - this$0_->_start_];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.dispatchSendTime" withLong:dispatchSendTime];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(_msg_);
  RELEASE_(_selector_);
  RELEASE_(_replyFound_);
  RELEASE_(_replyTimeout_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:withNetI2pRouterRouterContext:withNetI2pDataI2npGarlicMessage:withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector:withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob:withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "_msg_", "LNetI2pDataI2npGarlicMessage;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_selector_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_replyFound_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_replyTimeout_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pDataI2npGarlicMessage;LNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector;LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob;LNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob;", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob = { "DispatchJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x2, 3, 5, 1, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, ctx);
  JreStrongAssign(&self->_msg_, msg);
  JreStrongAssign(&self->_selector_, sel);
  JreStrongAssign(&self->_replyFound_, success);
  JreStrongAssign(&self->_replyTimeout_, timeout);
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_, outer$, ctx, msg, sel, success, timeout)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *ctx, NetI2pDataI2npGarlicMessage *msg, NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *sel, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *success, NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *timeout) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataI2npGarlicMessage_withNetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_withNetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_, outer$, ctx, msg, sel, success, timeout)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_DispatchJob)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector

- (instancetype)initWithLong:(jlong)token
                    withLong:(jlong)expiration {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(self, token, expiration);
  return self;
}

- (jboolean)continueMatching {
  return false;
}

- (jlong)getExpiration {
  return _expiration_;
}

- (jboolean)isMatchWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)inMsg {
  if ([((id<NetI2pDataI2npI2NPMessage>) nil_chk(inMsg)) getType] == NetI2pDataI2npDeliveryStatusMessage_MESSAGE_TYPE) {
    return _pendingToken_ == [((NetI2pDataI2npDeliveryStatusMessage *) cast_chk(inMsg, [NetI2pDataI2npDeliveryStatusMessage class])) getMessageId];
  }
  else {
    return false;
  }
}

- (NSString *)description {
  return JreStrcat("$J$@", @"OCMOSJ.RS waiting for token ", _pendingToken_, @" until ", create_JavaUtilDate_initWithLong_(_expiration_));
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 3, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLong:withLong:);
  methods[1].selector = @selector(continueMatching);
  methods[2].selector = @selector(getExpiration);
  methods[3].selector = @selector(isMatchWithNetI2pDataI2npI2NPMessage:);
  methods[4].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_pendingToken_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_expiration_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "JJ", "isMatch", "LNetI2pDataI2npI2NPMessage;", "toString", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector = { "ReplySelector", "net.i2p.router.message", ptrTable, methods, fields, 7, 0xa, 5, 2, 4, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *self, jlong token, jlong expiration) {
  NSObject_init(self);
  self->_pendingToken_ = token;
  self->_expiration_ = expiration;
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(jlong token, jlong expiration) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector, initWithLong_withLong_, token, expiration)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector_initWithLong_withLong_(jlong token, jlong expiration) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector, initWithLong_withLong_, token, expiration)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_ReplySelector)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext
                                                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                              withNetI2pCryptoTagSetHandle:(id<NetI2pCryptoTagSetHandle>)tags {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(self, outer$, enclosingContext, key, tags);
  return self;
}

- (NSString *)getName {
  return @"Outbound client message send success";
}

- (void)runJob {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *old;
  @synchronized(this$0_) {
    old = JreRetainedLocalValue(this$0_->_finished_);
    if (old == JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS)) {
      if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [this$0_->_log_ warnWithNSString:JreStrcat("J$", [this$0_ getJobId], @": SUCCESS-AFTER-SUCCESS")];
      return;
    }
    JreStrongAssign(&this$0_->_finished_, JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS));
    if (_key_ != nil && _tags_ != nil && this$0_->_leaseSet_ != nil) {
      NetI2pCryptoSessionKeyManager *skm = [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clientManager])) getClientSessionKeyManagerWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(this$0_->_from_)) calculateHash]];
      if (skm != nil) [skm tagsAckedWithNetI2pDataPublicKey:[((NetI2pDataLeaseSet *) nil_chk(this$0_->_leaseSet_)) getEncryptionKey] withNetI2pDataSessionKey:_key_ withNetI2pCryptoTagSetHandle:_tags_];
    }
  }
  jlong sendTime = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] - this$0_->_start_;
  if (old == JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, FAIL)) {
    if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [this$0_->_log_ warnWithNSString:JreStrcat("J$@$J$", [this$0_ getJobId], @": SUCCESS-AFTER-TIMEOUT ", this$0_->_clientMessageId_, @" acked by DSM after ", sendTime, @"ms")];
  }
  else if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) {
    [this$0_->_log_ infoWithNSString:JreStrcat("J$@$J$", [this$0_ getJobId], @": SUCCESS ", this$0_->_clientMessageId_, @" acked by DSM after ", sendTime, @"ms")];
  }
  [((NetI2pRouterMessageHistory *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) messageHistory])) sendPayloadMessageWithLong:99999 withBoolean:true withLong:sendTime];
  [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clientManager])) messageDeliveryStatusUpdateWithNetI2pDataDestination:this$0_->_from_ withNetI2pDataI2cpMessageId:this$0_->_clientMessageId_ withLong:[((NetI2pRouterClientMessage *) nil_chk(this$0_->_clientMessage_)) getMessageNonce] withInt:NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_GUARANTEED_SUCCESS];
  jint size = this$0_->_clientMessageSize_;
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.sendAckTime" withLong:sendTime];
  [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) addRateDataWithNSString:@"client.sendMessageSize" withLong:this$0_->_clientMessageSize_ withLong:sendTime];
  if (this$0_->_outTunnel_ != nil) {
    if ([this$0_->_outTunnel_ getLength] > 0) size = ((size + 1023) / 1024) * 1024;
    for (jint i = 1; i < [((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_outTunnel_)) getLength]; i++) {
      [((id<NetI2pRouterProfileManager>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) profileManager])) tunnelTestSucceededWithNetI2pDataHash:[((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_outTunnel_)) getPeerWithInt:i] withLong:sendTime];
      [((id<NetI2pRouterProfileManager>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) profileManager])) tunnelDataPushedWithNetI2pDataHash:[((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_outTunnel_)) getPeerWithInt:i] withLong:sendTime withInt:size];
    }
    [((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_outTunnel_)) incrementVerifiedBytesTransferredWithInt:size];
  }
  if (this$0_->_inTunnel_ != nil) {
    for (jint i = 0; i < [((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_inTunnel_)) getLength] - 1; i++) {
      [((id<NetI2pRouterProfileManager>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) profileManager])) tunnelTestSucceededWithNetI2pDataHash:[((id<NetI2pRouterTunnelInfo>) nil_chk(this$0_->_inTunnel_)) getPeerWithInt:i] withLong:sendTime];
    }
  }
}

- (void)setMessageWithNetI2pDataI2npI2NPMessage:(id<NetI2pDataI2npI2NPMessage>)msg {
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(_key_);
  RELEASE_(_tags_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:withNetI2pRouterRouterContext:withNetI2pDataSessionKey:withNetI2pCryptoTagSetHandle:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  methods[3].selector = @selector(setMessageWithNetI2pDataI2npI2NPMessage:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "_key_", "LNetI2pDataSessionKey;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_tags_", "LNetI2pCryptoTagSetHandle;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pDataSessionKey;LNetI2pCryptoTagSetHandle;", "setMessage", "LNetI2pDataI2npI2NPMessage;", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob = { "SendSuccessJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x2, 4, 3, 3, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, enclosingContext);
  JreStrongAssign(&self->_key_, key);
  JreStrongAssign(&self->_tags_, tags);
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_, outer$, enclosingContext, key, tags)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_, outer$, enclosingContext, key, tags)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendSuccessJob)

@implementation NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob

- (instancetype)initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:(NetI2pRouterMessageOutboundClientMessageOneShotJob *)outer$
                                             withNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)enclosingContext
                                                  withNetI2pDataSessionKey:(NetI2pDataSessionKey *)key
                                              withNetI2pCryptoTagSetHandle:(id<NetI2pCryptoTagSetHandle>)tags {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(self, outer$, enclosingContext, key, tags);
  return self;
}

- (NSString *)getName {
  return @"Outbound client message send timeout";
}

- (void)runJob {
  NetI2pRouterMessageOutboundClientMessageOneShotJob_Result *old;
  @synchronized(this$0_) {
    old = JreRetainedLocalValue(this$0_->_finished_);
    if (old == JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, SUCCESS)) {
      if ([((NetI2pUtilLog *) nil_chk(this$0_->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [this$0_->_log_ infoWithNSString:JreStrcat("J$", [this$0_ getJobId], @": TIMEOUT-AFTER-SUCCESS")];
      return;
    }
    if (_key_ != nil && _tags_ != nil && this$0_->_leaseSet_ != nil) {
      NetI2pCryptoSessionKeyManager *skm = [((NetI2pRouterClientManagerFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clientManager])) getClientSessionKeyManagerWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(this$0_->_from_)) calculateHash]];
      if (skm != nil) [skm failTagsWithNetI2pDataPublicKey:[((NetI2pDataLeaseSet *) nil_chk(this$0_->_leaseSet_)) getEncryptionKey] withNetI2pDataSessionKey:_key_ withNetI2pCryptoTagSetHandle:_tags_];
    }
  }
  if (old == JreLoadEnum(NetI2pRouterMessageOutboundClientMessageOneShotJob_Result, NONE)) NetI2pRouterMessageOutboundClientMessageOneShotJob_dieFatalWithInt_(this$0_, NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_BEST_EFFORT_FAILURE);
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(_key_);
  RELEASE_(_tags_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterMessageOutboundClientMessageOneShotJob:withNetI2pRouterRouterContext:withNetI2pDataSessionKey:withNetI2pCryptoTagSetHandle:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "_key_", "LNetI2pDataSessionKey;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_tags_", "LNetI2pCryptoTagSetHandle;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pDataSessionKey;LNetI2pCryptoTagSetHandle;", "LNetI2pRouterMessageOutboundClientMessageOneShotJob;" };
  static const J2ObjcClassInfo _NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob = { "SendTimeoutJob", "net.i2p.router.message", ptrTable, methods, fields, 7, 0x2, 3, 3, 1, -1, -1, -1, -1 };
  return &_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob;
}

@end

void NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *self, NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  JreStrongAssign(&self->this$0_, outer$);
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, enclosingContext);
  JreStrongAssign(&self->_key_, key);
  JreStrongAssign(&self->_tags_, tags);
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *new_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  J2OBJC_NEW_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_, outer$, enclosingContext, key, tags)
}

NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob *create_NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob_initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_(NetI2pRouterMessageOutboundClientMessageOneShotJob *outer$, NetI2pRouterRouterContext *enclosingContext, NetI2pDataSessionKey *key, id<NetI2pCryptoTagSetHandle> tags) {
  J2OBJC_CREATE_IMPL(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob, initWithNetI2pRouterMessageOutboundClientMessageOneShotJob_withNetI2pRouterRouterContext_withNetI2pDataSessionKey_withNetI2pCryptoTagSetHandle_, outer$, enclosingContext, key, tags)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterMessageOutboundClientMessageOneShotJob_SendTimeoutJob)
