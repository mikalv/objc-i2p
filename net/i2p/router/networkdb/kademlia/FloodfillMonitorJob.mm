//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/networkdb/kademlia/FloodfillMonitorJob.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/util/List.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/router/RouterAddress.h"
#include "net/i2p/data/router/RouterInfo.h"
#include "net/i2p/router/Banlist.h"
#include "net/i2p/router/CommSystemFacade.h"
#include "net/i2p/router/Job.h"
#include "net/i2p/router/JobImpl.h"
#include "net/i2p/router/JobQueue.h"
#include "net/i2p/router/JobTiming.h"
#include "net/i2p/router/Router.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/TunnelManagerFacade.h"
#include "net/i2p/router/networkdb/kademlia/FloodfillMonitorJob.h"
#include "net/i2p/router/networkdb/kademlia/FloodfillNetworkDatabaseFacade.h"
#include "net/i2p/router/networkdb/kademlia/FloodfillRouterInfoFloodJob.h"
#include "net/i2p/router/peermanager/PeerProfile.h"
#include "net/i2p/router/peermanager/ProfileOrganizer.h"
#include "net/i2p/router/transport/TransportManager.h"
#include "net/i2p/router/transport/TransportUtil.h"
#include "net/i2p/router/transport/udp/UDPTransport.h"
#include "net/i2p/router/util/EventLog.h"
#include "net/i2p/stat/Rate.h"
#include "net/i2p/stat/RateStat.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"
#include "net/i2p/util/SystemVersion.h"

@interface NetI2pRouterNetworkdbKademliaFloodfillMonitorJob () {
 @public
  NetI2pUtilLog *_log_;
  NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *_facade_;
  jlong _lastChanged_;
  jboolean _deferredFlood_;
}

- (jboolean)shouldBeFloodfill;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, _log_, NetI2pUtilLog *)
J2OBJC_FIELD_SETTER(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, _facade_, NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *)

inline jint NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_get_REQUEUE_DELAY(void);
#define NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_REQUEUE_DELAY 3600000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, REQUEUE_DELAY, jint)

inline jlong NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_get_MIN_UPTIME(void);
#define NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_UPTIME 7200000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, MIN_UPTIME, jlong)

inline jlong NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_get_MIN_CHANGE_DELAY(void);
#define NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_CHANGE_DELAY 21600000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, MIN_CHANGE_DELAY, jlong)

inline jint NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_get_MIN_FF(void);
#define NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF 5000
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, MIN_FF, jint)

inline jint NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_get_MAX_FF(void);
#define NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MAX_FF 999999
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, MAX_FF, jint)

__attribute__((unused)) static jboolean NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_shouldBeFloodfill(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob *self);

NSString *NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_PROP_FLOODFILL_PARTICIPANT = @"router.floodfillParticipant";

@implementation NetI2pRouterNetworkdbKademliaFloodfillMonitorJob

+ (NSString *)PROP_FLOODFILL_PARTICIPANT {
  return NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_PROP_FLOODFILL_PARTICIPANT;
}

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)context
withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade:(NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *)facade {
  NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_(self, context, facade);
  return self;
}

- (NSString *)getName {
  return @"Monitor the floodfill pool";
}

- (void)runJob {
  @synchronized(self) {
    jboolean wasFF = [((NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *) nil_chk(_facade_)) floodfillEnabled];
    jboolean ff = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_shouldBeFloodfill(self);
    [_facade_ setFloodfillEnabledFromMonitorWithBoolean:ff];
    if (ff != wasFF) {
      if (ff) {
        [((NetI2pRouterUtilEventLog *) nil_chk([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) eventLog])) addEventWithNSString:NetI2pRouterUtilEventLog_BECAME_FLOODFILL];
      }
      else {
        [((NetI2pRouterUtilEventLog *) nil_chk([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) eventLog])) addEventWithNSString:NetI2pRouterUtilEventLog_NOT_FLOODFILL];
      }
      [((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) rebuildRouterInfoWithBoolean:true];
      id<NetI2pRouterJob> routerInfoFlood = create_NetI2pRouterNetworkdbKademliaFloodfillRouterInfoFloodJob_initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_([self getContext], _facade_);
      if ([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) getUptime] < 5 * 60 * 1000) {
        if (!_deferredFlood_) {
          _deferredFlood_ = true;
          [((NetI2pRouterJobTiming *) nil_chk([routerInfoFlood getTiming])) setStartAfterWithLong:[((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now] + 5 * 60 * 1000];
          [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) jobQueue])) addJobWithNetI2pRouterJob:routerInfoFlood];
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ logAlwaysWithInt:NetI2pUtilLog_DEBUG withNSString:@"Deferring our FloodfillRouterInfoFloodJob run because of low uptime."];
        }
      }
      else {
        [routerInfoFlood runJob];
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) {
          [_log_ logAlwaysWithInt:NetI2pUtilLog_DEBUG withNSString:@"Running FloodfillRouterInfoFloodJob"];
        }
      }
    }
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$Z", @"Should we be floodfill? ", ff)];
    jint delay = (NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_REQUEUE_DELAY / 2) + [((NetI2pUtilRandomSource *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) random])) nextIntWithInt:NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_REQUEUE_DELAY];
    if (!ff) delay *= 4;
    [self requeueWithLong:delay];
  }
}

- (jboolean)shouldBeFloodfill {
  return NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_shouldBeFloodfill(self);
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_facade_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade:);
  methods[1].selector = @selector(getName);
  methods[2].selector = @selector(runJob);
  methods[3].selector = @selector(shouldBeFloodfill);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_facade_", "LNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_lastChanged_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_deferredFlood_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "REQUEUE_DELAY", "I", .constantValue.asInt = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_REQUEUE_DELAY, 0x1a, -1, -1, -1, -1 },
    { "MIN_UPTIME", "J", .constantValue.asLong = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_UPTIME, 0x1a, -1, -1, -1, -1 },
    { "MIN_CHANGE_DELAY", "J", .constantValue.asLong = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_CHANGE_DELAY, 0x1a, -1, -1, -1, -1 },
    { "MIN_FF", "I", .constantValue.asInt = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF, 0x1a, -1, -1, -1, -1 },
    { "MAX_FF", "I", .constantValue.asInt = NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MAX_FF, 0x1a, -1, -1, -1, -1 },
    { "PROP_FLOODFILL_PARTICIPANT", "LNSString;", .constantValue.asLong = 0, 0x18, -1, 1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade;", &NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_PROP_FLOODFILL_PARTICIPANT };
  static const J2ObjcClassInfo _NetI2pRouterNetworkdbKademliaFloodfillMonitorJob = { "FloodfillMonitorJob", "net.i2p.router.networkdb.kademlia", ptrTable, methods, fields, 7, 0x0, 4, 10, -1, -1, -1, -1, -1 };
  return &_NetI2pRouterNetworkdbKademliaFloodfillMonitorJob;
}

@end

void NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob *self, NetI2pRouterRouterContext *context, NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *facade) {
  NetI2pRouterJobImpl_initWithNetI2pRouterRouterContext_(self, context);
  JreStrongAssign(&self->_facade_, facade);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(context)) logManager])) getLogWithIOSClass:NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_class_()]);
}

NetI2pRouterNetworkdbKademliaFloodfillMonitorJob *new_NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_(NetI2pRouterRouterContext *context, NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *facade) {
  J2OBJC_NEW_IMPL(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_, context, facade)
}

NetI2pRouterNetworkdbKademliaFloodfillMonitorJob *create_NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_(NetI2pRouterRouterContext *context, NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *facade) {
  J2OBJC_CREATE_IMPL(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob, initWithNetI2pRouterRouterContext_withNetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade_, context, facade)
}

jboolean NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_shouldBeFloodfill(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob *self) {
  if (![((NetI2pCryptoSigType *) nil_chk(JreLoadEnum(NetI2pCryptoSigType, ECDSA_SHA256_P256))) isAvailable]) return false;
  if ([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) isHidden]) return false;
  NSString *enabled = [((NetI2pRouterRouterContext *) nil_chk([self getContext])) getPropertyWithNSString:NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_PROP_FLOODFILL_PARTICIPANT withNSString:@"auto"];
  if ([@"true" isEqual:enabled]) return true;
  if ([@"false" isEqual:enabled]) return false;
  if ([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) gracefulShutdownInProgress]) return false;
  if (NetI2pUtilSystemVersion_isARM() || NetI2pUtilSystemVersion_isAndroid()) return false;
  if ([((NetI2pRouterRouterContext *) nil_chk([self getContext])) getBooleanPropertyWithNSString:NetI2pRouterTransportUdpUDPTransport_PROP_LAPTOP_MODE]) return false;
  if (NetI2pRouterTransportTransportUtil_getIPv6ConfigWithNetI2pRouterRouterContext_withNSString_([self getContext], @"SSU") == JreLoadEnum(NetI2pRouterTransportTransportUtil_IPv6Config, IPV6_ONLY)) return false;
  if (!NetI2pRouterTransportTransportManager_isNTCPEnabledWithNetI2pRouterRouterContext_([self getContext])) return false;
  if (![((NetI2pRouterRouterContext *) nil_chk([self getContext])) getBooleanPropertyDefaultTrueWithNSString:NetI2pRouterTransportTransportManager_PROP_ENABLE_UDP]) return false;
  if ([((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) isInBadCountry]) return false;
  NSString *country = [((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) getOurCountry];
  if ([@"a1" isEqual:country] || [@"a2" isEqual:country]) return false;
  if ([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) getUptime] < NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_UPTIME) return false;
  NetI2pDataRouterRouterInfo *ri = [((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) getRouterInfo];
  if (ri == nil) return false;
  jchar bw = [((NSString *) nil_chk([ri getBandwidthTier])) charAtWithInt:0];
  if (bw != NetI2pRouterRouter_CAPABILITY_BW64 && bw != NetI2pRouterRouter_CAPABILITY_BW128 && bw != NetI2pRouterRouter_CAPABILITY_BW256 && bw != NetI2pRouterRouter_CAPABILITY_BW512 && bw != NetI2pRouterRouter_CAPABILITY_BW_UNLIMITED) return false;
  id<JavaUtilList> floodfillPeers = [((NetI2pRouterNetworkdbKademliaFloodfillNetworkDatabaseFacade *) nil_chk(self->_facade_)) getFloodfillPeers];
  jlong now = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) now];
  if (floodfillPeers == nil || [floodfillPeers isEmpty]) {
    self->_lastChanged_ = now;
    return true;
  }
  jboolean wasFF = [self->_facade_ floodfillEnabled];
  if (self->_lastChanged_ + NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_CHANGE_DELAY > now) return wasFF;
  jint ffcount = [floodfillPeers size];
  jint failcount = 0;
  jlong before = now - 60 * 60 * 1000;
  for (NetI2pDataHash * __strong peer in floodfillPeers) {
    NetI2pRouterPeermanagerPeerProfile *profile = [((NetI2pRouterPeermanagerProfileOrganizer *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) profileOrganizer])) getProfileWithNetI2pDataHash:peer];
    if (profile == nil || [profile getLastHeardFrom] < before || [profile getIsFailing] || [((NetI2pRouterBanlist *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) banlist])) isBanlistedWithNetI2pDataHash:peer] || [((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) wasUnreachableWithNetI2pDataHash:peer]) failcount++;
  }
  if (wasFF) ffcount++;
  jint good = ffcount - failcount;
  jboolean happy = [((NSString *) nil_chk([((NetI2pDataRouterRouterInfo *) nil_chk([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) getRouterInfo])) getCapabilities])) java_indexOf:'R'] >= 0;
  NetI2pStatRateStat *lagStat = [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) getRateWithNSString:@"jobQueue.jobLag"];
  NetI2pStatRateStat *queueStat = [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) getRateWithNSString:@"router.tunnelBacklog"];
  happy = (happy && [((NetI2pStatRate *) nil_chk([((NetI2pStatRateStat *) nil_chk(lagStat)) getRateWithLong:60 * 60 * 1000LL])) getAvgOrLifetimeAvg] < 25);
  happy = (happy && [((NetI2pStatRate *) nil_chk([((NetI2pStatRateStat *) nil_chk(queueStat)) getRateWithLong:60 * 60 * 1000LL])) getAvgOrLifetimeAvg] < 5);
  happy = (happy && [self->_facade_ getKnownRouters] >= 400);
  happy = (happy && [((NetI2pRouterCommSystemFacade *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) commSystem])) countActivePeers] >= 50);
  happy = (happy && [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) tunnelManager])) getParticipatingCount] >= 25);
  happy = (happy && JavaLangMath_absWithLong_([((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) clock])) getOffset]) < 10 * 1000);
  if (happy) {
    NetI2pDataRouterRouterAddress *ra = [((NetI2pDataRouterRouterInfo *) nil_chk([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) router])) getRouterInfo])) getTargetAddressWithNSString:@"SSU"];
    if (ra == nil) happy = false;
    else {
      if ([ra getOptionWithNSString:@"ihost0"] != nil) happy = false;
    }
  }
  jdouble elG = 0;
  NetI2pStatRateStat *stat = [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk([self getContext])) statManager])) getRateWithNSString:@"crypto.elGamal.decrypt"];
  if (stat != nil) {
    NetI2pStatRate *rate = [stat getRateWithLong:60 * 60 * 1000LL];
    if (rate != nil) {
      elG = [rate getAvgOrLifetimeAvg];
      happy = (happy && elG <= 40.0);
    }
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) {
    NetI2pRouterRouterContext *rc = [self getContext];
    NSString *log = NSString_java_formatWithNSString_withNSObjectArray_(@"FF criteria breakdown: happy=%b, capabilities=%s, maxLag=%d, known=%d, active=%d, participating=%d, offset=%d, ssuAddr=%s ElG=%f", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangBoolean_valueOfWithBoolean_(happy), [((NetI2pDataRouterRouterInfo *) nil_chk([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(rc)) router])) getRouterInfo])) getCapabilities], JavaLangLong_valueOfWithLong_([((NetI2pRouterJobQueue *) nil_chk([rc jobQueue])) getMaxLag]), JavaLangInteger_valueOfWithInt_([self->_facade_ getKnownRouters]), JavaLangInteger_valueOfWithInt_([((NetI2pRouterCommSystemFacade *) nil_chk([rc commSystem])) countActivePeers]), JavaLangInteger_valueOfWithInt_([((id<NetI2pRouterTunnelManagerFacade>) nil_chk([rc tunnelManager])) getParticipatingCount]), JavaLangLong_valueOfWithLong_(JavaLangMath_absWithLong_([((NetI2pUtilClock *) nil_chk([rc clock])) getOffset])), [((NetI2pDataRouterRouterAddress *) nil_chk([((NetI2pDataRouterRouterInfo *) nil_chk([((NetI2pRouterRouter *) nil_chk([rc router])) getRouterInfo])) getTargetAddressWithNSString:@"SSU"])) description], JavaLangDouble_valueOfWithDouble_(elG) } count:9 type:NSObject_class_()]);
    [self->_log_ debugWithNSString:log];
  }
  if (good < NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF && happy) {
    if (!wasFF) {
      self->_lastChanged_ = now;
      [self->_log_ logAlwaysWithInt:NetI2pUtilLog_INFO withNSString:JreStrcat("$I$I$", @"Only ", good, @" ff peers and we want ", NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF, @" so we are becoming floodfill")];
    }
    return true;
  }
  if (good > NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MAX_FF || (good > NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF && !happy)) {
    if (wasFF) {
      self->_lastChanged_ = now;
      [self->_log_ logAlwaysWithInt:NetI2pUtilLog_INFO withNSString:JreStrcat("$I$I$I$Z", @"Have ", good, @" ff peers and we need only ", NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MIN_FF, @" to ", NetI2pRouterNetworkdbKademliaFloodfillMonitorJob_MAX_FF, @" so we are disabling floodfill; reachable? ", happy)];
    }
    return false;
  }
  if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$I$Z$Z", @"Have ", good, @" ff peers, not changing, enabled? ", wasFF, @"; reachable? ", happy)];
  return wasFF;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterNetworkdbKademliaFloodfillMonitorJob)
