//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/client/ClientMessageEventListener.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/util/Date.h"
#include "java/util/List.h"
#include "java/util/Properties.h"
#include "net/i2p/CoreVersion.h"
#include "net/i2p/crypto/SigType.h"
#include "net/i2p/data/Certificate.h"
#include "net/i2p/data/DataHelper.h"
#include "net/i2p/data/Destination.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/LeaseSet.h"
#include "net/i2p/data/Payload.h"
#include "net/i2p/data/PrivateKey.h"
#include "net/i2p/data/PublicKey.h"
#include "net/i2p/data/Signature.h"
#include "net/i2p/data/SigningPrivateKey.h"
#include "net/i2p/data/i2cp/BandwidthLimitsMessage.h"
#include "net/i2p/data/i2cp/CreateLeaseSetMessage.h"
#include "net/i2p/data/i2cp/CreateSessionMessage.h"
#include "net/i2p/data/i2cp/DestLookupMessage.h"
#include "net/i2p/data/i2cp/DestroySessionMessage.h"
#include "net/i2p/data/i2cp/GetBandwidthLimitsMessage.h"
#include "net/i2p/data/i2cp/GetDateMessage.h"
#include "net/i2p/data/i2cp/HostLookupMessage.h"
#include "net/i2p/data/i2cp/I2CPMessage.h"
#include "net/i2p/data/i2cp/I2CPMessageException.h"
#include "net/i2p/data/i2cp/I2CPMessageReader.h"
#include "net/i2p/data/i2cp/MessageId.h"
#include "net/i2p/data/i2cp/MessagePayloadMessage.h"
#include "net/i2p/data/i2cp/MessageStatusMessage.h"
#include "net/i2p/data/i2cp/ReceiveMessageBeginMessage.h"
#include "net/i2p/data/i2cp/ReceiveMessageEndMessage.h"
#include "net/i2p/data/i2cp/ReconfigureSessionMessage.h"
#include "net/i2p/data/i2cp/SendMessageExpiresMessage.h"
#include "net/i2p/data/i2cp/SendMessageMessage.h"
#include "net/i2p/data/i2cp/SessionConfig.h"
#include "net/i2p/data/i2cp/SessionId.h"
#include "net/i2p/data/i2cp/SessionStatusMessage.h"
#include "net/i2p/data/i2cp/SetDateMessage.h"
#include "net/i2p/router/ClientTunnelSettings.h"
#include "net/i2p/router/JobQueue.h"
#include "net/i2p/router/KeyManager.h"
#include "net/i2p/router/LeaseSetKeys.h"
#include "net/i2p/router/NetworkDatabaseFacade.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/TunnelManagerFacade.h"
#include "net/i2p/router/TunnelPoolSettings.h"
#include "net/i2p/router/client/ClientConnectionRunner.h"
#include "net/i2p/router/client/ClientMessageEventListener.h"
#include "net/i2p/router/client/CreateSessionJob.h"
#include "net/i2p/router/client/LookupDestJob.h"
#include "net/i2p/router/transport/FIFOBandwidthLimiter.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Clock.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/PasswordManager.h"

@interface NetI2pRouterClientClientMessageEventListener () {
 @public
  NetI2pUtilLog *_log_;
  jboolean _enforceAuth_;
  volatile_jboolean _authorized_;
}

- (void)handleGetDateWithNetI2pDataI2cpGetDateMessage:(NetI2pDataI2cpGetDateMessage *)message;

- (void)handleSetDateWithNetI2pDataI2cpSetDateMessage:(NetI2pDataI2cpSetDateMessage *)message;

- (void)handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage:(NetI2pDataI2cpCreateSessionMessage *)message;

- (jboolean)checkAuthWithJavaUtilProperties:(JavaUtilProperties *)props;

- (void)handleSendMessageWithNetI2pDataI2cpSendMessageMessage:(NetI2pDataI2cpSendMessageMessage *)message;

- (void)handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage:(NetI2pDataI2cpReceiveMessageBeginMessage *)message;

- (void)handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage:(NetI2pDataI2cpReceiveMessageEndMessage *)message;

- (void)handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage:(NetI2pDataI2cpDestroySessionMessage *)message;

- (void)handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage:(NetI2pDataI2cpReconfigureSessionMessage *)message;

- (void)sendStatusMessageWithNetI2pDataI2cpSessionId:(NetI2pDataI2cpSessionId *)id_
                                             withInt:(jint)status;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterClientClientMessageEventListener, _log_, NetI2pUtilLog *)

inline NSString *NetI2pRouterClientClientMessageEventListener_get_PROP_AUTH(void);
static NSString *NetI2pRouterClientClientMessageEventListener_PROP_AUTH = @"i2cp.auth";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterClientClientMessageEventListener, PROP_AUTH, NSString *)

inline NSString *NetI2pRouterClientClientMessageEventListener_get_PROP_AUTH_STRICT(void);
static NSString *NetI2pRouterClientClientMessageEventListener_PROP_AUTH_STRICT = @"i2cp.strictAuth";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterClientClientMessageEventListener, PROP_AUTH_STRICT, NSString *)

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleGetDateWithNetI2pDataI2cpGetDateMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpGetDateMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleSetDateWithNetI2pDataI2cpSetDateMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSetDateMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpCreateSessionMessage *message);

__attribute__((unused)) static jboolean NetI2pRouterClientClientMessageEventListener_checkAuthWithJavaUtilProperties_(NetI2pRouterClientClientMessageEventListener *self, JavaUtilProperties *props);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleSendMessageWithNetI2pDataI2cpSendMessageMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSendMessageMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReceiveMessageBeginMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReceiveMessageEndMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpDestroySessionMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReconfigureSessionMessage *message);

__attribute__((unused)) static void NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSessionId *id_, jint status);

@implementation NetI2pRouterClientClientMessageEventListener

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)context
     withNetI2pRouterClientClientConnectionRunner:(NetI2pRouterClientClientConnectionRunner *)runner
                                      withBoolean:(jboolean)enforceAuth {
  NetI2pRouterClientClientMessageEventListener_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_(self, context, runner, enforceAuth);
  return self;
}

- (void)messageReceivedWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader
                             withNetI2pDataI2cpI2CPMessage:(id<NetI2pDataI2cpI2CPMessage>)message {
  if ([((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) isDead]) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$@", @"Received but runner dead: \n", message)];
    return;
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$@", @"Message received: \n", message)];
  jint type = [((id<NetI2pDataI2cpI2CPMessage>) nil_chk(message)) getType];
  if (!JreLoadVolatileBoolean(&_authorized_)) {
    jboolean strict = [((NetI2pRouterRouterContext *) nil_chk(_context_)) getBooleanPropertyDefaultTrueWithNSString:NetI2pRouterClientClientMessageEventListener_PROP_AUTH_STRICT];
    if ((strict && type != NetI2pDataI2cpGetDateMessage_MESSAGE_TYPE) || (type != NetI2pDataI2cpCreateSessionMessage_MESSAGE_TYPE && type != NetI2pDataI2cpGetDateMessage_MESSAGE_TYPE && type != NetI2pDataI2cpDestLookupMessage_MESSAGE_TYPE && type != NetI2pDataI2cpGetBandwidthLimitsMessage_MESSAGE_TYPE)) {
      [_log_ errorWithNSString:JreStrcat("$I$", @"Received message type ", type, @" without required authentication")];
      [_runner_ disconnectClientWithNSString:@"Authorization required"];
      return;
    }
  }
  switch ([message getType]) {
    case NetI2pDataI2cpGetDateMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleGetDateWithNetI2pDataI2cpGetDateMessage_(self, (NetI2pDataI2cpGetDateMessage *) cast_chk(message, [NetI2pDataI2cpGetDateMessage class]));
    break;
    case NetI2pDataI2cpSetDateMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleSetDateWithNetI2pDataI2cpSetDateMessage_(self, (NetI2pDataI2cpSetDateMessage *) cast_chk(message, [NetI2pDataI2cpSetDateMessage class]));
    break;
    case NetI2pDataI2cpCreateSessionMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage_(self, (NetI2pDataI2cpCreateSessionMessage *) cast_chk(message, [NetI2pDataI2cpCreateSessionMessage class]));
    break;
    case NetI2pDataI2cpSendMessageMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleSendMessageWithNetI2pDataI2cpSendMessageMessage_(self, (NetI2pDataI2cpSendMessageMessage *) cast_chk(message, [NetI2pDataI2cpSendMessageMessage class]));
    break;
    case NetI2pDataI2cpSendMessageExpiresMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleSendMessageWithNetI2pDataI2cpSendMessageMessage_(self, (NetI2pDataI2cpSendMessageExpiresMessage *) cast_chk(message, [NetI2pDataI2cpSendMessageExpiresMessage class]));
    break;
    case NetI2pDataI2cpReceiveMessageBeginMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage_(self, (NetI2pDataI2cpReceiveMessageBeginMessage *) cast_chk(message, [NetI2pDataI2cpReceiveMessageBeginMessage class]));
    break;
    case NetI2pDataI2cpReceiveMessageEndMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage_(self, (NetI2pDataI2cpReceiveMessageEndMessage *) cast_chk(message, [NetI2pDataI2cpReceiveMessageEndMessage class]));
    break;
    case NetI2pDataI2cpCreateLeaseSetMessage_MESSAGE_TYPE:
    [self handleCreateLeaseSetWithNetI2pDataI2cpCreateLeaseSetMessage:(NetI2pDataI2cpCreateLeaseSetMessage *) cast_chk(message, [NetI2pDataI2cpCreateLeaseSetMessage class])];
    break;
    case NetI2pDataI2cpDestroySessionMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage_(self, (NetI2pDataI2cpDestroySessionMessage *) cast_chk(message, [NetI2pDataI2cpDestroySessionMessage class]));
    break;
    case NetI2pDataI2cpDestLookupMessage_MESSAGE_TYPE:
    [self handleDestLookupWithNetI2pDataI2cpDestLookupMessage:(NetI2pDataI2cpDestLookupMessage *) cast_chk(message, [NetI2pDataI2cpDestLookupMessage class])];
    break;
    case NetI2pDataI2cpHostLookupMessage_MESSAGE_TYPE:
    [self handleHostLookupWithNetI2pDataI2cpHostLookupMessage:(NetI2pDataI2cpHostLookupMessage *) cast_chk(message, [NetI2pDataI2cpHostLookupMessage class])];
    break;
    case NetI2pDataI2cpReconfigureSessionMessage_MESSAGE_TYPE:
    NetI2pRouterClientClientMessageEventListener_handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage_(self, (NetI2pDataI2cpReconfigureSessionMessage *) cast_chk(message, [NetI2pDataI2cpReconfigureSessionMessage class]));
    break;
    case NetI2pDataI2cpGetBandwidthLimitsMessage_MESSAGE_TYPE:
    [self handleGetBWLimitsWithNetI2pDataI2cpGetBandwidthLimitsMessage:(NetI2pDataI2cpGetBandwidthLimitsMessage *) cast_chk(message, [NetI2pDataI2cpGetBandwidthLimitsMessage class])];
    break;
    default:
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$I", @"Unhandled I2CP type received: ", [message getType])];
  }
}

- (void)readErrorWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader
                               withJavaLangException:(JavaLangException *)error {
  if ([((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) isDead]) return;
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Error occurred" withJavaLangThrowable:error];
  [_runner_ disconnectClientWithNSString:[((JavaLangException *) nil_chk(error)) description]];
  [_runner_ stopRunning];
}

- (void)disconnectedWithNetI2pDataI2cpI2CPMessageReader:(NetI2pDataI2cpI2CPMessageReader *)reader {
  if ([((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) isDead]) return;
  [_runner_ disconnected];
}

- (void)handleGetDateWithNetI2pDataI2cpGetDateMessage:(NetI2pDataI2cpGetDateMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleGetDateWithNetI2pDataI2cpGetDateMessage_(self, message);
}

- (void)handleSetDateWithNetI2pDataI2cpSetDateMessage:(NetI2pDataI2cpSetDateMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleSetDateWithNetI2pDataI2cpSetDateMessage_(self, message);
}

- (void)handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage:(NetI2pDataI2cpCreateSessionMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage_(self, message);
}

- (jboolean)checkAuthWithJavaUtilProperties:(JavaUtilProperties *)props {
  return NetI2pRouterClientClientMessageEventListener_checkAuthWithJavaUtilProperties_(self, props);
}

- (void)startCreateSessionJobWithNetI2pDataI2cpSessionConfig:(NetI2pDataI2cpSessionConfig *)config {
  [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) jobQueue])) addJobWithNetI2pRouterJob:create_NetI2pRouterClientCreateSessionJob_initWithNetI2pRouterRouterContext_withNetI2pDataI2cpSessionConfig_(_context_, config)];
}

- (void)handleSendMessageWithNetI2pDataI2cpSendMessageMessage:(NetI2pDataI2cpSendMessageMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleSendMessageWithNetI2pDataI2cpSendMessageMessage_(self, message);
}

- (void)handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage:(NetI2pDataI2cpReceiveMessageBeginMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage_(self, message);
}

- (void)handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage:(NetI2pDataI2cpReceiveMessageEndMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage_(self, message);
}

- (void)handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage:(NetI2pDataI2cpDestroySessionMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage_(self, message);
}

- (void)handleCreateLeaseSetWithNetI2pDataI2cpCreateLeaseSetMessage:(NetI2pDataI2cpCreateLeaseSetMessage *)message {
  if (([((NetI2pDataI2cpCreateLeaseSetMessage *) nil_chk(message)) getLeaseSet] == nil) || ([message getPrivateKey] == nil) || ([message getSigningPrivateKey] == nil)) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:JreStrcat("$@", @"Null lease set granted: ", message)];
    [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) disconnectClientWithNSString:@"Invalid CreateLeaseSetMessage"];
    return;
  }
  NetI2pDataI2cpSessionId *id_ = [message getSessionId];
  NetI2pDataI2cpSessionConfig *cfg = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) getConfigWithNetI2pDataI2cpSessionId:id_];
  if (cfg == nil) {
    id<JavaUtilList> current = [_runner_ getSessionIds];
    NSString *msg = JreStrcat("$@$@", @"CreateLeaseSet invalid session: ", id_, @" current: ", current);
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:msg];
    [_runner_ disconnectClientWithNSString:msg];
    return;
  }
  NetI2pDataDestination *dest = [cfg getDestination];
  NetI2pDataDestination *ndest = [((NetI2pDataLeaseSet *) nil_chk([message getLeaseSet])) getDestination];
  if (![((NetI2pDataDestination *) nil_chk(dest)) isEqual:ndest]) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Different destination in LS"];
    [_runner_ disconnectClientWithNSString:@"Different destination in LS"];
    return;
  }
  NetI2pRouterLeaseSetKeys *keys = [((NetI2pRouterKeyManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) keyManager])) getKeysWithNetI2pDataDestination:dest];
  if (keys == nil || ![((NetI2pDataPrivateKey *) nil_chk([message getPrivateKey])) isEqual:[keys getDecryptionKey]]) {
    NetI2pDataPublicKey *pk;
    @try {
      pk = [((NetI2pDataPrivateKey *) nil_chk([message getPrivateKey])) toPublic];
    }
    @catch (JavaLangIllegalArgumentException *iae) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Bad private key in LS"];
      [_runner_ disconnectClientWithNSString:@"Bad private key in LS"];
      return;
    }
    if (![((NetI2pDataPublicKey *) nil_chk(pk)) isEqual:[((NetI2pDataLeaseSet *) nil_chk([message getLeaseSet])) getEncryptionKey]]) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Private/public crypto key mismatch in LS"];
      [_runner_ disconnectClientWithNSString:@"Private/public crypto key mismatch in LS"];
      return;
    }
    [((NetI2pRouterKeyManager *) nil_chk([_context_ keyManager])) registerKeysWithNetI2pDataDestination:dest withNetI2pDataSigningPrivateKey:[message getSigningPrivateKey] withNetI2pDataPrivateKey:[message getPrivateKey]];
  }
  else if (![((NetI2pDataSigningPrivateKey *) nil_chk([message getSigningPrivateKey])) isEqual:[keys getRevocationKey]]) {
    [((NetI2pRouterKeyManager *) nil_chk([_context_ keyManager])) registerKeysWithNetI2pDataDestination:dest withNetI2pDataSigningPrivateKey:[message getSigningPrivateKey] withNetI2pDataPrivateKey:[message getPrivateKey]];
  }
  @try {
    [((NetI2pRouterNetworkDatabaseFacade *) nil_chk([_context_ netDb])) publishWithNetI2pDataLeaseSet:[message getLeaseSet]];
  }
  @catch (JavaLangIllegalArgumentException *iae) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [_log_ errorWithNSString:@"Invalid leaseset from client" withJavaLangThrowable:iae];
    [_runner_ disconnectClientWithNSString:JreStrcat("$@", @"Invalid leaseset: ", iae)];
    return;
  }
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$@", @"New lease set granted for destination ", dest)];
  [_runner_ leaseSetCreatedWithNetI2pDataLeaseSet:[message getLeaseSet]];
}

- (void)handleDestLookupWithNetI2pDataI2cpDestLookupMessage:(NetI2pDataI2cpDestLookupMessage *)message {
  [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) jobQueue])) addJobWithNetI2pRouterJob:create_NetI2pRouterClientLookupDestJob_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withNetI2pDataHash_withNetI2pDataHash_(_context_, _runner_, [((NetI2pDataI2cpDestLookupMessage *) nil_chk(message)) getHash], [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) getDestHash])];
}

- (void)handleHostLookupWithNetI2pDataI2cpHostLookupMessage:(NetI2pDataI2cpHostLookupMessage *)message {
  NetI2pDataI2cpSessionId *sid = [((NetI2pDataI2cpHostLookupMessage *) nil_chk(message)) getSessionId];
  NetI2pDataHash *h;
  if (sid != nil) {
    h = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) getDestHashWithNetI2pDataI2cpSessionId:sid];
  }
  else {
    if ([message getReqID] >= 0) sid = create_NetI2pDataI2cpSessionId_initWithInt_(65535);
    h = nil;
  }
  if (h == nil) {
    h = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) getDestHash];
  }
  [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) jobQueue])) addJobWithNetI2pRouterJob:create_NetI2pRouterClientLookupDestJob_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withLong_withLong_withNetI2pDataI2cpSessionId_withNetI2pDataHash_withNSString_withNetI2pDataHash_(_context_, _runner_, [message getReqID], [message getTimeout], sid, [message getHash], [message getHostname], h)];
}

- (void)handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage:(NetI2pDataI2cpReconfigureSessionMessage *)message {
  NetI2pRouterClientClientMessageEventListener_handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage_(self, message);
}

- (void)sendStatusMessageWithNetI2pDataI2cpSessionId:(NetI2pDataI2cpSessionId *)id_
                                             withInt:(jint)status {
  NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, status);
}

- (void)handleGetBWLimitsWithNetI2pDataI2cpGetBandwidthLimitsMessage:(NetI2pDataI2cpGetBandwidthLimitsMessage *)message {
  if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:@"Got BW Limits request"];
  jint in = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) bandwidthLimiter])) getInboundKBytesPerSecond] * 4 / 7;
  jint out = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([_context_ bandwidthLimiter])) getOutboundKBytesPerSecond] * 4 / 7;
  NetI2pDataI2cpBandwidthLimitsMessage *msg = create_NetI2pDataI2cpBandwidthLimitsMessage_initWithInt_withInt_(in, out);
  @try {
    [((NetI2pRouterClientClientConnectionRunner *) nil_chk(_runner_)) doSendWithNetI2pDataI2cpI2CPMessage:msg];
  }
  @catch (NetI2pDataI2cpI2CPMessageException *ime) {
    if ([_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Error writing bw limits msg" withJavaLangThrowable:ime];
  }
}

- (void)dealloc {
  RELEASE_(_log_);
  RELEASE_(_context_);
  RELEASE_(_runner_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 17, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 25, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 27, 28, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 29, 30, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 33, 34, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 35, 36, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:withNetI2pRouterClientClientConnectionRunner:withBoolean:);
  methods[1].selector = @selector(messageReceivedWithNetI2pDataI2cpI2CPMessageReader:withNetI2pDataI2cpI2CPMessage:);
  methods[2].selector = @selector(readErrorWithNetI2pDataI2cpI2CPMessageReader:withJavaLangException:);
  methods[3].selector = @selector(disconnectedWithNetI2pDataI2cpI2CPMessageReader:);
  methods[4].selector = @selector(handleGetDateWithNetI2pDataI2cpGetDateMessage:);
  methods[5].selector = @selector(handleSetDateWithNetI2pDataI2cpSetDateMessage:);
  methods[6].selector = @selector(handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage:);
  methods[7].selector = @selector(checkAuthWithJavaUtilProperties:);
  methods[8].selector = @selector(startCreateSessionJobWithNetI2pDataI2cpSessionConfig:);
  methods[9].selector = @selector(handleSendMessageWithNetI2pDataI2cpSendMessageMessage:);
  methods[10].selector = @selector(handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage:);
  methods[11].selector = @selector(handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage:);
  methods[12].selector = @selector(handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage:);
  methods[13].selector = @selector(handleCreateLeaseSetWithNetI2pDataI2cpCreateLeaseSetMessage:);
  methods[14].selector = @selector(handleDestLookupWithNetI2pDataI2cpDestLookupMessage:);
  methods[15].selector = @selector(handleHostLookupWithNetI2pDataI2cpHostLookupMessage:);
  methods[16].selector = @selector(handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage:);
  methods[17].selector = @selector(sendStatusMessageWithNetI2pDataI2cpSessionId:withInt:);
  methods[18].selector = @selector(handleGetBWLimitsWithNetI2pDataI2cpGetBandwidthLimitsMessage:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_context_", "LNetI2pRouterRouterContext;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_runner_", "LNetI2pRouterClientClientConnectionRunner;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_enforceAuth_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_authorized_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "PROP_AUTH", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 37, -1, -1 },
    { "PROP_AUTH_STRICT", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 38, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;LNetI2pRouterClientClientConnectionRunner;Z", "messageReceived", "LNetI2pDataI2cpI2CPMessageReader;LNetI2pDataI2cpI2CPMessage;", "readError", "LNetI2pDataI2cpI2CPMessageReader;LJavaLangException;", "disconnected", "LNetI2pDataI2cpI2CPMessageReader;", "handleGetDate", "LNetI2pDataI2cpGetDateMessage;", "handleSetDate", "LNetI2pDataI2cpSetDateMessage;", "handleCreateSession", "LNetI2pDataI2cpCreateSessionMessage;", "checkAuth", "LJavaUtilProperties;", "startCreateSessionJob", "LNetI2pDataI2cpSessionConfig;", "handleSendMessage", "LNetI2pDataI2cpSendMessageMessage;", "handleReceiveBegin", "LNetI2pDataI2cpReceiveMessageBeginMessage;", "handleReceiveEnd", "LNetI2pDataI2cpReceiveMessageEndMessage;", "handleDestroySession", "LNetI2pDataI2cpDestroySessionMessage;", "handleCreateLeaseSet", "LNetI2pDataI2cpCreateLeaseSetMessage;", "handleDestLookup", "LNetI2pDataI2cpDestLookupMessage;", "handleHostLookup", "LNetI2pDataI2cpHostLookupMessage;", "handleReconfigureSession", "LNetI2pDataI2cpReconfigureSessionMessage;", "sendStatusMessage", "LNetI2pDataI2cpSessionId;I", "handleGetBWLimits", "LNetI2pDataI2cpGetBandwidthLimitsMessage;", &NetI2pRouterClientClientMessageEventListener_PROP_AUTH, &NetI2pRouterClientClientMessageEventListener_PROP_AUTH_STRICT };
  static const J2ObjcClassInfo _NetI2pRouterClientClientMessageEventListener = { "ClientMessageEventListener", "net.i2p.router.client", ptrTable, methods, fields, 7, 0x0, 19, 7, -1, -1, -1, -1, -1 };
  return &_NetI2pRouterClientClientMessageEventListener;
}

@end

void NetI2pRouterClientClientMessageEventListener_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_(NetI2pRouterClientClientMessageEventListener *self, NetI2pRouterRouterContext *context, NetI2pRouterClientClientConnectionRunner *runner, jboolean enforceAuth) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) logManager])) getLogWithIOSClass:NetI2pRouterClientClientMessageEventListener_class_()]);
  JreStrongAssign(&self->_runner_, runner);
  self->_enforceAuth_ = enforceAuth;
  if ((!self->_enforceAuth_) || ![self->_context_ getBooleanPropertyWithNSString:NetI2pRouterClientClientMessageEventListener_PROP_AUTH]) JreAssignVolatileBoolean(&self->_authorized_, true);
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"client.distributeTime" withNSString:@"How long it took to inject the client message into the router" withNSString:@"ClientMessages" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000 } count:3]];
}

NetI2pRouterClientClientMessageEventListener *new_NetI2pRouterClientClientMessageEventListener_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_(NetI2pRouterRouterContext *context, NetI2pRouterClientClientConnectionRunner *runner, jboolean enforceAuth) {
  J2OBJC_NEW_IMPL(NetI2pRouterClientClientMessageEventListener, initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_, context, runner, enforceAuth)
}

NetI2pRouterClientClientMessageEventListener *create_NetI2pRouterClientClientMessageEventListener_initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_(NetI2pRouterRouterContext *context, NetI2pRouterClientClientConnectionRunner *runner, jboolean enforceAuth) {
  J2OBJC_CREATE_IMPL(NetI2pRouterClientClientMessageEventListener, initWithNetI2pRouterRouterContext_withNetI2pRouterClientClientConnectionRunner_withBoolean_, context, runner, enforceAuth)
}

void NetI2pRouterClientClientMessageEventListener_handleGetDateWithNetI2pDataI2cpGetDateMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpGetDateMessage *message) {
  NSString *clientVersion = [((NetI2pDataI2cpGetDateMessage *) nil_chk(message)) getVersion];
  if (clientVersion != nil) [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) setClientVersionWithNSString:clientVersion];
  JavaUtilProperties *props = [message getOptions];
  if (!NetI2pRouterClientClientMessageEventListener_checkAuthWithJavaUtilProperties_(self, props)) return;
  @try {
    [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) doSendWithNetI2pDataI2cpI2CPMessage:create_NetI2pDataI2cpSetDateMessage_initWithNSString_(clientVersion != nil ? NetI2pCoreVersion_VERSION : nil)];
  }
  @catch (NetI2pDataI2cpI2CPMessageException *ime) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [self->_log_ errorWithNSString:@"Error writing out the setDate message" withJavaLangThrowable:ime];
  }
}

void NetI2pRouterClientClientMessageEventListener_handleSetDateWithNetI2pDataI2cpSetDateMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSetDateMessage *message) {
}

void NetI2pRouterClientClientMessageEventListener_handleCreateSessionWithNetI2pDataI2cpCreateSessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpCreateSessionMessage *message) {
  NetI2pDataI2cpSessionConfig *in = [((NetI2pDataI2cpCreateSessionMessage *) nil_chk(message)) getSessionConfig];
  NetI2pDataDestination *dest = [((NetI2pDataI2cpSessionConfig *) nil_chk(in)) getDestination];
  if ([in verifySignature]) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:@"Signature verified correctly on create session message"];
  }
  else {
    jint itype = [((NetI2pDataCertificate *) nil_chk([((NetI2pDataDestination *) nil_chk(dest)) getCertificate])) getCertificateType];
    NetI2pCryptoSigType *stype = NetI2pCryptoSigType_getByCodeWithInt_(itype);
    if (stype == nil || ![stype isAvailable]) {
      [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:JreStrcat("$I", @"Client requested unsupported signature type ", itype)];
      [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) disconnectClientWithNSString:JreStrcat("$I", @"Unsupported signature type ", itype)];
    }
    else if ([in tooOld]) {
      jlong skew = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) clock])) now] - [((JavaUtilDate *) nil_chk([in getCreationDate])) getTime];
      NSString *msg = @"Create session message client clock skew? ";
      if (skew >= 0) JreStrAppend(&msg, "$$", NetI2pDataDataHelper_formatDurationWithLong_(skew), @" in the past");
      else JreStrAppend(&msg, "$$", NetI2pDataDataHelper_formatDurationWithLong_(0 - skew), @" in the future");
      [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:msg];
      [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) disconnectClientWithNSString:msg];
    }
    else {
      [((NetI2pUtilLog *) nil_chk(self->_log_)) errorWithNSString:@"Signature verification failed on a create session message"];
      [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) disconnectClientWithNSString:@"Invalid signature on CreateSessionMessage"];
    }
    return;
  }
  JavaUtilProperties *inProps = [in getOptions];
  if (!NetI2pRouterClientClientMessageEventListener_checkAuthWithJavaUtilProperties_(self, inProps)) return;
  NetI2pDataI2cpSessionId *id_ = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) getSessionIdWithNetI2pDataHash:[((NetI2pDataDestination *) nil_chk(dest)) calculateHash]];
  if (id_ != nil) {
    [self->_runner_ disconnectClientWithNSString:JreStrcat("$@", @"Already have session ", id_)];
    return;
  }
  NetI2pDataI2cpSessionConfig *cfg = create_NetI2pDataI2cpSessionConfig_initWithNetI2pDataDestination_(dest);
  [cfg setSignatureWithNetI2pDataSignature:[in getSignature]];
  JavaUtilProperties *props = create_JavaUtilProperties_init();
  jboolean isPrimary = [((id<JavaUtilList>) nil_chk([self->_runner_ getSessionIds])) isEmpty];
  if (!isPrimary) {
    NetI2pDataI2cpSessionConfig *pcfg = [self->_runner_ getPrimaryConfig];
    if (pcfg != nil) {
      [props putAllWithJavaUtilMap:[pcfg getOptions]];
    }
    else {
      [self->_log_ errorWithNSString:@"no primary config?"];
    }
  }
  [props putAllWithJavaUtilMap:inProps];
  [cfg setOptionsWithJavaUtilProperties:props];
  jint status = [self->_runner_ sessionEstablishedWithNetI2pDataI2cpSessionConfig:cfg];
  if (status != NetI2pDataI2cpSessionStatusMessage_STATUS_CREATED) {
    if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_ERROR]) [self->_log_ errorWithNSString:JreStrcat("$I", @"Session establish failed: code = ", status)];
    NSString *msg;
    if (status == NetI2pDataI2cpSessionStatusMessage_STATUS_INVALID) msg = @"duplicate destination";
    else if (status == NetI2pDataI2cpSessionStatusMessage_STATUS_REFUSED) msg = @"session limit exceeded";
    else msg = @"unknown error";
    [self->_runner_ disconnectClientWithNSString:msg];
    return;
  }
  id_ = [self->_runner_ getSessionIdWithNetI2pDataHash:[dest calculateHash]];
  if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$@$@", @"Session ", id_, @" established for ", [dest calculateHash])];
  if (isPrimary) {
    NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, status);
    [self startCreateSessionJobWithNetI2pDataI2cpSessionConfig:cfg];
  }
  else {
    NetI2pDataI2cpSessionConfig *pcfg = [self->_runner_ getPrimaryConfig];
    if (pcfg != nil) {
      NetI2pRouterClientTunnelSettings *settings = create_NetI2pRouterClientTunnelSettings_initWithNetI2pDataHash_([dest calculateHash]);
      [settings readFromPropertiesWithJavaUtilProperties:props];
      NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, status);
      jboolean ok = [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) tunnelManager])) addAliasWithNetI2pDataDestination:dest withNetI2pRouterClientTunnelSettings:settings withNetI2pDataDestination:[pcfg getDestination]];
      if (!ok) {
        [self->_log_ errorWithNSString:@"Add alias failed"];
      }
    }
    else {
      [self->_log_ errorWithNSString:@"no primary config?"];
      status = NetI2pDataI2cpSessionStatusMessage_STATUS_INVALID;
      NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, status);
    }
  }
}

jboolean NetI2pRouterClientClientMessageEventListener_checkAuthWithJavaUtilProperties_(NetI2pRouterClientClientMessageEventListener *self, JavaUtilProperties *props) {
  if (JreLoadVolatileBoolean(&self->_authorized_)) return true;
  if (self->_enforceAuth_ && [((NetI2pRouterRouterContext *) nil_chk(self->_context_)) getBooleanPropertyWithNSString:NetI2pRouterClientClientMessageEventListener_PROP_AUTH]) {
    NSString *user = nil;
    NSString *pw = nil;
    if (props != nil) {
      user = [props getPropertyWithNSString:@"i2cp.username"];
      pw = [props getPropertyWithNSString:@"i2cp.password"];
    }
    if (user == nil || [user java_length] == 0 || pw == nil || [pw java_length] == 0) {
      [((NetI2pUtilLog *) nil_chk(self->_log_)) logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:@"I2CP authentication failed"];
      [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) disconnectClientWithNSString:@"Authorization required, specify i2cp.username and i2cp.password in options"];
      JreAssignVolatileBoolean(&self->_authorized_, false);
      return false;
    }
    NetI2pUtilPasswordManager *mgr = create_NetI2pUtilPasswordManager_initWithNetI2pI2PAppContext_(self->_context_);
    if (![mgr checkHashWithNSString:NetI2pRouterClientClientMessageEventListener_PROP_AUTH withNSString:user withNSString:pw]) {
      [((NetI2pUtilLog *) nil_chk(self->_log_)) logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:JreStrcat("$$", @"I2CP authentication failed, user: ", user)];
      [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) disconnectClientWithNSString:JreStrcat("$$", @"Authorization failed, user = ", user)];
      JreAssignVolatileBoolean(&self->_authorized_, false);
      return false;
    }
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$$", @"I2CP auth success user: ", user)];
  }
  JreAssignVolatileBoolean(&self->_authorized_, true);
  return true;
}

void NetI2pRouterClientClientMessageEventListener_handleSendMessageWithNetI2pDataI2cpSendMessageMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSendMessageMessage *message) {
  NetI2pDataI2cpSessionId *sid = [((NetI2pDataI2cpSendMessageMessage *) nil_chk(message)) getSessionId];
  NetI2pDataI2cpSessionConfig *cfg = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) getConfigWithNetI2pDataI2cpSessionId:sid];
  if (cfg == nil) {
    id<JavaUtilList> current = [self->_runner_ getSessionIds];
    NSString *msg = JreStrcat("$@$@", @"SendMessage invalid session: ", sid, @" current: ", current);
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [self->_log_ errorWithNSString:msg];
    if (sid != nil && [message getNonce] > 0) {
      NetI2pDataI2cpMessageStatusMessage *status = create_NetI2pDataI2cpMessageStatusMessage_init();
      [status setMessageIdWithLong:[self->_runner_ getNextMessageId]];
      [status setSessionIdWithLong:[sid getSessionId]];
      [status setSizeWithLong:0];
      [status setNonceWithLong:[message getNonce]];
      [status setStatusWithInt:NetI2pDataI2cpMessageStatusMessage_STATUS_SEND_FAILURE_BAD_SESSION];
      @try {
        [self->_runner_ doSendWithNetI2pDataI2cpI2CPMessage:status];
      }
      @catch (NetI2pDataI2cpI2CPMessageException *ime) {
        if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"Error writing out the message status message" withJavaLangThrowable:ime];
      }
    }
    return;
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:@"handleSendMessage called"];
  jlong beforeDistribute = [((NetI2pUtilClock *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) clock])) now];
  NetI2pDataI2cpMessageId *id_ = [self->_runner_ distributeMessageWithNetI2pDataI2cpSendMessageMessage:message];
  jlong timeToDistribute = [((NetI2pUtilClock *) nil_chk([self->_context_ clock])) now] - beforeDistribute;
  [self->_runner_ ackSendMessageWithNetI2pDataI2cpSessionId:sid withNetI2pDataI2cpMessageId:id_ withLong:[message getNonce]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"client.distributeTime" withLong:timeToDistribute];
  if ((timeToDistribute > 50) && ([self->_log_ shouldLogWithInt:NetI2pUtilLog_DEBUG])) [self->_log_ debugWithNSString:JreStrcat("$J", @"Took too long to distribute the message (which holds up the ack): ", timeToDistribute)];
}

void NetI2pRouterClientClientMessageEventListener_handleReceiveBeginWithNetI2pDataI2cpReceiveMessageBeginMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReceiveMessageBeginMessage *message) {
  if ([((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) isDead]) return;
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$J", @"Handling receive begin: id = ", [((NetI2pDataI2cpReceiveMessageBeginMessage *) nil_chk(message)) getMessageId])];
  NetI2pDataI2cpMessagePayloadMessage *msg = create_NetI2pDataI2cpMessagePayloadMessage_init();
  [msg setMessageIdWithLong:[((NetI2pDataI2cpReceiveMessageBeginMessage *) nil_chk(message)) getMessageId]];
  [msg setSessionIdWithLong:[message getSessionId]];
  NetI2pDataPayload *payload = [self->_runner_ getPayloadWithNetI2pDataI2cpMessageId:create_NetI2pDataI2cpMessageId_initWithLong_([message getMessageId])];
  if (payload == nil) {
    if ([self->_log_ shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$J$", @"Payload for message id [", [message getMessageId], @"] is null!  Dropped or Unknown message id")];
    return;
  }
  [msg setPayloadWithNetI2pDataPayload:payload];
  @try {
    [self->_runner_ doSendWithNetI2pDataI2cpI2CPMessage:msg];
  }
  @catch (NetI2pDataI2cpI2CPMessageException *ime) {
    NSString *emsg = JreStrcat("$@", @"Error sending data to client ", [self->_runner_ getDestHash]);
    if ([self->_log_ shouldWarn]) [self->_log_ warnWithNSString:emsg withJavaLangThrowable:ime];
    else [self->_log_ logAlwaysWithInt:NetI2pUtilLog_WARN withNSString:emsg];
    [self->_runner_ removePayloadWithNetI2pDataI2cpMessageId:create_NetI2pDataI2cpMessageId_initWithLong_([message getMessageId])];
  }
}

void NetI2pRouterClientClientMessageEventListener_handleReceiveEndWithNetI2pDataI2cpReceiveMessageEndMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReceiveMessageEndMessage *message) {
  [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) removePayloadWithNetI2pDataI2cpMessageId:create_NetI2pDataI2cpMessageId_initWithLong_([((NetI2pDataI2cpReceiveMessageEndMessage *) nil_chk(message)) getMessageId])];
}

void NetI2pRouterClientClientMessageEventListener_handleDestroySessionWithNetI2pDataI2cpDestroySessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpDestroySessionMessage *message) {
  NetI2pDataI2cpSessionId *id_ = [((NetI2pDataI2cpDestroySessionMessage *) nil_chk(message)) getSessionId];
  if (id_ != nil) {
    [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) removeSessionWithNetI2pDataI2cpSessionId:id_];
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"destroy session with null ID"];
  }
  jint left = [((id<JavaUtilList>) nil_chk([((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) getSessionIds])) size];
  if (left <= 0 || id_ == nil) {
    [self->_runner_ stopRunning];
  }
  else {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$I$", @"Still ", left, @" sessions left")];
  }
}

void NetI2pRouterClientClientMessageEventListener_handleReconfigureSessionWithNetI2pDataI2cpReconfigureSessionMessage_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpReconfigureSessionMessage *message) {
  NetI2pDataI2cpSessionId *id_ = [((NetI2pDataI2cpReconfigureSessionMessage *) nil_chk(message)) getSessionId];
  NetI2pDataI2cpSessionConfig *cfg = [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) getConfigWithNetI2pDataI2cpSessionId:id_];
  if (cfg == nil) {
    id<JavaUtilList> current = [self->_runner_ getSessionIds];
    NSString *msg = JreStrcat("$@$@", @"ReconfigureSession invalid session: ", id_, @" current: ", current);
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_ERROR]) [self->_log_ errorWithNSString:msg];
    [self->_runner_ disconnectClientWithNSString:msg];
    return;
  }
  if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [self->_log_ infoWithNSString:JreStrcat("$@$@", @"Updating options - old: ", cfg, @" new: ", [message getSessionConfig])];
  if (![((NetI2pDataDestination *) nil_chk([((NetI2pDataI2cpSessionConfig *) nil_chk([message getSessionConfig])) getDestination])) isEqual:[cfg getDestination]]) {
    [self->_log_ errorWithNSString:@"Dest mismatch"];
    NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, NetI2pDataI2cpSessionStatusMessage_STATUS_INVALID);
    [self->_runner_ stopRunning];
    return;
  }
  NetI2pDataHash *dest = [((NetI2pDataDestination *) nil_chk([cfg getDestination])) calculateHash];
  [((JavaUtilProperties *) nil_chk([cfg getOptions])) putAllWithJavaUtilMap:[((NetI2pDataI2cpSessionConfig *) nil_chk([message getSessionConfig])) getOptions]];
  NetI2pRouterClientTunnelSettings *settings = create_NetI2pRouterClientTunnelSettings_initWithNetI2pDataHash_(dest);
  JavaUtilProperties *props = create_JavaUtilProperties_init();
  [props putAllWithJavaUtilMap:[cfg getOptions]];
  [settings readFromPropertiesWithJavaUtilProperties:props];
  [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) tunnelManager])) setInboundSettingsWithNetI2pDataHash:dest withNetI2pRouterTunnelPoolSettings:[settings getInboundSettings]];
  [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([self->_context_ tunnelManager])) setOutboundSettingsWithNetI2pDataHash:dest withNetI2pRouterTunnelPoolSettings:[settings getOutboundSettings]];
  NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(self, id_, NetI2pDataI2cpSessionStatusMessage_STATUS_UPDATED);
}

void NetI2pRouterClientClientMessageEventListener_sendStatusMessageWithNetI2pDataI2cpSessionId_withInt_(NetI2pRouterClientClientMessageEventListener *self, NetI2pDataI2cpSessionId *id_, jint status) {
  NetI2pDataI2cpSessionStatusMessage *msg = create_NetI2pDataI2cpSessionStatusMessage_init();
  [msg setSessionIdWithNetI2pDataI2cpSessionId:id_];
  [msg setStatusWithInt:status];
  @try {
    [((NetI2pRouterClientClientConnectionRunner *) nil_chk(self->_runner_)) doSendWithNetI2pDataI2cpI2CPMessage:msg];
  }
  @catch (NetI2pDataI2cpI2CPMessageException *ime) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:@"Error writing out the session status message" withJavaLangThrowable:ime];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterClientClientMessageEventListener)
