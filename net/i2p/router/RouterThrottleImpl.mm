//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: router/java/src/net/i2p/router/RouterThrottleImpl.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/annotation/Annotation.h"
#include "net/i2p/data/Hash.h"
#include "net/i2p/data/router/RouterInfo.h"
#include "net/i2p/router/JobQueue.h"
#include "net/i2p/router/Router.h"
#include "net/i2p/router/RouterContext.h"
#include "net/i2p/router/RouterThrottleImpl.h"
#include "net/i2p/router/TunnelManagerFacade.h"
#include "net/i2p/router/peermanager/TunnelHistory.h"
#include "net/i2p/router/transport/FIFOBandwidthLimiter.h"
#include "net/i2p/stat/Rate.h"
#include "net/i2p/stat/RateAverages.h"
#include "net/i2p/stat/RateStat.h"
#include "net/i2p/stat/StatManager.h"
#include "net/i2p/util/Log.h"
#include "net/i2p/util/LogManager.h"
#include "net/i2p/util/RandomSource.h"
#include "net/i2p/util/SimpleTimer.h"
#include "net/i2p/util/SimpleTimer2.h"
#include "net/i2p/util/SystemVersion.h"

@interface NetI2pRouterRouterThrottleImpl () {
 @public
  NetI2pUtilLog *_log_;
  volatile_id _tunnelStatus_;
  jlong _rejectStartupTime_;
}

- (jboolean)allowTunnelWithDouble:(jdouble)bytesAllocated
                          withInt:(jint)numTunnels;

- (jint)getMinThrottleTunnels;

- (jdouble)getTunnelGrowthFactor;

- (jdouble)getTunnelTestTimeGrowthFactor;

+ (jdouble)getBpsWithNetI2pStatRate:(NetI2pStatRate *)rate;

- (void)setTunnelStatus;

+ (NSString *)_xWithNSString:(NSString *)s;

@end

J2OBJC_FIELD_SETTER(NetI2pRouterRouterThrottleImpl, _log_, NetI2pUtilLog *)
J2OBJC_VOLATILE_FIELD_SETTER(NetI2pRouterRouterThrottleImpl, _tunnelStatus_, NSString *)

inline jlong NetI2pRouterRouterThrottleImpl_get_JOB_LAG_LIMIT_NETWORK(void);
#define NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETWORK 2000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, JOB_LAG_LIMIT_NETWORK, jlong)

inline jlong NetI2pRouterRouterThrottleImpl_get_JOB_LAG_LIMIT_NETDB(void);
#define NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETDB 2000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, JOB_LAG_LIMIT_NETDB, jlong)

inline jlong NetI2pRouterRouterThrottleImpl_get_JOB_LAG_LIMIT_TUNNEL(void);
#define NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_TUNNEL 500LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, JOB_LAG_LIMIT_TUNNEL, jlong)

inline NSString *NetI2pRouterRouterThrottleImpl_get_PROP_MAX_PROCESSINGTIME(void);
static NSString *NetI2pRouterRouterThrottleImpl_PROP_MAX_PROCESSINGTIME = @"router.defaultProcessingTimeThrottle";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterRouterThrottleImpl, PROP_MAX_PROCESSINGTIME, NSString *)

inline jlong NetI2pRouterRouterThrottleImpl_get_DEFAULT_REJECT_STARTUP_TIME(void);
#define NetI2pRouterRouterThrottleImpl_DEFAULT_REJECT_STARTUP_TIME 600000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, DEFAULT_REJECT_STARTUP_TIME, jlong)

inline jlong NetI2pRouterRouterThrottleImpl_get_MIN_REJECT_STARTUP_TIME(void);
#define NetI2pRouterRouterThrottleImpl_MIN_REJECT_STARTUP_TIME 90000LL
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, MIN_REJECT_STARTUP_TIME, jlong)

inline NSString *NetI2pRouterRouterThrottleImpl_get_PROP_REJECT_STARTUP_TIME(void);
static NSString *NetI2pRouterRouterThrottleImpl_PROP_REJECT_STARTUP_TIME = @"router.rejectStartupTime";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterRouterThrottleImpl, PROP_REJECT_STARTUP_TIME, NSString *)

inline jint NetI2pRouterRouterThrottleImpl_get_DEFAULT_MIN_THROTTLE_TUNNELS(void);
static jint NetI2pRouterRouterThrottleImpl_DEFAULT_MIN_THROTTLE_TUNNELS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(NetI2pRouterRouterThrottleImpl, DEFAULT_MIN_THROTTLE_TUNNELS, jint)

inline jint NetI2pRouterRouterThrottleImpl_get_DEFAULT_MAX_PROCESSINGTIME(void);
#define NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_PROCESSINGTIME 2250
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, DEFAULT_MAX_PROCESSINGTIME, jint)

inline jint NetI2pRouterRouterThrottleImpl_get_PREPROCESSED_SIZE(void);
#define NetI2pRouterRouterThrottleImpl_PREPROCESSED_SIZE 1024
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, PREPROCESSED_SIZE, jint)

inline jint NetI2pRouterRouterThrottleImpl_get_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE(void);
#define NetI2pRouterRouterThrottleImpl_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE 40
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE, jint)

inline jint NetI2pRouterRouterThrottleImpl_get_MIN_AVAILABLE_BPS(void);
#define NetI2pRouterRouterThrottleImpl_MIN_AVAILABLE_BPS 4096
J2OBJC_STATIC_FIELD_CONSTANT(NetI2pRouterRouterThrottleImpl, MIN_AVAILABLE_BPS, jint)

inline NSString *NetI2pRouterRouterThrottleImpl_get_LIMIT_STR(void);
static NSString *NetI2pRouterRouterThrottleImpl_LIMIT_STR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetI2pRouterRouterThrottleImpl, LIMIT_STR, NSString *)

__attribute__((unused)) static jboolean NetI2pRouterRouterThrottleImpl_allowTunnelWithDouble_withInt_(NetI2pRouterRouterThrottleImpl *self, jdouble bytesAllocated, jint numTunnels);

__attribute__((unused)) static jint NetI2pRouterRouterThrottleImpl_getMinThrottleTunnels(NetI2pRouterRouterThrottleImpl *self);

__attribute__((unused)) static jdouble NetI2pRouterRouterThrottleImpl_getTunnelGrowthFactor(NetI2pRouterRouterThrottleImpl *self);

__attribute__((unused)) static jdouble NetI2pRouterRouterThrottleImpl_getTunnelTestTimeGrowthFactor(NetI2pRouterRouterThrottleImpl *self);

__attribute__((unused)) static jdouble NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_(NetI2pStatRate *rate);

__attribute__((unused)) static void NetI2pRouterRouterThrottleImpl_setTunnelStatus(NetI2pRouterRouterThrottleImpl *self);

__attribute__((unused)) static NSString *NetI2pRouterRouterThrottleImpl__xWithNSString_(NSString *s);

__attribute__((unused)) static IOSObjectArray *NetI2pRouterRouterThrottleImpl__Annotations$0(void);

@interface NetI2pRouterRouterThrottleImpl_ResetStatus : NSObject < NetI2pUtilSimpleTimer_TimedEvent > {
 @public
  NetI2pRouterRouterThrottleImpl *this$0_;
}

- (instancetype)initWithNetI2pRouterRouterThrottleImpl:(NetI2pRouterRouterThrottleImpl *)outer$;

- (void)timeReached;

@end

J2OBJC_EMPTY_STATIC_INIT(NetI2pRouterRouterThrottleImpl_ResetStatus)

__attribute__((unused)) static void NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl_ResetStatus *self, NetI2pRouterRouterThrottleImpl *outer$);

__attribute__((unused)) static NetI2pRouterRouterThrottleImpl_ResetStatus *new_NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetI2pRouterRouterThrottleImpl_ResetStatus *create_NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl *outer$);

J2OBJC_TYPE_LITERAL_HEADER(NetI2pRouterRouterThrottleImpl_ResetStatus)

J2OBJC_INITIALIZED_DEFN(NetI2pRouterRouterThrottleImpl)

NSString *NetI2pRouterRouterThrottleImpl_PROP_MAX_TUNNELS = @"router.maxParticipatingTunnels";

@implementation NetI2pRouterRouterThrottleImpl

+ (NSString *)PROP_MAX_TUNNELS {
  return NetI2pRouterRouterThrottleImpl_PROP_MAX_TUNNELS;
}

+ (jint)DEFAULT_MAX_TUNNELS {
  return NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_TUNNELS;
}

+ (jint)TUNNEL_ACCEPT {
  return NetI2pRouterRouterThrottleImpl_TUNNEL_ACCEPT;
}

- (instancetype)initWithNetI2pRouterRouterContext:(NetI2pRouterRouterContext *)context {
  NetI2pRouterRouterThrottleImpl_initWithNetI2pRouterRouterContext_(self, context);
  return self;
}

- (jboolean)acceptNetworkMessage {
  jlong lag = [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) jobQueue])) getMaxLag];
  if ((lag > NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETWORK) && ([((NetI2pRouterRouter *) nil_chk([_context_ router])) getUptime] > 60 * 1000)) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$J", @"Throttling network reader, as the job lag is ", lag)];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"router.throttleNetworkCause" withLong:lag];
    return false;
  }
  else {
    return true;
  }
}

- (jboolean)acceptNetDbLookupRequestWithNetI2pDataHash:(NetI2pDataHash *)key {
  jlong lag = [((NetI2pRouterJobQueue *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) jobQueue])) getMaxLag];
  if (lag > NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETDB) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [_log_ debugWithNSString:JreStrcat("$J", @"Refusing netDb request, as the job lag is ", lag)];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"router.throttleNetDbCause" withLong:lag];
    return false;
  }
  else {
    return true;
  }
}

- (jint)acceptTunnelRequest {
  if ([((NetI2pRouterRouter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) router])) gracefulShutdownInProgress]) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:@"Refusing tunnel request since we are shutting down ASAP"];
    [self setShutdownStatus];
    return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_BANDWIDTH;
  }
  if ([((NetI2pRouterRouter *) nil_chk([_context_ router])) getUptime] < _rejectStartupTime_) {
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Starting up")];
    return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_BANDWIDTH;
  }
  NetI2pStatRateAverages *ra = NetI2pStatRateAverages_getTemp();
  NetI2pStatRateStat *rs = [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) getRateWithNSString:@"transport.sendProcessingTime"];
  NetI2pStatRate *r = nil;
  if (rs != nil) r = [rs getRateWithLong:60 * 1000];
  if (r != nil) {
    [r computeAveragesWithNetI2pStatRateAverages:ra withBoolean:false];
    jint maxProcessingTime = [_context_ getPropertyWithNSString:NetI2pRouterRouterThrottleImpl_PROP_MAX_PROCESSINGTIME withInt:NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_PROCESSINGTIME];
    if (([((NetI2pStatRateAverages *) nil_chk(ra)) getAverage] > maxProcessingTime * 0.9 || [ra getCurrent] > maxProcessingTime || [ra getLast] > maxProcessingTime)) {
      if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) {
        [_log_ warnWithNSString:JreStrcat("$I$I$I$I$", @"Refusing tunnel request due to sendProcessingTime ", (JreFpToInt([ra getCurrent])), @" / ", (JreFpToInt([ra getLast])), @" / ", (JreFpToInt([ra getAverage])), @" / ", maxProcessingTime, @" current/last/avg/max ms")];
      }
      [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: High message delay")];
      return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_BANDWIDTH;
    }
  }
  jint numTunnels = [((id<NetI2pRouterTunnelManagerFacade>) nil_chk([_context_ tunnelManager])) getParticipatingCount];
  jint maxTunnels = [_context_ getPropertyWithNSString:NetI2pRouterRouterThrottleImpl_PROP_MAX_TUNNELS withInt:NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_TUNNELS];
  if (numTunnels >= maxTunnels) {
    if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$I$IC", @"Refusing tunnel request since we are already participating in ", numTunnels, @" (our max is ", maxTunnels, ')')];
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"router.throttleTunnelMaxExceeded" withLong:numTunnels];
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Limit reached")];
    return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_BANDWIDTH;
  }
  if ((numTunnels > NetI2pRouterRouterThrottleImpl_getMinThrottleTunnels(self)) && (NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_TUNNELS >= maxTunnels)) {
    NetI2pStatRate *avgTunnels = [((NetI2pStatRateStat *) nil_chk([((NetI2pStatStatManager *) nil_chk([_context_ statManager])) getRateWithNSString:@"tunnel.participatingTunnels"])) getRateWithLong:10 * 60 * 1000];
    if (avgTunnels != nil) {
      jdouble avg = [avgTunnels getAvgOrLifetimeAvg];
      jdouble tunnelGrowthFactor = NetI2pRouterRouterThrottleImpl_getTunnelGrowthFactor(self);
      jint min = NetI2pRouterRouterThrottleImpl_getMinThrottleTunnels(self);
      if (avg < min) avg = min;
      if ((avg > 0) && (avg * tunnelGrowthFactor < numTunnels)) {
        jdouble probAccept = (avg * tunnelGrowthFactor) / numTunnels;
        JreTimesAssignDoubleD(&probAccept, probAccept);
        jint v = [((NetI2pUtilRandomSource *) nil_chk([_context_ random])) nextIntWithInt:100];
        if (v < probAccept * 100) {
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$D$I$D$IC", @"Probabalistically accept tunnel request (p=", probAccept, @" v=", v, @" avg=", avg, @" current=", numTunnels, ')')];
        }
        else {
          if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [_log_ warnWithNSString:JreStrcat("$D$IC", @"Probabalistically refusing tunnel request (avg=", avg, @" current=", numTunnels, ')')];
          [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"router.throttleTunnelProbTooFast" withLong:JreFpToLong((numTunnels - avg))];
          if (probAccept <= 0.5) [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting most tunnels: High number of requests")];
          else if (probAccept <= 0.9) [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Accepting most tunnels")];
          else [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Accepting tunnels")];
          return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_PROBABALISTIC_REJECT;
        }
      }
      else {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$D$IC", @"Accepting tunnel request, since the tunnel count average is ", avg, @" and we only have ", numTunnels, ')')];
      }
    }
  }
  jdouble tunnelTestTimeGrowthFactor = NetI2pRouterRouterThrottleImpl_getTunnelTestTimeGrowthFactor(self);
  NetI2pStatRate *tunnelTestTime1m = [((NetI2pStatRateStat *) nil_chk([((NetI2pStatStatManager *) nil_chk([_context_ statManager])) getRateWithNSString:@"tunnel.testSuccessTime"])) getRateWithLong:1 * 60 * 1000];
  NetI2pStatRate *tunnelTestTime10m = [((NetI2pStatRateStat *) nil_chk([((NetI2pStatStatManager *) nil_chk([_context_ statManager])) getRateWithNSString:@"tunnel.testSuccessTime"])) getRateWithLong:10 * 60 * 1000];
  if ((tunnelTestTime1m != nil) && (tunnelTestTime10m != nil) && ([((NetI2pStatRate *) nil_chk(tunnelTestTime1m)) getLastEventCount] > 0)) {
    jdouble avg1m = [((NetI2pStatRate *) nil_chk(tunnelTestTime1m)) getAverageValue];
    jdouble avg10m = [((NetI2pStatRate *) nil_chk(tunnelTestTime10m)) getAvgOrLifetimeAvg];
    if (avg10m < 5000) avg10m = 5000;
    if ((avg10m > 0) && (avg1m > avg10m * tunnelTestTimeGrowthFactor)) {
      jdouble probAccept = (avg10m * tunnelTestTimeGrowthFactor) / avg1m;
      probAccept = probAccept * probAccept;
      jint v = [((NetI2pUtilRandomSource *) nil_chk([_context_ random])) nextIntWithInt:100];
      if (v < probAccept * 100) {
        if ([((NetI2pUtilLog *) nil_chk(_log_)) shouldLogWithInt:NetI2pUtilLog_INFO]) [_log_ infoWithNSString:JreStrcat("$D$I$D$DC", @"Probabalistically accept tunnel request (p=", probAccept, @" v=", v, @" test time avg 1m=", avg1m, @" 10m=", avg10m, ')')];
      }
    }
    else {
    }
  }
  rs = [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) getRateWithNSString:@"tunnel.participatingMessageCountAvgPerTunnel"];
  r = nil;
  jdouble messagesPerTunnel = NetI2pRouterRouterThrottleImpl_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE;
  if (rs != nil) {
    r = [rs getRateWithLong:60 * 1000];
    if (r != nil) messagesPerTunnel = [((NetI2pStatRateAverages *) nil_chk([r computeAveragesWithNetI2pStatRateAverages:ra withBoolean:true])) getAverage];
  }
  if (messagesPerTunnel < NetI2pRouterRouterThrottleImpl_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE) messagesPerTunnel = NetI2pRouterRouterThrottleImpl_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE;
  jdouble bytesAllocated = messagesPerTunnel * numTunnels * NetI2pRouterRouterThrottleImpl_PREPROCESSED_SIZE;
  if (!NetI2pRouterRouterThrottleImpl_allowTunnelWithDouble_withInt_(self, bytesAllocated, numTunnels)) {
    [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"router.throttleTunnelBandwidthExceeded" withLong:JreFpToLong(bytesAllocated)];
    return NetI2pRouterPeermanagerTunnelHistory_TUNNEL_REJECT_BANDWIDTH;
  }
  [((NetI2pStatStatManager *) nil_chk([_context_ statManager])) addRateDataWithNSString:@"tunnel.bytesAllocatedAtAccept" withLong:JreFpToLong(bytesAllocated) withLong:60 * 10 * 1000];
  return NetI2pRouterRouterThrottleImpl_TUNNEL_ACCEPT;
}

- (jboolean)allowTunnelWithDouble:(jdouble)bytesAllocated
                          withInt:(jint)numTunnels {
  return NetI2pRouterRouterThrottleImpl_allowTunnelWithDouble_withInt_(self, bytesAllocated, numTunnels);
}

- (jint)getMinThrottleTunnels {
  return NetI2pRouterRouterThrottleImpl_getMinThrottleTunnels(self);
}

- (jdouble)getTunnelGrowthFactor {
  return NetI2pRouterRouterThrottleImpl_getTunnelGrowthFactor(self);
}

- (jdouble)getTunnelTestTimeGrowthFactor {
  return NetI2pRouterRouterThrottleImpl_getTunnelTestTimeGrowthFactor(self);
}

- (jlong)getMessageDelay {
  NetI2pStatRateStat *rs = [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) getRateWithNSString:@"transport.sendProcessingTime"];
  if (rs == nil) return 0;
  NetI2pStatRate *delayRate = [rs getRateWithLong:60 * 1000];
  return JreFpToLong([((NetI2pStatRate *) nil_chk(delayRate)) getAverageValue]);
}

- (jlong)getTunnelLag {
  NetI2pStatRate *lagRate = [((NetI2pStatRateStat *) nil_chk([((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) getRateWithNSString:@"tunnel.testSuccessTime"])) getRateWithLong:10 * 60 * 1000];
  return JreFpToLong([((NetI2pStatRate *) nil_chk(lagRate)) getAverageValue]);
}

- (jdouble)getInboundRateDelta {
  NetI2pStatRateStat *receiveRate = [((NetI2pStatStatManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(_context_)) statManager])) getRateWithNSString:@"transport.sendMessageSize"];
  if (receiveRate == nil) return 0;
  jdouble nowBps = NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_([receiveRate getRateWithLong:60 * 1000]);
  jdouble fiveMinBps = NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_([receiveRate getRateWithLong:5 * 60 * 1000]);
  jdouble hourBps = NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_([receiveRate getRateWithLong:60 * 60 * 1000]);
  jdouble dailyBps = NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_([receiveRate getRateWithLong:24 * 60 * 60 * 1000]);
  if (nowBps < 0) return 0;
  if (dailyBps > 0) return nowBps - dailyBps;
  if (hourBps > 0) return nowBps - hourBps;
  if (fiveMinBps > 0) return nowBps - fiveMinBps;
  return 0;
}

+ (jdouble)getBpsWithNetI2pStatRate:(NetI2pStatRate *)rate {
  return NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_(rate);
}

- (NSString *)getTunnelStatus {
  return JreLoadVolatileId(&_tunnelStatus_);
}

- (void)setTunnelStatus {
  NetI2pRouterRouterThrottleImpl_setTunnelStatus(self);
}

- (void)setShutdownStatus {
  [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Shutting down")];
}

- (void)cancelShutdownStatus {
  jint maxTunnels = [((NetI2pRouterRouterContext *) nil_chk(_context_)) getPropertyWithNSString:NetI2pRouterRouterThrottleImpl_PROP_MAX_TUNNELS withInt:NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_TUNNELS];
  NetI2pDataRouterRouterInfo *ri = [((NetI2pRouterRouter *) nil_chk([_context_ router])) getRouterInfo];
  if (maxTunnels > 0 && ![((NetI2pRouterRouter *) nil_chk([_context_ router])) isHidden] && ri != nil && ![((NSString *) nil_chk([ri getBandwidthTier])) isEqual:@"K"]) {
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Accepting tunnels")];
  }
  else {
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels")];
  }
}

- (void)setTunnelStatusWithNSString:(NSString *)msg {
  JreVolatileStrongAssign(&_tunnelStatus_, msg);
}

+ (NSString *)_xWithNSString:(NSString *)s {
  return NetI2pRouterRouterThrottleImpl__xWithNSString_(s);
}

- (void)__javaClone:(NetI2pRouterRouterThrottleImpl *)original {
  [super __javaClone:original];
  JreCloneVolatileStrong(&_tunnelStatus_, &original->_tunnelStatus_);
}

- (void)dealloc {
  RELEASE_(_context_);
  RELEASE_(_log_);
  JreReleaseVolatile(&_tunnelStatus_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, 3, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "D", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "D", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "D", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "D", 0xa, 6, 7, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1a, 10, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterContext:);
  methods[1].selector = @selector(acceptNetworkMessage);
  methods[2].selector = @selector(acceptNetDbLookupRequestWithNetI2pDataHash:);
  methods[3].selector = @selector(acceptTunnelRequest);
  methods[4].selector = @selector(allowTunnelWithDouble:withInt:);
  methods[5].selector = @selector(getMinThrottleTunnels);
  methods[6].selector = @selector(getTunnelGrowthFactor);
  methods[7].selector = @selector(getTunnelTestTimeGrowthFactor);
  methods[8].selector = @selector(getMessageDelay);
  methods[9].selector = @selector(getTunnelLag);
  methods[10].selector = @selector(getInboundRateDelta);
  methods[11].selector = @selector(getBpsWithNetI2pStatRate:);
  methods[12].selector = @selector(getTunnelStatus);
  methods[13].selector = @selector(setTunnelStatus);
  methods[14].selector = @selector(setShutdownStatus);
  methods[15].selector = @selector(cancelShutdownStatus);
  methods[16].selector = @selector(setTunnelStatusWithNSString:);
  methods[17].selector = @selector(_xWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "_context_", "LNetI2pRouterRouterContext;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "_log_", "LNetI2pUtilLog;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "_tunnelStatus_", "LNSString;", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "_rejectStartupTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "JOB_LAG_LIMIT_NETWORK", "J", .constantValue.asLong = NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETWORK, 0x1a, -1, -1, -1, -1 },
    { "JOB_LAG_LIMIT_NETDB", "J", .constantValue.asLong = NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_NETDB, 0x1a, -1, -1, -1, -1 },
    { "JOB_LAG_LIMIT_TUNNEL", "J", .constantValue.asLong = NetI2pRouterRouterThrottleImpl_JOB_LAG_LIMIT_TUNNEL, 0x1a, -1, -1, -1, -1 },
    { "PROP_MAX_TUNNELS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 11, -1, -1 },
    { "DEFAULT_MAX_TUNNELS", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_TUNNELS, 0x19, -1, -1, -1, -1 },
    { "PROP_MAX_PROCESSINGTIME", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 12, -1, -1 },
    { "DEFAULT_REJECT_STARTUP_TIME", "J", .constantValue.asLong = NetI2pRouterRouterThrottleImpl_DEFAULT_REJECT_STARTUP_TIME, 0x1a, -1, -1, -1, -1 },
    { "MIN_REJECT_STARTUP_TIME", "J", .constantValue.asLong = NetI2pRouterRouterThrottleImpl_MIN_REJECT_STARTUP_TIME, 0x1a, -1, -1, -1, -1 },
    { "PROP_REJECT_STARTUP_TIME", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "DEFAULT_MIN_THROTTLE_TUNNELS", "I", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "DEFAULT_MAX_PROCESSINGTIME", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_DEFAULT_MAX_PROCESSINGTIME, 0x1a, -1, -1, -1, -1 },
    { "TUNNEL_ACCEPT", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_TUNNEL_ACCEPT, 0x19, -1, -1, -1, -1 },
    { "PREPROCESSED_SIZE", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_PREPROCESSED_SIZE, 0x1a, -1, -1, -1, -1 },
    { "DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE, 0x1a, -1, -1, -1, -1 },
    { "MIN_AVAILABLE_BPS", "I", .constantValue.asInt = NetI2pRouterRouterThrottleImpl_MIN_AVAILABLE_BPS, 0x1a, -1, -1, -1, -1 },
    { "LIMIT_STR", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 15, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterContext;", "acceptNetDbLookupRequest", "LNetI2pDataHash;", (void *)&NetI2pRouterRouterThrottleImpl__Annotations$0, "allowTunnel", "DI", "getBps", "LNetI2pStatRate;", "setTunnelStatus", "LNSString;", "_x", &NetI2pRouterRouterThrottleImpl_PROP_MAX_TUNNELS, &NetI2pRouterRouterThrottleImpl_PROP_MAX_PROCESSINGTIME, &NetI2pRouterRouterThrottleImpl_PROP_REJECT_STARTUP_TIME, &NetI2pRouterRouterThrottleImpl_DEFAULT_MIN_THROTTLE_TUNNELS, &NetI2pRouterRouterThrottleImpl_LIMIT_STR, "LNetI2pRouterRouterThrottleImpl_ResetStatus;" };
  static const J2ObjcClassInfo _NetI2pRouterRouterThrottleImpl = { "RouterThrottleImpl", "net.i2p.router", ptrTable, methods, fields, 7, 0x1, 18, 20, -1, 16, -1, -1, -1 };
  return &_NetI2pRouterRouterThrottleImpl;
}

+ (void)initialize {
  if (self == [NetI2pRouterRouterThrottleImpl class]) {
    NetI2pRouterRouterThrottleImpl_DEFAULT_MIN_THROTTLE_TUNNELS = NetI2pUtilSystemVersion_isAndroid() ? 100 : NetI2pUtilSystemVersion_isARM() ? 500 : 1000;
    JreStrongAssign(&NetI2pRouterRouterThrottleImpl_LIMIT_STR, NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Bandwidth limit"));
    J2OBJC_SET_INITIALIZED(NetI2pRouterRouterThrottleImpl)
  }
}

@end

void NetI2pRouterRouterThrottleImpl_initWithNetI2pRouterRouterContext_(NetI2pRouterRouterThrottleImpl *self, NetI2pRouterRouterContext *context) {
  NSObject_init(self);
  JreStrongAssign(&self->_context_, context);
  JreStrongAssign(&self->_log_, [((NetI2pUtilLogManager *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(context)) logManager])) getLogWithIOSClass:NetI2pRouterRouterThrottleImpl_class_()]);
  NetI2pRouterRouterThrottleImpl_setTunnelStatus(self);
  self->_rejectStartupTime_ = JavaLangMath_maxWithLong_withLong_(NetI2pRouterRouterThrottleImpl_MIN_REJECT_STARTUP_TIME, [((NetI2pRouterRouterContext *) nil_chk(self->_context_)) getPropertyWithNSString:NetI2pRouterRouterThrottleImpl_PROP_REJECT_STARTUP_TIME withLong:NetI2pRouterRouterThrottleImpl_DEFAULT_REJECT_STARTUP_TIME]);
  [((NetI2pUtilSimpleTimer2 *) nil_chk([self->_context_ simpleTimer2])) addEventWithNetI2pUtilSimpleTimer_TimedEvent:create_NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(self) withLong:5 * 1000 + self->_rejectStartupTime_];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleNetworkCause" withNSString:@"How lagged the jobQueue was when an I2NP was throttled" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:4]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelCause" withNSString:@"How lagged the jobQueue was when a tunnel request was throttled" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:4]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"tunnel.bytesAllocatedAtAccept" withNSString:@"How many bytes had been 'allocated' for participating tunnels when we accepted a request?" withNSString:@"Tunnels" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelProcessingTime1m" withNSString:@"How long it takes to process a message (1 minute average) when we throttle a tunnel?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:4]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelProcessingTime10m" withNSString:@"How long it takes to process a message (10 minute average) when we throttle a tunnel?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:4]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelMaxExceeded" withNSString:@"How many tunnels we are participating in when we refuse one due to excees?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelProbTooFast" withNSString:@"How many tunnels beyond the previous 1h average are we participating in when we throttle?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelBandwidthExceeded" withNSString:@"How much bandwidth is allocated when we refuse due to bandwidth allocation?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelBytesAllowed" withNSString:@"How many bytes are allowed to be sent when we get a tunnel request (period is how many are currently allocated)?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelBytesUsed" withNSString:@"Used Bps at request (period = max KBps)?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 10 * 60 * 1000, 60 * 60 * 1000, 24 * 60 * 60 * 1000 } count:3]];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) createRateStatWithNSString:@"router.throttleTunnelFailCount1m" withNSString:@"How many messages failed to be sent in the last 2 minutes when we throttle based on a spike in failures (period = 10 minute average failure count)?" withNSString:@"Throttle" withLongArray:[IOSLongArray arrayWithLongs:(jlong[]){ 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000 } count:3]];
}

NetI2pRouterRouterThrottleImpl *new_NetI2pRouterRouterThrottleImpl_initWithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *context) {
  J2OBJC_NEW_IMPL(NetI2pRouterRouterThrottleImpl, initWithNetI2pRouterRouterContext_, context)
}

NetI2pRouterRouterThrottleImpl *create_NetI2pRouterRouterThrottleImpl_initWithNetI2pRouterRouterContext_(NetI2pRouterRouterContext *context) {
  J2OBJC_CREATE_IMPL(NetI2pRouterRouterThrottleImpl, initWithNetI2pRouterRouterContext_, context)
}

jboolean NetI2pRouterRouterThrottleImpl_allowTunnelWithDouble_withInt_(NetI2pRouterRouterThrottleImpl *self, jdouble bytesAllocated, jint numTunnels) {
  jint maxKBpsIn = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) bandwidthLimiter])) getInboundKBytesPerSecond];
  jint maxKBpsOut = [((NetI2pRouterTransportFIFOBandwidthLimiter *) nil_chk([self->_context_ bandwidthLimiter])) getOutboundKBytesPerSecond];
  jint maxKBps = JavaLangMath_minWithInt_withInt_(maxKBpsIn, maxKBpsOut);
  jint usedIn = JavaLangMath_minWithInt_withInt_([((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get1sRateIn], [((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get15sRateIn]);
  jint usedOut = JavaLangMath_minWithInt_withInt_([((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get1sRateWithBoolean:true], [((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get15sRateWithBoolean:true]);
  jint used = JavaLangMath_maxWithInt_withInt_(usedIn, usedOut);
  jint used1mIn = [((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get1mRateIn];
  jint used1mOut = [((NetI2pRouterRouter *) nil_chk([self->_context_ router])) get1mRateWithBoolean:true];
  jint availBps = JavaLangMath_minWithInt_withInt_((maxKBpsIn * 1024 * 9 / 10) - usedIn, (maxKBpsOut * 1024 * 9 / 10) - usedOut);
  if (availBps < NetI2pRouterRouterThrottleImpl_MIN_AVAILABLE_BPS) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$I$", @"Reject, avail (", availBps, @") less than min")];
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl_LIMIT_STR];
    return false;
  }
  jdouble share = [((NetI2pRouterRouter *) nil_chk([self->_context_ router])) getSharePercentage];
  used = JavaLangMath_minWithInt_withInt_(used, JreFpToInt((bytesAllocated / (10 * 60))));
  availBps = JavaLangMath_minWithInt_withInt_(availBps, JreFpToInt((((maxKBps * 1024) * share) - used)));
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"router.throttleTunnelBytesUsed" withLong:used withLong:maxKBps];
  [((NetI2pStatStatManager *) nil_chk([self->_context_ statManager])) addRateDataWithNSString:@"router.throttleTunnelBytesAllowed" withLong:availBps withLong:JreFpToLong(bytesAllocated)];
  jlong overage = JavaLangMath_maxWithInt_withInt_(used1mIn - (maxKBpsIn * 1024), used1mOut - (maxKBpsOut * 1024));
  if ((overage > 0) && ((overage / (maxKBps * 1024.0f)) > [((NetI2pUtilRandomSource *) nil_chk([self->_context_ random])) nextFloat])) {
    if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [self->_log_ warnWithNSString:JreStrcat("$J$", @"Reject tunnel, 1m rate (", overage, @" over) indicates overload.")];
    [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl_LIMIT_STR];
    return false;
  }
  jfloat maxBps = (maxKBps * 1024.0f * 0.9f) - NetI2pRouterRouterThrottleImpl_MIN_AVAILABLE_BPS;
  jfloat pctFull = (maxBps - availBps) / (maxBps);
  jdouble probReject = JavaLangMath_powWithDouble_withDouble_(pctFull, 16);
  jdouble rand = [((NetI2pUtilRandomSource *) nil_chk([self->_context_ random])) nextFloat];
  jboolean reject = rand <= probReject;
  if (reject && [((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_WARN]) [((NetI2pUtilLog *) nil_chk(self->_log_)) warnWithNSString:JreStrcat("$ICICI$D$F$I$D$D", @"Reject avail/maxK/used ", availBps, '/', maxKBps, '/', used, @" pReject = ", probReject, @" pFull = ", pctFull, @" numTunnels = ", numTunnels, @" rand = ", rand, @" est = ", bytesAllocated)];
  else if ([((NetI2pUtilLog *) nil_chk(self->_log_)) shouldLogWithInt:NetI2pUtilLog_DEBUG]) [self->_log_ debugWithNSString:JreStrcat("$ICICI$D$F$I$D$D", @"Accept avail/maxK/used ", availBps, '/', maxKBps, '/', used, @" pReject = ", probReject, @" pFull = ", pctFull, @" numTunnels = ", numTunnels, @" rand = ", rand, @" est = ", bytesAllocated)];
  if (probReject >= 0.9) [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl_LIMIT_STR];
  else if (probReject >= 0.5) [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting most tunnels: Bandwidth limit")];
  else if (probReject >= 0.1) [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Accepting most tunnels")];
  else [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Accepting tunnels")];
  return !reject;
}

jint NetI2pRouterRouterThrottleImpl_getMinThrottleTunnels(NetI2pRouterRouterThrottleImpl *self) {
  return [((NetI2pRouterRouterContext *) nil_chk(self->_context_)) getPropertyWithNSString:@"router.minThrottleTunnels" withInt:NetI2pRouterRouterThrottleImpl_DEFAULT_MIN_THROTTLE_TUNNELS];
}

jdouble NetI2pRouterRouterThrottleImpl_getTunnelGrowthFactor(NetI2pRouterRouterThrottleImpl *self) {
  @try {
    return JavaLangDouble_parseDoubleWithNSString_([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) getPropertyWithNSString:@"router.tunnelGrowthFactor" withNSString:@"1.3"]);
  }
  @catch (JavaLangNumberFormatException *nfe) {
    return 1.3;
  }
}

jdouble NetI2pRouterRouterThrottleImpl_getTunnelTestTimeGrowthFactor(NetI2pRouterRouterThrottleImpl *self) {
  @try {
    return JavaLangDouble_parseDoubleWithNSString_([((NetI2pRouterRouterContext *) nil_chk(self->_context_)) getPropertyWithNSString:@"router.tunnelTestTimeGrowthFactor" withNSString:@"1.3"]);
  }
  @catch (JavaLangNumberFormatException *nfe) {
    return 1.3;
  }
}

jdouble NetI2pRouterRouterThrottleImpl_getBpsWithNetI2pStatRate_(NetI2pStatRate *rate) {
  NetI2pRouterRouterThrottleImpl_initialize();
  if (rate == nil) return -1;
  jdouble bytes = [rate getLastTotalValue];
  return (bytes * 1000.0) / [rate getPeriod];
}

void NetI2pRouterRouterThrottleImpl_setTunnelStatus(NetI2pRouterRouterThrottleImpl *self) {
  [self setTunnelStatusWithNSString:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Starting up")];
}

NSString *NetI2pRouterRouterThrottleImpl__xWithNSString_(NSString *s) {
  NetI2pRouterRouterThrottleImpl_initialize();
  return s;
}

IOSObjectArray *NetI2pRouterRouterThrottleImpl__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterRouterThrottleImpl)

@implementation NetI2pRouterRouterThrottleImpl_ResetStatus

- (instancetype)initWithNetI2pRouterRouterThrottleImpl:(NetI2pRouterRouterThrottleImpl *)outer$ {
  NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(self, outer$);
  return self;
}

- (void)timeReached {
  if ([((NSString *) nil_chk(JreLoadVolatileId(&this$0_->_tunnelStatus_))) isEqual:NetI2pRouterRouterThrottleImpl__xWithNSString_(@"Rejecting tunnels: Starting up")]) [this$0_ cancelShutdownStatus];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNetI2pRouterRouterThrottleImpl:);
  methods[1].selector = @selector(timeReached);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LNetI2pRouterRouterThrottleImpl;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetI2pRouterRouterThrottleImpl;" };
  static const J2ObjcClassInfo _NetI2pRouterRouterThrottleImpl_ResetStatus = { "ResetStatus", "net.i2p.router", ptrTable, methods, fields, 7, 0x2, 2, 1, 0, -1, -1, -1, -1 };
  return &_NetI2pRouterRouterThrottleImpl_ResetStatus;
}

@end

void NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl_ResetStatus *self, NetI2pRouterRouterThrottleImpl *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
}

NetI2pRouterRouterThrottleImpl_ResetStatus *new_NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl *outer$) {
  J2OBJC_NEW_IMPL(NetI2pRouterRouterThrottleImpl_ResetStatus, initWithNetI2pRouterRouterThrottleImpl_, outer$)
}

NetI2pRouterRouterThrottleImpl_ResetStatus *create_NetI2pRouterRouterThrottleImpl_ResetStatus_initWithNetI2pRouterRouterThrottleImpl_(NetI2pRouterRouterThrottleImpl *outer$) {
  J2OBJC_CREATE_IMPL(NetI2pRouterRouterThrottleImpl_ResetStatus, initWithNetI2pRouterRouterThrottleImpl_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetI2pRouterRouterThrottleImpl_ResetStatus)
